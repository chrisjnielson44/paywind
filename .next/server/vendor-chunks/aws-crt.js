"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/aws-crt";
exports.ids = ["vendor-chunks/aws-crt"];
exports.modules = {

/***/ "(ssr)/./node_modules/aws-crt/dist/common/aws_iot_shared.js":
/*!************************************************************!*\
  !*** ./node_modules/aws-crt/dist/common/aws_iot_shared.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n * SPDX-License-Identifier: Apache-2.0.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.extractRegionFromEndpoint = exports.buildMqtt5FinalUsername = exports.populate_username_string_with_custom_authorizer = exports.is_string_and_not_empty = exports.add_to_username_parameter = void 0;\n/**\n *\n * A module containing miscellaneous functionality that is shared across both native and browser for aws_iot\n *\n * @packageDocumentation\n * @module aws_iot\n */\nconst platform = __importStar(__webpack_require__(/*! ./platform */ \"(ssr)/./node_modules/aws-crt/dist/common/platform.js\"));\n/**\n * A helper function to add parameters to the username in with_custom_authorizer function\n *\n * @internal\n */\nfunction add_to_username_parameter(current_username, parameter_value, parameter_pre_text) {\n    let return_string = current_username;\n    if (return_string.indexOf(\"?\") != -1) {\n        return_string += \"&\";\n    }\n    else {\n        return_string += \"?\";\n    }\n    if (parameter_value.indexOf(parameter_pre_text) != -1) {\n        return return_string + parameter_value;\n    }\n    else {\n        return return_string + parameter_pre_text + parameter_value;\n    }\n}\nexports.add_to_username_parameter = add_to_username_parameter;\n/**\n * A helper function to see if a string is not null, is defined, and is not an empty string\n *\n * @internal\n */\nfunction is_string_and_not_empty(item) {\n    return item != undefined && typeof (item) == 'string' && item != \"\";\n}\nexports.is_string_and_not_empty = is_string_and_not_empty;\n/**\n * A helper function to populate the username with the Custom Authorizer fields\n * @param current_username the current username\n * @param input_username the username to add - can be an empty string to skip\n * @param input_authorizer the name of the authorizer to add - can be an empty string to skip\n * @param input_signature the name of the signature to add - can be an empty string to skip\n * @param input_builder_username the username from the MQTT builder\n * @param input_token_key_name the token key name\n * @param input_token_value the token key value\n * @returns The finished username with the additions added to it\n *\n * @internal\n */\nfunction populate_username_string_with_custom_authorizer(current_username, input_username, input_authorizer, input_signature, input_builder_username, input_token_key_name, input_token_value) {\n    let username_string = \"\";\n    if (current_username) {\n        username_string += current_username;\n    }\n    if (is_string_and_not_empty(input_username) == false) {\n        if (is_string_and_not_empty(input_builder_username) && input_builder_username) {\n            username_string += input_builder_username;\n        }\n    }\n    else {\n        username_string += input_username;\n    }\n    if (is_string_and_not_empty(input_authorizer) && input_authorizer) {\n        username_string = add_to_username_parameter(username_string, input_authorizer, \"x-amz-customauthorizer-name=\");\n    }\n    if (is_string_and_not_empty(input_signature) && input_signature) {\n        username_string = add_to_username_parameter(username_string, input_signature, \"x-amz-customauthorizer-signature=\");\n        if ((is_string_and_not_empty(input_token_key_name) && input_token_key_name) || (is_string_and_not_empty(input_token_value) && input_token_value)) {\n            console.log(\"Warning: Signed custom authorizers with signature will not work without a token key name and \" +\n                \"token value. Your connection may be rejected/stalled on the IoT Core side due to this. Please \" +\n                \"set the token key name and token value to connect to a signed custom authorizer.\");\n        }\n    }\n    if (is_string_and_not_empty(input_signature) || is_string_and_not_empty(input_token_value) || is_string_and_not_empty(input_token_key_name)) {\n        if (!input_token_value || !input_token_key_name) {\n            throw new Error(\"Token-based custom authentication requires all token-related properties to be set\");\n        }\n        username_string = add_to_username_parameter(username_string, input_token_value, input_token_key_name + \"=\");\n    }\n    return username_string;\n}\nexports.populate_username_string_with_custom_authorizer = populate_username_string_with_custom_authorizer;\n;\n/** @internal */\nfunction addParam(paramName, paramValue, paramSet) {\n    if (paramValue) {\n        paramSet.push([paramName, paramValue]);\n    }\n}\n/**\n * Builds the final value for the CONNECT packet's username property based on AWS IoT custom auth configuration\n * and SDK metrics properties.\n *\n * @param customAuthConfig intended AWS IoT custom auth client configuration\n *\n * @internal\n */\nfunction buildMqtt5FinalUsername(customAuthConfig) {\n    let path = \"\";\n    let paramList = [];\n    if (customAuthConfig) {\n        /* If we're using token-signing authentication, then all token properties must be set */\n        let usingSigning = false;\n        if (customAuthConfig.tokenValue || customAuthConfig.tokenKeyName || customAuthConfig.tokenSignature) {\n            usingSigning = true;\n            if (!customAuthConfig.tokenValue || !customAuthConfig.tokenKeyName || !customAuthConfig.tokenSignature) {\n                throw new Error(\"Token-based custom authentication requires all token-related properties to be set\");\n            }\n        }\n        let username = customAuthConfig.username;\n        let pathSplit = (username !== null && username !== void 0 ? username : \"\").split(\"?\");\n        let params = pathSplit.slice(1);\n        path = pathSplit[0];\n        if (params.length > 1) {\n            throw new Error(\"Custom auth username property value is invalid\");\n        }\n        else if (params.length == 1) {\n            params[0].split(\"&\").forEach((keyValue, index, array) => {\n                var _a;\n                let kvPair = keyValue.split(\"=\");\n                paramList.push([kvPair[0], (_a = kvPair[1]) !== null && _a !== void 0 ? _a : \"\"]);\n            });\n        }\n        addParam(\"x-amz-customauthorizer-name\", customAuthConfig.authorizerName, paramList);\n        if (usingSigning) {\n            // @ts-ignore verified earlier\n            addParam(customAuthConfig.tokenKeyName, customAuthConfig.tokenValue, paramList);\n            addParam(\"x-amz-customauthorizer-signature\", customAuthConfig.tokenSignature, paramList);\n        }\n    }\n    paramList.push([\"SDK\", \"NodeJSv2\"]);\n    paramList.push([\"Version\", platform.crt_version()]);\n    return (path !== null && path !== void 0 ? path : \"\") + \"?\" + paramList.map((value) => `${value[0]}=${value[1]}`).join(\"&\");\n}\nexports.buildMqtt5FinalUsername = buildMqtt5FinalUsername;\n/**\n * Attempts to determine the AWS region associated with an endpoint.\n *\n * @param endpoint endpoint to compute the region for\n *\n * @internal\n */\nfunction extractRegionFromEndpoint(endpoint) {\n    const regexpRegion = /^[\\w\\-]+\\.[\\w\\-]+\\.([\\w+\\-]+)\\./;\n    const match = endpoint.match(regexpRegion);\n    if (match) {\n        return match[1];\n    }\n    throw new Error(\"AWS region could not be extracted from endpoint.  Use 'region' property on WebsocketConfig to set manually.\");\n}\nexports.extractRegionFromEndpoint = extractRegionFromEndpoint;\n//# sourceMappingURL=aws_iot_shared.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXdzLWNydC9kaXN0L2NvbW1vbi9hd3NfaW90X3NoYXJlZC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQ0FBaUMsR0FBRywrQkFBK0IsR0FBRyx1REFBdUQsR0FBRywrQkFBK0IsR0FBRyxpQ0FBaUM7QUFDbk07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsbUJBQU8sQ0FBQyx3RUFBWTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RixTQUFTLEdBQUcsU0FBUztBQUNuSDtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wYXl3aW5kLy4vbm9kZV9tb2R1bGVzL2F3cy1jcnQvZGlzdC9jb21tb24vYXdzX2lvdF9zaGFyZWQuanM/NzhiMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wLlxuICovXG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZXh0cmFjdFJlZ2lvbkZyb21FbmRwb2ludCA9IGV4cG9ydHMuYnVpbGRNcXR0NUZpbmFsVXNlcm5hbWUgPSBleHBvcnRzLnBvcHVsYXRlX3VzZXJuYW1lX3N0cmluZ193aXRoX2N1c3RvbV9hdXRob3JpemVyID0gZXhwb3J0cy5pc19zdHJpbmdfYW5kX25vdF9lbXB0eSA9IGV4cG9ydHMuYWRkX3RvX3VzZXJuYW1lX3BhcmFtZXRlciA9IHZvaWQgMDtcbi8qKlxuICpcbiAqIEEgbW9kdWxlIGNvbnRhaW5pbmcgbWlzY2VsbGFuZW91cyBmdW5jdGlvbmFsaXR5IHRoYXQgaXMgc2hhcmVkIGFjcm9zcyBib3RoIG5hdGl2ZSBhbmQgYnJvd3NlciBmb3IgYXdzX2lvdFxuICpcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuICogQG1vZHVsZSBhd3NfaW90XG4gKi9cbmNvbnN0IHBsYXRmb3JtID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3BsYXRmb3JtXCIpKTtcbi8qKlxuICogQSBoZWxwZXIgZnVuY3Rpb24gdG8gYWRkIHBhcmFtZXRlcnMgdG8gdGhlIHVzZXJuYW1lIGluIHdpdGhfY3VzdG9tX2F1dGhvcml6ZXIgZnVuY3Rpb25cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gYWRkX3RvX3VzZXJuYW1lX3BhcmFtZXRlcihjdXJyZW50X3VzZXJuYW1lLCBwYXJhbWV0ZXJfdmFsdWUsIHBhcmFtZXRlcl9wcmVfdGV4dCkge1xuICAgIGxldCByZXR1cm5fc3RyaW5nID0gY3VycmVudF91c2VybmFtZTtcbiAgICBpZiAocmV0dXJuX3N0cmluZy5pbmRleE9mKFwiP1wiKSAhPSAtMSkge1xuICAgICAgICByZXR1cm5fc3RyaW5nICs9IFwiJlwiO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuX3N0cmluZyArPSBcIj9cIjtcbiAgICB9XG4gICAgaWYgKHBhcmFtZXRlcl92YWx1ZS5pbmRleE9mKHBhcmFtZXRlcl9wcmVfdGV4dCkgIT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHJldHVybl9zdHJpbmcgKyBwYXJhbWV0ZXJfdmFsdWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gcmV0dXJuX3N0cmluZyArIHBhcmFtZXRlcl9wcmVfdGV4dCArIHBhcmFtZXRlcl92YWx1ZTtcbiAgICB9XG59XG5leHBvcnRzLmFkZF90b191c2VybmFtZV9wYXJhbWV0ZXIgPSBhZGRfdG9fdXNlcm5hbWVfcGFyYW1ldGVyO1xuLyoqXG4gKiBBIGhlbHBlciBmdW5jdGlvbiB0byBzZWUgaWYgYSBzdHJpbmcgaXMgbm90IG51bGwsIGlzIGRlZmluZWQsIGFuZCBpcyBub3QgYW4gZW1wdHkgc3RyaW5nXG4gKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGlzX3N0cmluZ19hbmRfbm90X2VtcHR5KGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbSAhPSB1bmRlZmluZWQgJiYgdHlwZW9mIChpdGVtKSA9PSAnc3RyaW5nJyAmJiBpdGVtICE9IFwiXCI7XG59XG5leHBvcnRzLmlzX3N0cmluZ19hbmRfbm90X2VtcHR5ID0gaXNfc3RyaW5nX2FuZF9ub3RfZW1wdHk7XG4vKipcbiAqIEEgaGVscGVyIGZ1bmN0aW9uIHRvIHBvcHVsYXRlIHRoZSB1c2VybmFtZSB3aXRoIHRoZSBDdXN0b20gQXV0aG9yaXplciBmaWVsZHNcbiAqIEBwYXJhbSBjdXJyZW50X3VzZXJuYW1lIHRoZSBjdXJyZW50IHVzZXJuYW1lXG4gKiBAcGFyYW0gaW5wdXRfdXNlcm5hbWUgdGhlIHVzZXJuYW1lIHRvIGFkZCAtIGNhbiBiZSBhbiBlbXB0eSBzdHJpbmcgdG8gc2tpcFxuICogQHBhcmFtIGlucHV0X2F1dGhvcml6ZXIgdGhlIG5hbWUgb2YgdGhlIGF1dGhvcml6ZXIgdG8gYWRkIC0gY2FuIGJlIGFuIGVtcHR5IHN0cmluZyB0byBza2lwXG4gKiBAcGFyYW0gaW5wdXRfc2lnbmF0dXJlIHRoZSBuYW1lIG9mIHRoZSBzaWduYXR1cmUgdG8gYWRkIC0gY2FuIGJlIGFuIGVtcHR5IHN0cmluZyB0byBza2lwXG4gKiBAcGFyYW0gaW5wdXRfYnVpbGRlcl91c2VybmFtZSB0aGUgdXNlcm5hbWUgZnJvbSB0aGUgTVFUVCBidWlsZGVyXG4gKiBAcGFyYW0gaW5wdXRfdG9rZW5fa2V5X25hbWUgdGhlIHRva2VuIGtleSBuYW1lXG4gKiBAcGFyYW0gaW5wdXRfdG9rZW5fdmFsdWUgdGhlIHRva2VuIGtleSB2YWx1ZVxuICogQHJldHVybnMgVGhlIGZpbmlzaGVkIHVzZXJuYW1lIHdpdGggdGhlIGFkZGl0aW9ucyBhZGRlZCB0byBpdFxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBwb3B1bGF0ZV91c2VybmFtZV9zdHJpbmdfd2l0aF9jdXN0b21fYXV0aG9yaXplcihjdXJyZW50X3VzZXJuYW1lLCBpbnB1dF91c2VybmFtZSwgaW5wdXRfYXV0aG9yaXplciwgaW5wdXRfc2lnbmF0dXJlLCBpbnB1dF9idWlsZGVyX3VzZXJuYW1lLCBpbnB1dF90b2tlbl9rZXlfbmFtZSwgaW5wdXRfdG9rZW5fdmFsdWUpIHtcbiAgICBsZXQgdXNlcm5hbWVfc3RyaW5nID0gXCJcIjtcbiAgICBpZiAoY3VycmVudF91c2VybmFtZSkge1xuICAgICAgICB1c2VybmFtZV9zdHJpbmcgKz0gY3VycmVudF91c2VybmFtZTtcbiAgICB9XG4gICAgaWYgKGlzX3N0cmluZ19hbmRfbm90X2VtcHR5KGlucHV0X3VzZXJuYW1lKSA9PSBmYWxzZSkge1xuICAgICAgICBpZiAoaXNfc3RyaW5nX2FuZF9ub3RfZW1wdHkoaW5wdXRfYnVpbGRlcl91c2VybmFtZSkgJiYgaW5wdXRfYnVpbGRlcl91c2VybmFtZSkge1xuICAgICAgICAgICAgdXNlcm5hbWVfc3RyaW5nICs9IGlucHV0X2J1aWxkZXJfdXNlcm5hbWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHVzZXJuYW1lX3N0cmluZyArPSBpbnB1dF91c2VybmFtZTtcbiAgICB9XG4gICAgaWYgKGlzX3N0cmluZ19hbmRfbm90X2VtcHR5KGlucHV0X2F1dGhvcml6ZXIpICYmIGlucHV0X2F1dGhvcml6ZXIpIHtcbiAgICAgICAgdXNlcm5hbWVfc3RyaW5nID0gYWRkX3RvX3VzZXJuYW1lX3BhcmFtZXRlcih1c2VybmFtZV9zdHJpbmcsIGlucHV0X2F1dGhvcml6ZXIsIFwieC1hbXotY3VzdG9tYXV0aG9yaXplci1uYW1lPVwiKTtcbiAgICB9XG4gICAgaWYgKGlzX3N0cmluZ19hbmRfbm90X2VtcHR5KGlucHV0X3NpZ25hdHVyZSkgJiYgaW5wdXRfc2lnbmF0dXJlKSB7XG4gICAgICAgIHVzZXJuYW1lX3N0cmluZyA9IGFkZF90b191c2VybmFtZV9wYXJhbWV0ZXIodXNlcm5hbWVfc3RyaW5nLCBpbnB1dF9zaWduYXR1cmUsIFwieC1hbXotY3VzdG9tYXV0aG9yaXplci1zaWduYXR1cmU9XCIpO1xuICAgICAgICBpZiAoKGlzX3N0cmluZ19hbmRfbm90X2VtcHR5KGlucHV0X3Rva2VuX2tleV9uYW1lKSAmJiBpbnB1dF90b2tlbl9rZXlfbmFtZSkgfHwgKGlzX3N0cmluZ19hbmRfbm90X2VtcHR5KGlucHV0X3Rva2VuX3ZhbHVlKSAmJiBpbnB1dF90b2tlbl92YWx1ZSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiV2FybmluZzogU2lnbmVkIGN1c3RvbSBhdXRob3JpemVycyB3aXRoIHNpZ25hdHVyZSB3aWxsIG5vdCB3b3JrIHdpdGhvdXQgYSB0b2tlbiBrZXkgbmFtZSBhbmQgXCIgK1xuICAgICAgICAgICAgICAgIFwidG9rZW4gdmFsdWUuIFlvdXIgY29ubmVjdGlvbiBtYXkgYmUgcmVqZWN0ZWQvc3RhbGxlZCBvbiB0aGUgSW9UIENvcmUgc2lkZSBkdWUgdG8gdGhpcy4gUGxlYXNlIFwiICtcbiAgICAgICAgICAgICAgICBcInNldCB0aGUgdG9rZW4ga2V5IG5hbWUgYW5kIHRva2VuIHZhbHVlIHRvIGNvbm5lY3QgdG8gYSBzaWduZWQgY3VzdG9tIGF1dGhvcml6ZXIuXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpc19zdHJpbmdfYW5kX25vdF9lbXB0eShpbnB1dF9zaWduYXR1cmUpIHx8IGlzX3N0cmluZ19hbmRfbm90X2VtcHR5KGlucHV0X3Rva2VuX3ZhbHVlKSB8fCBpc19zdHJpbmdfYW5kX25vdF9lbXB0eShpbnB1dF90b2tlbl9rZXlfbmFtZSkpIHtcbiAgICAgICAgaWYgKCFpbnB1dF90b2tlbl92YWx1ZSB8fCAhaW5wdXRfdG9rZW5fa2V5X25hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRva2VuLWJhc2VkIGN1c3RvbSBhdXRoZW50aWNhdGlvbiByZXF1aXJlcyBhbGwgdG9rZW4tcmVsYXRlZCBwcm9wZXJ0aWVzIHRvIGJlIHNldFwiKTtcbiAgICAgICAgfVxuICAgICAgICB1c2VybmFtZV9zdHJpbmcgPSBhZGRfdG9fdXNlcm5hbWVfcGFyYW1ldGVyKHVzZXJuYW1lX3N0cmluZywgaW5wdXRfdG9rZW5fdmFsdWUsIGlucHV0X3Rva2VuX2tleV9uYW1lICsgXCI9XCIpO1xuICAgIH1cbiAgICByZXR1cm4gdXNlcm5hbWVfc3RyaW5nO1xufVxuZXhwb3J0cy5wb3B1bGF0ZV91c2VybmFtZV9zdHJpbmdfd2l0aF9jdXN0b21fYXV0aG9yaXplciA9IHBvcHVsYXRlX3VzZXJuYW1lX3N0cmluZ193aXRoX2N1c3RvbV9hdXRob3JpemVyO1xuO1xuLyoqIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gYWRkUGFyYW0ocGFyYW1OYW1lLCBwYXJhbVZhbHVlLCBwYXJhbVNldCkge1xuICAgIGlmIChwYXJhbVZhbHVlKSB7XG4gICAgICAgIHBhcmFtU2V0LnB1c2goW3BhcmFtTmFtZSwgcGFyYW1WYWx1ZV0pO1xuICAgIH1cbn1cbi8qKlxuICogQnVpbGRzIHRoZSBmaW5hbCB2YWx1ZSBmb3IgdGhlIENPTk5FQ1QgcGFja2V0J3MgdXNlcm5hbWUgcHJvcGVydHkgYmFzZWQgb24gQVdTIElvVCBjdXN0b20gYXV0aCBjb25maWd1cmF0aW9uXG4gKiBhbmQgU0RLIG1ldHJpY3MgcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0gY3VzdG9tQXV0aENvbmZpZyBpbnRlbmRlZCBBV1MgSW9UIGN1c3RvbSBhdXRoIGNsaWVudCBjb25maWd1cmF0aW9uXG4gKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkTXF0dDVGaW5hbFVzZXJuYW1lKGN1c3RvbUF1dGhDb25maWcpIHtcbiAgICBsZXQgcGF0aCA9IFwiXCI7XG4gICAgbGV0IHBhcmFtTGlzdCA9IFtdO1xuICAgIGlmIChjdXN0b21BdXRoQ29uZmlnKSB7XG4gICAgICAgIC8qIElmIHdlJ3JlIHVzaW5nIHRva2VuLXNpZ25pbmcgYXV0aGVudGljYXRpb24sIHRoZW4gYWxsIHRva2VuIHByb3BlcnRpZXMgbXVzdCBiZSBzZXQgKi9cbiAgICAgICAgbGV0IHVzaW5nU2lnbmluZyA9IGZhbHNlO1xuICAgICAgICBpZiAoY3VzdG9tQXV0aENvbmZpZy50b2tlblZhbHVlIHx8IGN1c3RvbUF1dGhDb25maWcudG9rZW5LZXlOYW1lIHx8IGN1c3RvbUF1dGhDb25maWcudG9rZW5TaWduYXR1cmUpIHtcbiAgICAgICAgICAgIHVzaW5nU2lnbmluZyA9IHRydWU7XG4gICAgICAgICAgICBpZiAoIWN1c3RvbUF1dGhDb25maWcudG9rZW5WYWx1ZSB8fCAhY3VzdG9tQXV0aENvbmZpZy50b2tlbktleU5hbWUgfHwgIWN1c3RvbUF1dGhDb25maWcudG9rZW5TaWduYXR1cmUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUb2tlbi1iYXNlZCBjdXN0b20gYXV0aGVudGljYXRpb24gcmVxdWlyZXMgYWxsIHRva2VuLXJlbGF0ZWQgcHJvcGVydGllcyB0byBiZSBzZXRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHVzZXJuYW1lID0gY3VzdG9tQXV0aENvbmZpZy51c2VybmFtZTtcbiAgICAgICAgbGV0IHBhdGhTcGxpdCA9ICh1c2VybmFtZSAhPT0gbnVsbCAmJiB1c2VybmFtZSAhPT0gdm9pZCAwID8gdXNlcm5hbWUgOiBcIlwiKS5zcGxpdChcIj9cIik7XG4gICAgICAgIGxldCBwYXJhbXMgPSBwYXRoU3BsaXQuc2xpY2UoMSk7XG4gICAgICAgIHBhdGggPSBwYXRoU3BsaXRbMF07XG4gICAgICAgIGlmIChwYXJhbXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ3VzdG9tIGF1dGggdXNlcm5hbWUgcHJvcGVydHkgdmFsdWUgaXMgaW52YWxpZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJhbXMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgIHBhcmFtc1swXS5zcGxpdChcIiZcIikuZm9yRWFjaCgoa2V5VmFsdWUsIGluZGV4LCBhcnJheSkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBsZXQga3ZQYWlyID0ga2V5VmFsdWUuc3BsaXQoXCI9XCIpO1xuICAgICAgICAgICAgICAgIHBhcmFtTGlzdC5wdXNoKFtrdlBhaXJbMF0sIChfYSA9IGt2UGFpclsxXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIl0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkUGFyYW0oXCJ4LWFtei1jdXN0b21hdXRob3JpemVyLW5hbWVcIiwgY3VzdG9tQXV0aENvbmZpZy5hdXRob3JpemVyTmFtZSwgcGFyYW1MaXN0KTtcbiAgICAgICAgaWYgKHVzaW5nU2lnbmluZykge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSB2ZXJpZmllZCBlYXJsaWVyXG4gICAgICAgICAgICBhZGRQYXJhbShjdXN0b21BdXRoQ29uZmlnLnRva2VuS2V5TmFtZSwgY3VzdG9tQXV0aENvbmZpZy50b2tlblZhbHVlLCBwYXJhbUxpc3QpO1xuICAgICAgICAgICAgYWRkUGFyYW0oXCJ4LWFtei1jdXN0b21hdXRob3JpemVyLXNpZ25hdHVyZVwiLCBjdXN0b21BdXRoQ29uZmlnLnRva2VuU2lnbmF0dXJlLCBwYXJhbUxpc3QpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBhcmFtTGlzdC5wdXNoKFtcIlNES1wiLCBcIk5vZGVKU3YyXCJdKTtcbiAgICBwYXJhbUxpc3QucHVzaChbXCJWZXJzaW9uXCIsIHBsYXRmb3JtLmNydF92ZXJzaW9uKCldKTtcbiAgICByZXR1cm4gKHBhdGggIT09IG51bGwgJiYgcGF0aCAhPT0gdm9pZCAwID8gcGF0aCA6IFwiXCIpICsgXCI/XCIgKyBwYXJhbUxpc3QubWFwKCh2YWx1ZSkgPT4gYCR7dmFsdWVbMF19PSR7dmFsdWVbMV19YCkuam9pbihcIiZcIik7XG59XG5leHBvcnRzLmJ1aWxkTXF0dDVGaW5hbFVzZXJuYW1lID0gYnVpbGRNcXR0NUZpbmFsVXNlcm5hbWU7XG4vKipcbiAqIEF0dGVtcHRzIHRvIGRldGVybWluZSB0aGUgQVdTIHJlZ2lvbiBhc3NvY2lhdGVkIHdpdGggYW4gZW5kcG9pbnQuXG4gKlxuICogQHBhcmFtIGVuZHBvaW50IGVuZHBvaW50IHRvIGNvbXB1dGUgdGhlIHJlZ2lvbiBmb3JcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZXh0cmFjdFJlZ2lvbkZyb21FbmRwb2ludChlbmRwb2ludCkge1xuICAgIGNvbnN0IHJlZ2V4cFJlZ2lvbiA9IC9eW1xcd1xcLV0rXFwuW1xcd1xcLV0rXFwuKFtcXHcrXFwtXSspXFwuLztcbiAgICBjb25zdCBtYXRjaCA9IGVuZHBvaW50Lm1hdGNoKHJlZ2V4cFJlZ2lvbik7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIHJldHVybiBtYXRjaFsxXTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQVdTIHJlZ2lvbiBjb3VsZCBub3QgYmUgZXh0cmFjdGVkIGZyb20gZW5kcG9pbnQuICBVc2UgJ3JlZ2lvbicgcHJvcGVydHkgb24gV2Vic29ja2V0Q29uZmlnIHRvIHNldCBtYW51YWxseS5cIik7XG59XG5leHBvcnRzLmV4dHJhY3RSZWdpb25Gcm9tRW5kcG9pbnQgPSBleHRyYWN0UmVnaW9uRnJvbUVuZHBvaW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXdzX2lvdF9zaGFyZWQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/aws-crt/dist/common/aws_iot_shared.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/aws-crt/dist/common/cancel.js":
/*!****************************************************!*\
  !*** ./node_modules/aws-crt/dist/common/cancel.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n * SPDX-License-Identifier: Apache-2.0.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.newCancellablePromiseFromNextEvent = exports.CancelController = exports.EVENT_NAME = void 0;\n/**\n *\n * A module containing support for cancelling asynchronous operations\n *\n * @packageDocumentation\n * @module cancel\n */\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst promise = __importStar(__webpack_require__(/*! ./promise */ \"(ssr)/./node_modules/aws-crt/dist/common/promise.js\"));\nexports.EVENT_NAME = 'cancelled';\n/**\n * CRT implementation of the ICancelController interface\n */\nclass CancelController {\n    constructor(options) {\n        this.cancelled = false;\n        if (options && options.emitterFactory) {\n            this.emitter = options.emitterFactory();\n        }\n        else {\n            this.emitter = new events_1.EventEmitter();\n        }\n    }\n    /**\n     * Cancels all asynchronous operations associated with this controller\n     */\n    cancel() {\n        if (!this.cancelled) {\n            this.cancelled = true;\n            this.emitter.emit(exports.EVENT_NAME);\n            this.emitter.removeAllListeners(exports.EVENT_NAME);\n        }\n    }\n    /**\n     * Checks whether or not the controller is in the cancelled state\n     */\n    hasBeenCancelled() {\n        return this.cancelled;\n    }\n    /**\n     * Registers a callback to be notified when cancel() is invoked externally.  In general, the callback\n     * will cancel an asynchronous operation by rejecting the associated promise.\n     *\n     * IMPORTANT: The listener is invoked synchronously if the controller has already been cancelled.\n     *\n     * @param listener - function to invoke on cancel; invoked synchronously if the controller has been cancelled\n     *\n     * @return undefined if the controller has already been cancelled, otherwise a function object whose invocation\n     * will remove the listener from the controller's event emitter.\n     *\n     */\n    addListener(listener) {\n        if (this.cancelled) {\n            listener();\n            return undefined;\n        }\n        this.emitter.on(exports.EVENT_NAME, listener);\n        return () => { this.emitter.removeListener(exports.EVENT_NAME, listener); };\n    }\n}\nexports.CancelController = CancelController;\n/**\n * Creates a promise that can be rejected by a CancelController and resolved by the receipt of an event from an\n * EventEmitter.\n *\n * @param config promise creation options\n */\nfunction newCancellablePromiseFromNextEvent(config) {\n    let onEvent = undefined;\n    let cancelRemoveListener = undefined;\n    let liftedPromise = promise.newLiftedPromise();\n    onEvent = (eventData) => {\n        try {\n            if (config.eventDataTransformer) {\n                liftedPromise.resolve(config.eventDataTransformer(eventData));\n            }\n            else {\n                liftedPromise.resolve(eventData);\n            }\n        }\n        catch (err) {\n            liftedPromise.reject(err);\n        }\n    };\n    config.emitter.addListener(config.eventName, onEvent);\n    if (config.cancelController) {\n        cancelRemoveListener = config.cancelController.addListener(() => {\n            liftedPromise.reject(config.cancelMessage);\n        });\n    }\n    return promise.makeSelfCleaningPromise(liftedPromise.promise, () => {\n        if (onEvent) {\n            config.emitter.removeListener(config.eventName, onEvent);\n        }\n        if (cancelRemoveListener) {\n            cancelRemoveListener();\n        }\n    });\n}\nexports.newCancellablePromiseFromNextEvent = newCancellablePromiseFromNextEvent;\n//# sourceMappingURL=cancel.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXdzLWNydC9kaXN0L2NvbW1vbi9jYW5jZWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMENBQTBDLEdBQUcsd0JBQXdCLEdBQUcsa0JBQWtCO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsc0JBQVE7QUFDakMsNkJBQTZCLG1CQUFPLENBQUMsc0VBQVc7QUFDaEQsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsMENBQTBDO0FBQzFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGF5d2luZC8uL25vZGVfbW9kdWxlcy9hd3MtY3J0L2Rpc3QvY29tbW9uL2NhbmNlbC5qcz9kZWI5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjAuXG4gKi9cbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5uZXdDYW5jZWxsYWJsZVByb21pc2VGcm9tTmV4dEV2ZW50ID0gZXhwb3J0cy5DYW5jZWxDb250cm9sbGVyID0gZXhwb3J0cy5FVkVOVF9OQU1FID0gdm9pZCAwO1xuLyoqXG4gKlxuICogQSBtb2R1bGUgY29udGFpbmluZyBzdXBwb3J0IGZvciBjYW5jZWxsaW5nIGFzeW5jaHJvbm91cyBvcGVyYXRpb25zXG4gKlxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKiBAbW9kdWxlIGNhbmNlbFxuICovXG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5jb25zdCBwcm9taXNlID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3Byb21pc2VcIikpO1xuZXhwb3J0cy5FVkVOVF9OQU1FID0gJ2NhbmNlbGxlZCc7XG4vKipcbiAqIENSVCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgSUNhbmNlbENvbnRyb2xsZXIgaW50ZXJmYWNlXG4gKi9cbmNsYXNzIENhbmNlbENvbnRyb2xsZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5jYW5jZWxsZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5lbWl0dGVyRmFjdG9yeSkge1xuICAgICAgICAgICAgdGhpcy5lbWl0dGVyID0gb3B0aW9ucy5lbWl0dGVyRmFjdG9yeSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lbWl0dGVyID0gbmV3IGV2ZW50c18xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbmNlbHMgYWxsIGFzeW5jaHJvbm91cyBvcGVyYXRpb25zIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGNvbnRyb2xsZXJcbiAgICAgKi9cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgIGlmICghdGhpcy5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlci5lbWl0KGV4cG9ydHMuRVZFTlRfTkFNRSk7XG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKGV4cG9ydHMuRVZFTlRfTkFNRSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoZSBjb250cm9sbGVyIGlzIGluIHRoZSBjYW5jZWxsZWQgc3RhdGVcbiAgICAgKi9cbiAgICBoYXNCZWVuQ2FuY2VsbGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYW5jZWxsZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIGNhbGxiYWNrIHRvIGJlIG5vdGlmaWVkIHdoZW4gY2FuY2VsKCkgaXMgaW52b2tlZCBleHRlcm5hbGx5LiAgSW4gZ2VuZXJhbCwgdGhlIGNhbGxiYWNrXG4gICAgICogd2lsbCBjYW5jZWwgYW4gYXN5bmNocm9ub3VzIG9wZXJhdGlvbiBieSByZWplY3RpbmcgdGhlIGFzc29jaWF0ZWQgcHJvbWlzZS5cbiAgICAgKlxuICAgICAqIElNUE9SVEFOVDogVGhlIGxpc3RlbmVyIGlzIGludm9rZWQgc3luY2hyb25vdXNseSBpZiB0aGUgY29udHJvbGxlciBoYXMgYWxyZWFkeSBiZWVuIGNhbmNlbGxlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsaXN0ZW5lciAtIGZ1bmN0aW9uIHRvIGludm9rZSBvbiBjYW5jZWw7IGludm9rZWQgc3luY2hyb25vdXNseSBpZiB0aGUgY29udHJvbGxlciBoYXMgYmVlbiBjYW5jZWxsZWRcbiAgICAgKlxuICAgICAqIEByZXR1cm4gdW5kZWZpbmVkIGlmIHRoZSBjb250cm9sbGVyIGhhcyBhbHJlYWR5IGJlZW4gY2FuY2VsbGVkLCBvdGhlcndpc2UgYSBmdW5jdGlvbiBvYmplY3Qgd2hvc2UgaW52b2NhdGlvblxuICAgICAqIHdpbGwgcmVtb3ZlIHRoZSBsaXN0ZW5lciBmcm9tIHRoZSBjb250cm9sbGVyJ3MgZXZlbnQgZW1pdHRlci5cbiAgICAgKlxuICAgICAqL1xuICAgIGFkZExpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICh0aGlzLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgbGlzdGVuZXIoKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0dGVyLm9uKGV4cG9ydHMuRVZFTlRfTkFNRSwgbGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gKCkgPT4geyB0aGlzLmVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoZXhwb3J0cy5FVkVOVF9OQU1FLCBsaXN0ZW5lcik7IH07XG4gICAgfVxufVxuZXhwb3J0cy5DYW5jZWxDb250cm9sbGVyID0gQ2FuY2VsQ29udHJvbGxlcjtcbi8qKlxuICogQ3JlYXRlcyBhIHByb21pc2UgdGhhdCBjYW4gYmUgcmVqZWN0ZWQgYnkgYSBDYW5jZWxDb250cm9sbGVyIGFuZCByZXNvbHZlZCBieSB0aGUgcmVjZWlwdCBvZiBhbiBldmVudCBmcm9tIGFuXG4gKiBFdmVudEVtaXR0ZXIuXG4gKlxuICogQHBhcmFtIGNvbmZpZyBwcm9taXNlIGNyZWF0aW9uIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gbmV3Q2FuY2VsbGFibGVQcm9taXNlRnJvbU5leHRFdmVudChjb25maWcpIHtcbiAgICBsZXQgb25FdmVudCA9IHVuZGVmaW5lZDtcbiAgICBsZXQgY2FuY2VsUmVtb3ZlTGlzdGVuZXIgPSB1bmRlZmluZWQ7XG4gICAgbGV0IGxpZnRlZFByb21pc2UgPSBwcm9taXNlLm5ld0xpZnRlZFByb21pc2UoKTtcbiAgICBvbkV2ZW50ID0gKGV2ZW50RGF0YSkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5ldmVudERhdGFUcmFuc2Zvcm1lcikge1xuICAgICAgICAgICAgICAgIGxpZnRlZFByb21pc2UucmVzb2x2ZShjb25maWcuZXZlbnREYXRhVHJhbnNmb3JtZXIoZXZlbnREYXRhKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsaWZ0ZWRQcm9taXNlLnJlc29sdmUoZXZlbnREYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBsaWZ0ZWRQcm9taXNlLnJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25maWcuZW1pdHRlci5hZGRMaXN0ZW5lcihjb25maWcuZXZlbnROYW1lLCBvbkV2ZW50KTtcbiAgICBpZiAoY29uZmlnLmNhbmNlbENvbnRyb2xsZXIpIHtcbiAgICAgICAgY2FuY2VsUmVtb3ZlTGlzdGVuZXIgPSBjb25maWcuY2FuY2VsQ29udHJvbGxlci5hZGRMaXN0ZW5lcigoKSA9PiB7XG4gICAgICAgICAgICBsaWZ0ZWRQcm9taXNlLnJlamVjdChjb25maWcuY2FuY2VsTWVzc2FnZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcHJvbWlzZS5tYWtlU2VsZkNsZWFuaW5nUHJvbWlzZShsaWZ0ZWRQcm9taXNlLnByb21pc2UsICgpID0+IHtcbiAgICAgICAgaWYgKG9uRXZlbnQpIHtcbiAgICAgICAgICAgIGNvbmZpZy5lbWl0dGVyLnJlbW92ZUxpc3RlbmVyKGNvbmZpZy5ldmVudE5hbWUsIG9uRXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYW5jZWxSZW1vdmVMaXN0ZW5lcikge1xuICAgICAgICAgICAgY2FuY2VsUmVtb3ZlTGlzdGVuZXIoKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5uZXdDYW5jZWxsYWJsZVByb21pc2VGcm9tTmV4dEV2ZW50ID0gbmV3Q2FuY2VsbGFibGVQcm9taXNlRnJvbU5leHRFdmVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhbmNlbC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/aws-crt/dist/common/cancel.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/aws-crt/dist/common/event.js":
/*!***************************************************!*\
  !*** ./node_modules/aws-crt/dist/common/event.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n * SPDX-License-Identifier: Apache-2.0.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BufferedEventEmitter = void 0;\n/**\n * Module for base types related to event emission\n *\n * @packageDocumentation\n * @module event\n */\nconst events_1 = __webpack_require__(/*! events */ \"events\");\n/**\n * @internal\n */\nclass BufferedEvent {\n    constructor(event, args) {\n        this.event = event;\n        this.args = args;\n    }\n}\n/**\n * Provides buffered event emitting semantics, similar to many Node-style streams.\n * Subclasses will override EventEmitter.on() and trigger uncorking.\n * NOTE: It is HIGHLY recommended that uncorking should always be done via\n * ```process.nextTick()```, not during the EventEmitter.on() call.\n *\n * See also: [Node writable streams](https://nodejs.org/api/stream.html#stream_writable_cork)\n *\n * @category Events\n */\nclass BufferedEventEmitter extends events_1.EventEmitter {\n    constructor() {\n        super();\n        this.corked = false;\n    }\n    /**\n     * Forces all written events to be buffered in memory. The buffered data will be\n     * flushed when {@link BufferedEventEmitter.uncork} is called.\n     */\n    cork() {\n        this.corked = true;\n    }\n    /**\n     * Flushes all data buffered since {@link BufferedEventEmitter.cork} was called.\n     *\n     * NOTE: It is HIGHLY recommended that uncorking should always be done via\n     * ``` process.nextTick```, not during the ```EventEmitter.on()``` call.\n     */\n    uncork() {\n        this.corked = false;\n        while (this.eventQueue) {\n            const event = this.eventQueue;\n            super.emit(event.event, ...event.args);\n            this.eventQueue = this.eventQueue.next;\n        }\n    }\n    /**\n     * Synchronously calls each of the listeners registered for the event key supplied\n     * in registration order. If the {@link BufferedEventEmitter} is currently corked,\n     * the event will be buffered until {@link BufferedEventEmitter.uncork} is called.\n     * @param event The name of the event\n     * @param args Event payload\n     */\n    emit(event, ...args) {\n        if (this.corked) {\n            // queue requests in order\n            let last = this.lastQueuedEvent;\n            this.lastQueuedEvent = new BufferedEvent(event, args);\n            if (last) {\n                last.next = this.lastQueuedEvent;\n            }\n            else {\n                this.eventQueue = this.lastQueuedEvent;\n            }\n            return this.listeners(event).length > 0;\n        }\n        return super.emit(event, ...args);\n    }\n}\nexports.BufferedEventEmitter = BufferedEventEmitter;\n//# sourceMappingURL=event.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXdzLWNydC9kaXN0L2NvbW1vbi9ldmVudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1DQUFtQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGlDQUFpQztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDRCQUE0QjtBQUNsRSx5Q0FBeUMsbUNBQW1DO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGF5d2luZC8uL25vZGVfbW9kdWxlcy9hd3MtY3J0L2Rpc3QvY29tbW9uL2V2ZW50LmpzPzdmOGIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IEFtYXpvbi5jb20sIEluYy4gb3IgaXRzIGFmZmlsaWF0ZXMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMC5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CdWZmZXJlZEV2ZW50RW1pdHRlciA9IHZvaWQgMDtcbi8qKlxuICogTW9kdWxlIGZvciBiYXNlIHR5cGVzIHJlbGF0ZWQgdG8gZXZlbnQgZW1pc3Npb25cbiAqXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqIEBtb2R1bGUgZXZlbnRcbiAqL1xuY29uc3QgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgQnVmZmVyZWRFdmVudCB7XG4gICAgY29uc3RydWN0b3IoZXZlbnQsIGFyZ3MpIHtcbiAgICAgICAgdGhpcy5ldmVudCA9IGV2ZW50O1xuICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgIH1cbn1cbi8qKlxuICogUHJvdmlkZXMgYnVmZmVyZWQgZXZlbnQgZW1pdHRpbmcgc2VtYW50aWNzLCBzaW1pbGFyIHRvIG1hbnkgTm9kZS1zdHlsZSBzdHJlYW1zLlxuICogU3ViY2xhc3NlcyB3aWxsIG92ZXJyaWRlIEV2ZW50RW1pdHRlci5vbigpIGFuZCB0cmlnZ2VyIHVuY29ya2luZy5cbiAqIE5PVEU6IEl0IGlzIEhJR0hMWSByZWNvbW1lbmRlZCB0aGF0IHVuY29ya2luZyBzaG91bGQgYWx3YXlzIGJlIGRvbmUgdmlhXG4gKiBgYGBwcm9jZXNzLm5leHRUaWNrKClgYGAsIG5vdCBkdXJpbmcgdGhlIEV2ZW50RW1pdHRlci5vbigpIGNhbGwuXG4gKlxuICogU2VlIGFsc286IFtOb2RlIHdyaXRhYmxlIHN0cmVhbXNdKGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvc3RyZWFtLmh0bWwjc3RyZWFtX3dyaXRhYmxlX2NvcmspXG4gKlxuICogQGNhdGVnb3J5IEV2ZW50c1xuICovXG5jbGFzcyBCdWZmZXJlZEV2ZW50RW1pdHRlciBleHRlbmRzIGV2ZW50c18xLkV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY29ya2VkID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvcmNlcyBhbGwgd3JpdHRlbiBldmVudHMgdG8gYmUgYnVmZmVyZWQgaW4gbWVtb3J5LiBUaGUgYnVmZmVyZWQgZGF0YSB3aWxsIGJlXG4gICAgICogZmx1c2hlZCB3aGVuIHtAbGluayBCdWZmZXJlZEV2ZW50RW1pdHRlci51bmNvcmt9IGlzIGNhbGxlZC5cbiAgICAgKi9cbiAgICBjb3JrKCkge1xuICAgICAgICB0aGlzLmNvcmtlZCA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZsdXNoZXMgYWxsIGRhdGEgYnVmZmVyZWQgc2luY2Uge0BsaW5rIEJ1ZmZlcmVkRXZlbnRFbWl0dGVyLmNvcmt9IHdhcyBjYWxsZWQuXG4gICAgICpcbiAgICAgKiBOT1RFOiBJdCBpcyBISUdITFkgcmVjb21tZW5kZWQgdGhhdCB1bmNvcmtpbmcgc2hvdWxkIGFsd2F5cyBiZSBkb25lIHZpYVxuICAgICAqIGBgYCBwcm9jZXNzLm5leHRUaWNrYGBgLCBub3QgZHVyaW5nIHRoZSBgYGBFdmVudEVtaXR0ZXIub24oKWBgYCBjYWxsLlxuICAgICAqL1xuICAgIHVuY29yaygpIHtcbiAgICAgICAgdGhpcy5jb3JrZWQgPSBmYWxzZTtcbiAgICAgICAgd2hpbGUgKHRoaXMuZXZlbnRRdWV1ZSkge1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSB0aGlzLmV2ZW50UXVldWU7XG4gICAgICAgICAgICBzdXBlci5lbWl0KGV2ZW50LmV2ZW50LCAuLi5ldmVudC5hcmdzKTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRRdWV1ZSA9IHRoaXMuZXZlbnRRdWV1ZS5uZXh0O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN5bmNocm9ub3VzbHkgY2FsbHMgZWFjaCBvZiB0aGUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIHRoZSBldmVudCBrZXkgc3VwcGxpZWRcbiAgICAgKiBpbiByZWdpc3RyYXRpb24gb3JkZXIuIElmIHRoZSB7QGxpbmsgQnVmZmVyZWRFdmVudEVtaXR0ZXJ9IGlzIGN1cnJlbnRseSBjb3JrZWQsXG4gICAgICogdGhlIGV2ZW50IHdpbGwgYmUgYnVmZmVyZWQgdW50aWwge0BsaW5rIEJ1ZmZlcmVkRXZlbnRFbWl0dGVyLnVuY29ya30gaXMgY2FsbGVkLlxuICAgICAqIEBwYXJhbSBldmVudCBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICAgKiBAcGFyYW0gYXJncyBFdmVudCBwYXlsb2FkXG4gICAgICovXG4gICAgZW1pdChldmVudCwgLi4uYXJncykge1xuICAgICAgICBpZiAodGhpcy5jb3JrZWQpIHtcbiAgICAgICAgICAgIC8vIHF1ZXVlIHJlcXVlc3RzIGluIG9yZGVyXG4gICAgICAgICAgICBsZXQgbGFzdCA9IHRoaXMubGFzdFF1ZXVlZEV2ZW50O1xuICAgICAgICAgICAgdGhpcy5sYXN0UXVldWVkRXZlbnQgPSBuZXcgQnVmZmVyZWRFdmVudChldmVudCwgYXJncyk7XG4gICAgICAgICAgICBpZiAobGFzdCkge1xuICAgICAgICAgICAgICAgIGxhc3QubmV4dCA9IHRoaXMubGFzdFF1ZXVlZEV2ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudFF1ZXVlID0gdGhpcy5sYXN0UXVldWVkRXZlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lcnMoZXZlbnQpLmxlbmd0aCA+IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLmVtaXQoZXZlbnQsIC4uLmFyZ3MpO1xuICAgIH1cbn1cbmV4cG9ydHMuQnVmZmVyZWRFdmVudEVtaXR0ZXIgPSBCdWZmZXJlZEV2ZW50RW1pdHRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV2ZW50LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/aws-crt/dist/common/event.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/aws-crt/dist/common/http.js":
/*!**************************************************!*\
  !*** ./node_modules/aws-crt/dist/common/http.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n *\n * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n * SPDX-License-Identifier: Apache-2.0.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CommonHttpProxyOptions = exports.HttpProxyAuthenticationType = exports.HttpVersion = void 0;\n/**\n *\n * A module containing support for creating http connections and making requests on them.\n *\n * @packageDocumentation\n * @module http\n */\n/**\n * HTTP protocol version\n *\n * @category HTTP\n */\nvar HttpVersion;\n(function (HttpVersion) {\n    HttpVersion[HttpVersion[\"Unknown\"] = 0] = \"Unknown\";\n    /** HTTP/1.0 */\n    HttpVersion[HttpVersion[\"Http1_0\"] = 1] = \"Http1_0\";\n    /** HTTP/1.1 */\n    HttpVersion[HttpVersion[\"Http1_1\"] = 2] = \"Http1_1\";\n    /** HTTP/2 */\n    HttpVersion[HttpVersion[\"Http2\"] = 3] = \"Http2\";\n})(HttpVersion = exports.HttpVersion || (exports.HttpVersion = {}));\n/**\n * Proxy authentication types\n *\n * @category HTTP\n */\nvar HttpProxyAuthenticationType;\n(function (HttpProxyAuthenticationType) {\n    /**\n     * No to-proxy authentication logic\n     */\n    HttpProxyAuthenticationType[HttpProxyAuthenticationType[\"None\"] = 0] = \"None\";\n    /**\n     * Use basic authentication (user/pass).  Supply these values in {@link HttpProxyOptions}\n     */\n    HttpProxyAuthenticationType[HttpProxyAuthenticationType[\"Basic\"] = 1] = \"Basic\";\n})(HttpProxyAuthenticationType = exports.HttpProxyAuthenticationType || (exports.HttpProxyAuthenticationType = {}));\n;\n/**\n * Options used when connecting to an HTTP endpoint via a proxy\n *\n * @category HTTP\n */\nclass CommonHttpProxyOptions {\n    /**\n     *\n     * @param host_name endpoint of the proxy to use\n     * @param port port of proxy to use\n     * @param auth_method type of authentication to use with the proxy\n     * @param auth_username (basic authentication only) proxy username\n     * @param auth_password (basic authentication only) password associated with the username\n     */\n    constructor(host_name, port, auth_method = HttpProxyAuthenticationType.None, auth_username, auth_password) {\n        this.host_name = host_name;\n        this.port = port;\n        this.auth_method = auth_method;\n        this.auth_username = auth_username;\n        this.auth_password = auth_password;\n    }\n}\nexports.CommonHttpProxyOptions = CommonHttpProxyOptions;\n//# sourceMappingURL=http.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXdzLWNydC9kaXN0L2NvbW1vbi9odHRwLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw4QkFBOEIsR0FBRyxtQ0FBbUMsR0FBRyxtQkFBbUI7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3Q0FBd0MsbUJBQW1CLEtBQUs7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQSxDQUFDLHdFQUF3RSxtQ0FBbUMsS0FBSztBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGF5d2luZC8uL25vZGVfbW9kdWxlcy9hd3MtY3J0L2Rpc3QvY29tbW9uL2h0dHAuanM/MDdkMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKlxuICogQ29weXJpZ2h0IEFtYXpvbi5jb20sIEluYy4gb3IgaXRzIGFmZmlsaWF0ZXMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMC5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db21tb25IdHRwUHJveHlPcHRpb25zID0gZXhwb3J0cy5IdHRwUHJveHlBdXRoZW50aWNhdGlvblR5cGUgPSBleHBvcnRzLkh0dHBWZXJzaW9uID0gdm9pZCAwO1xuLyoqXG4gKlxuICogQSBtb2R1bGUgY29udGFpbmluZyBzdXBwb3J0IGZvciBjcmVhdGluZyBodHRwIGNvbm5lY3Rpb25zIGFuZCBtYWtpbmcgcmVxdWVzdHMgb24gdGhlbS5cbiAqXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqIEBtb2R1bGUgaHR0cFxuICovXG4vKipcbiAqIEhUVFAgcHJvdG9jb2wgdmVyc2lvblxuICpcbiAqIEBjYXRlZ29yeSBIVFRQXG4gKi9cbnZhciBIdHRwVmVyc2lvbjtcbihmdW5jdGlvbiAoSHR0cFZlcnNpb24pIHtcbiAgICBIdHRwVmVyc2lvbltIdHRwVmVyc2lvbltcIlVua25vd25cIl0gPSAwXSA9IFwiVW5rbm93blwiO1xuICAgIC8qKiBIVFRQLzEuMCAqL1xuICAgIEh0dHBWZXJzaW9uW0h0dHBWZXJzaW9uW1wiSHR0cDFfMFwiXSA9IDFdID0gXCJIdHRwMV8wXCI7XG4gICAgLyoqIEhUVFAvMS4xICovXG4gICAgSHR0cFZlcnNpb25bSHR0cFZlcnNpb25bXCJIdHRwMV8xXCJdID0gMl0gPSBcIkh0dHAxXzFcIjtcbiAgICAvKiogSFRUUC8yICovXG4gICAgSHR0cFZlcnNpb25bSHR0cFZlcnNpb25bXCJIdHRwMlwiXSA9IDNdID0gXCJIdHRwMlwiO1xufSkoSHR0cFZlcnNpb24gPSBleHBvcnRzLkh0dHBWZXJzaW9uIHx8IChleHBvcnRzLkh0dHBWZXJzaW9uID0ge30pKTtcbi8qKlxuICogUHJveHkgYXV0aGVudGljYXRpb24gdHlwZXNcbiAqXG4gKiBAY2F0ZWdvcnkgSFRUUFxuICovXG52YXIgSHR0cFByb3h5QXV0aGVudGljYXRpb25UeXBlO1xuKGZ1bmN0aW9uIChIdHRwUHJveHlBdXRoZW50aWNhdGlvblR5cGUpIHtcbiAgICAvKipcbiAgICAgKiBObyB0by1wcm94eSBhdXRoZW50aWNhdGlvbiBsb2dpY1xuICAgICAqL1xuICAgIEh0dHBQcm94eUF1dGhlbnRpY2F0aW9uVHlwZVtIdHRwUHJveHlBdXRoZW50aWNhdGlvblR5cGVbXCJOb25lXCJdID0gMF0gPSBcIk5vbmVcIjtcbiAgICAvKipcbiAgICAgKiBVc2UgYmFzaWMgYXV0aGVudGljYXRpb24gKHVzZXIvcGFzcykuICBTdXBwbHkgdGhlc2UgdmFsdWVzIGluIHtAbGluayBIdHRwUHJveHlPcHRpb25zfVxuICAgICAqL1xuICAgIEh0dHBQcm94eUF1dGhlbnRpY2F0aW9uVHlwZVtIdHRwUHJveHlBdXRoZW50aWNhdGlvblR5cGVbXCJCYXNpY1wiXSA9IDFdID0gXCJCYXNpY1wiO1xufSkoSHR0cFByb3h5QXV0aGVudGljYXRpb25UeXBlID0gZXhwb3J0cy5IdHRwUHJveHlBdXRoZW50aWNhdGlvblR5cGUgfHwgKGV4cG9ydHMuSHR0cFByb3h5QXV0aGVudGljYXRpb25UeXBlID0ge30pKTtcbjtcbi8qKlxuICogT3B0aW9ucyB1c2VkIHdoZW4gY29ubmVjdGluZyB0byBhbiBIVFRQIGVuZHBvaW50IHZpYSBhIHByb3h5XG4gKlxuICogQGNhdGVnb3J5IEhUVFBcbiAqL1xuY2xhc3MgQ29tbW9uSHR0cFByb3h5T3B0aW9ucyB7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaG9zdF9uYW1lIGVuZHBvaW50IG9mIHRoZSBwcm94eSB0byB1c2VcbiAgICAgKiBAcGFyYW0gcG9ydCBwb3J0IG9mIHByb3h5IHRvIHVzZVxuICAgICAqIEBwYXJhbSBhdXRoX21ldGhvZCB0eXBlIG9mIGF1dGhlbnRpY2F0aW9uIHRvIHVzZSB3aXRoIHRoZSBwcm94eVxuICAgICAqIEBwYXJhbSBhdXRoX3VzZXJuYW1lIChiYXNpYyBhdXRoZW50aWNhdGlvbiBvbmx5KSBwcm94eSB1c2VybmFtZVxuICAgICAqIEBwYXJhbSBhdXRoX3Bhc3N3b3JkIChiYXNpYyBhdXRoZW50aWNhdGlvbiBvbmx5KSBwYXNzd29yZCBhc3NvY2lhdGVkIHdpdGggdGhlIHVzZXJuYW1lXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaG9zdF9uYW1lLCBwb3J0LCBhdXRoX21ldGhvZCA9IEh0dHBQcm94eUF1dGhlbnRpY2F0aW9uVHlwZS5Ob25lLCBhdXRoX3VzZXJuYW1lLCBhdXRoX3Bhc3N3b3JkKSB7XG4gICAgICAgIHRoaXMuaG9zdF9uYW1lID0gaG9zdF9uYW1lO1xuICAgICAgICB0aGlzLnBvcnQgPSBwb3J0O1xuICAgICAgICB0aGlzLmF1dGhfbWV0aG9kID0gYXV0aF9tZXRob2Q7XG4gICAgICAgIHRoaXMuYXV0aF91c2VybmFtZSA9IGF1dGhfdXNlcm5hbWU7XG4gICAgICAgIHRoaXMuYXV0aF9wYXNzd29yZCA9IGF1dGhfcGFzc3dvcmQ7XG4gICAgfVxufVxuZXhwb3J0cy5Db21tb25IdHRwUHJveHlPcHRpb25zID0gQ29tbW9uSHR0cFByb3h5T3B0aW9ucztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWh0dHAuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/aws-crt/dist/common/http.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/aws-crt/dist/common/io.js":
/*!************************************************!*\
  !*** ./node_modules/aws-crt/dist/common/io.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n * SPDX-License-Identifier: Apache-2.0.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SocketDomain = exports.SocketType = exports.TlsVersion = void 0;\n/**\n *\n * A module containing a grab bag of support for core network I/O functionality, including sockets, TLS, DNS, logging,\n * error handling, streams, and connection -> thread mapping.\n *\n * Categories include:\n * - Network: socket configuration\n * - TLS: tls configuration\n * - Logging: logging controls and configuration\n * - IO: everything else\n *\n * @packageDocumentation\n * @module io\n */\n/**\n * TLS Version\n *\n * @category TLS\n */\nvar TlsVersion;\n(function (TlsVersion) {\n    TlsVersion[TlsVersion[\"SSLv3\"] = 0] = \"SSLv3\";\n    TlsVersion[TlsVersion[\"TLSv1\"] = 1] = \"TLSv1\";\n    TlsVersion[TlsVersion[\"TLSv1_1\"] = 2] = \"TLSv1_1\";\n    TlsVersion[TlsVersion[\"TLSv1_2\"] = 3] = \"TLSv1_2\";\n    TlsVersion[TlsVersion[\"TLSv1_3\"] = 4] = \"TLSv1_3\";\n    TlsVersion[TlsVersion[\"Default\"] = 128] = \"Default\";\n})(TlsVersion = exports.TlsVersion || (exports.TlsVersion = {}));\n/**\n * @category Network\n */\nvar SocketType;\n(function (SocketType) {\n    /**\n     * A streaming socket sends reliable messages over a two-way connection.\n     * This means TCP when used with {@link SocketDomain.IPV4}/{@link SocketDomain.IPV6},\n     * and Unix domain sockets when used with {@link SocketDomain.LOCAL }\n      */\n    SocketType[SocketType[\"STREAM\"] = 0] = \"STREAM\";\n    /**\n     * A datagram socket is connectionless and sends unreliable messages.\n     * This means UDP when used with {@link SocketDomain.IPV4}/{@link SocketDomain.IPV6}.\n     * {@link SocketDomain.LOCAL} is not compatible with {@link DGRAM}\n     */\n    SocketType[SocketType[\"DGRAM\"] = 1] = \"DGRAM\";\n})(SocketType = exports.SocketType || (exports.SocketType = {}));\n/**\n * @category Network\n */\nvar SocketDomain;\n(function (SocketDomain) {\n    /** IPv4 sockets */\n    SocketDomain[SocketDomain[\"IPV4\"] = 0] = \"IPV4\";\n    /** IPv6 sockets */\n    SocketDomain[SocketDomain[\"IPV6\"] = 1] = \"IPV6\";\n    /** UNIX domain socket/Windows named pipes */\n    SocketDomain[SocketDomain[\"LOCAL\"] = 2] = \"LOCAL\";\n})(SocketDomain = exports.SocketDomain || (exports.SocketDomain = {}));\n//# sourceMappingURL=io.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXdzLWNydC9kaXN0L2NvbW1vbi9pby5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQixHQUFHLGtCQUFrQixHQUFHLGtCQUFrQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNDQUFzQyxrQkFBa0IsS0FBSztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyx3QkFBd0IsRUFBRSx3QkFBd0I7QUFDeEYsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHdCQUF3QixFQUFFLHdCQUF3QjtBQUN4RixRQUFRLDBCQUEwQix3QkFBd0I7QUFDMUQ7QUFDQTtBQUNBLENBQUMsc0NBQXNDLGtCQUFrQixLQUFLO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBDQUEwQyxvQkFBb0IsS0FBSztBQUNwRSIsInNvdXJjZXMiOlsid2VicGFjazovL3BheXdpbmQvLi9ub2RlX21vZHVsZXMvYXdzLWNydC9kaXN0L2NvbW1vbi9pby5qcz84MTI1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjAuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU29ja2V0RG9tYWluID0gZXhwb3J0cy5Tb2NrZXRUeXBlID0gZXhwb3J0cy5UbHNWZXJzaW9uID0gdm9pZCAwO1xuLyoqXG4gKlxuICogQSBtb2R1bGUgY29udGFpbmluZyBhIGdyYWIgYmFnIG9mIHN1cHBvcnQgZm9yIGNvcmUgbmV0d29yayBJL08gZnVuY3Rpb25hbGl0eSwgaW5jbHVkaW5nIHNvY2tldHMsIFRMUywgRE5TLCBsb2dnaW5nLFxuICogZXJyb3IgaGFuZGxpbmcsIHN0cmVhbXMsIGFuZCBjb25uZWN0aW9uIC0+IHRocmVhZCBtYXBwaW5nLlxuICpcbiAqIENhdGVnb3JpZXMgaW5jbHVkZTpcbiAqIC0gTmV0d29yazogc29ja2V0IGNvbmZpZ3VyYXRpb25cbiAqIC0gVExTOiB0bHMgY29uZmlndXJhdGlvblxuICogLSBMb2dnaW5nOiBsb2dnaW5nIGNvbnRyb2xzIGFuZCBjb25maWd1cmF0aW9uXG4gKiAtIElPOiBldmVyeXRoaW5nIGVsc2VcbiAqXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqIEBtb2R1bGUgaW9cbiAqL1xuLyoqXG4gKiBUTFMgVmVyc2lvblxuICpcbiAqIEBjYXRlZ29yeSBUTFNcbiAqL1xudmFyIFRsc1ZlcnNpb247XG4oZnVuY3Rpb24gKFRsc1ZlcnNpb24pIHtcbiAgICBUbHNWZXJzaW9uW1Rsc1ZlcnNpb25bXCJTU0x2M1wiXSA9IDBdID0gXCJTU0x2M1wiO1xuICAgIFRsc1ZlcnNpb25bVGxzVmVyc2lvbltcIlRMU3YxXCJdID0gMV0gPSBcIlRMU3YxXCI7XG4gICAgVGxzVmVyc2lvbltUbHNWZXJzaW9uW1wiVExTdjFfMVwiXSA9IDJdID0gXCJUTFN2MV8xXCI7XG4gICAgVGxzVmVyc2lvbltUbHNWZXJzaW9uW1wiVExTdjFfMlwiXSA9IDNdID0gXCJUTFN2MV8yXCI7XG4gICAgVGxzVmVyc2lvbltUbHNWZXJzaW9uW1wiVExTdjFfM1wiXSA9IDRdID0gXCJUTFN2MV8zXCI7XG4gICAgVGxzVmVyc2lvbltUbHNWZXJzaW9uW1wiRGVmYXVsdFwiXSA9IDEyOF0gPSBcIkRlZmF1bHRcIjtcbn0pKFRsc1ZlcnNpb24gPSBleHBvcnRzLlRsc1ZlcnNpb24gfHwgKGV4cG9ydHMuVGxzVmVyc2lvbiA9IHt9KSk7XG4vKipcbiAqIEBjYXRlZ29yeSBOZXR3b3JrXG4gKi9cbnZhciBTb2NrZXRUeXBlO1xuKGZ1bmN0aW9uIChTb2NrZXRUeXBlKSB7XG4gICAgLyoqXG4gICAgICogQSBzdHJlYW1pbmcgc29ja2V0IHNlbmRzIHJlbGlhYmxlIG1lc3NhZ2VzIG92ZXIgYSB0d28td2F5IGNvbm5lY3Rpb24uXG4gICAgICogVGhpcyBtZWFucyBUQ1Agd2hlbiB1c2VkIHdpdGgge0BsaW5rIFNvY2tldERvbWFpbi5JUFY0fS97QGxpbmsgU29ja2V0RG9tYWluLklQVjZ9LFxuICAgICAqIGFuZCBVbml4IGRvbWFpbiBzb2NrZXRzIHdoZW4gdXNlZCB3aXRoIHtAbGluayBTb2NrZXREb21haW4uTE9DQUwgfVxuICAgICAgKi9cbiAgICBTb2NrZXRUeXBlW1NvY2tldFR5cGVbXCJTVFJFQU1cIl0gPSAwXSA9IFwiU1RSRUFNXCI7XG4gICAgLyoqXG4gICAgICogQSBkYXRhZ3JhbSBzb2NrZXQgaXMgY29ubmVjdGlvbmxlc3MgYW5kIHNlbmRzIHVucmVsaWFibGUgbWVzc2FnZXMuXG4gICAgICogVGhpcyBtZWFucyBVRFAgd2hlbiB1c2VkIHdpdGgge0BsaW5rIFNvY2tldERvbWFpbi5JUFY0fS97QGxpbmsgU29ja2V0RG9tYWluLklQVjZ9LlxuICAgICAqIHtAbGluayBTb2NrZXREb21haW4uTE9DQUx9IGlzIG5vdCBjb21wYXRpYmxlIHdpdGgge0BsaW5rIERHUkFNfVxuICAgICAqL1xuICAgIFNvY2tldFR5cGVbU29ja2V0VHlwZVtcIkRHUkFNXCJdID0gMV0gPSBcIkRHUkFNXCI7XG59KShTb2NrZXRUeXBlID0gZXhwb3J0cy5Tb2NrZXRUeXBlIHx8IChleHBvcnRzLlNvY2tldFR5cGUgPSB7fSkpO1xuLyoqXG4gKiBAY2F0ZWdvcnkgTmV0d29ya1xuICovXG52YXIgU29ja2V0RG9tYWluO1xuKGZ1bmN0aW9uIChTb2NrZXREb21haW4pIHtcbiAgICAvKiogSVB2NCBzb2NrZXRzICovXG4gICAgU29ja2V0RG9tYWluW1NvY2tldERvbWFpbltcIklQVjRcIl0gPSAwXSA9IFwiSVBWNFwiO1xuICAgIC8qKiBJUHY2IHNvY2tldHMgKi9cbiAgICBTb2NrZXREb21haW5bU29ja2V0RG9tYWluW1wiSVBWNlwiXSA9IDFdID0gXCJJUFY2XCI7XG4gICAgLyoqIFVOSVggZG9tYWluIHNvY2tldC9XaW5kb3dzIG5hbWVkIHBpcGVzICovXG4gICAgU29ja2V0RG9tYWluW1NvY2tldERvbWFpbltcIkxPQ0FMXCJdID0gMl0gPSBcIkxPQ0FMXCI7XG59KShTb2NrZXREb21haW4gPSBleHBvcnRzLlNvY2tldERvbWFpbiB8fCAoZXhwb3J0cy5Tb2NrZXREb21haW4gPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW8uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/aws-crt/dist/common/io.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/aws-crt/dist/common/mqtt.js":
/*!**************************************************!*\
  !*** ./node_modules/aws-crt/dist/common/mqtt.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n * SPDX-License-Identifier: Apache-2.0.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DEFAULT_RECONNECT_MIN_SEC = exports.DEFAULT_RECONNECT_MAX_SEC = exports.MqttWill = exports.QoS = void 0;\n/**\n * Quality of service control for mqtt publish operations\n *\n * @category MQTT\n */\nvar QoS;\n(function (QoS) {\n    /**\n     * QoS 0 - At most once delivery\n     * The message is delivered according to the capabilities of the underlying network.\n     * No response is sent by the receiver and no retry is performed by the sender.\n     * The message arrives at the receiver either once or not at all.\n     */\n    QoS[QoS[\"AtMostOnce\"] = 0] = \"AtMostOnce\";\n    /**\n     * QoS 1 - At least once delivery\n     * This quality of service ensures that the message arrives at the receiver at least once.\n     */\n    QoS[QoS[\"AtLeastOnce\"] = 1] = \"AtLeastOnce\";\n    /**\n     * QoS 2 - Exactly once delivery\n\n     * This is the highest quality of service, for use when neither loss nor\n     * duplication of messages are acceptable. There is an increased overhead\n     * associated with this quality of service.\n\n     * Note that, while this client supports QoS 2, the AWS IoT Core service\n     * does not support QoS 2 at time of writing (May 2020).\n     */\n    QoS[QoS[\"ExactlyOnce\"] = 2] = \"ExactlyOnce\";\n})(QoS = exports.QoS || (exports.QoS = {}));\n/**\n * A Will message is published by the server if a client is lost unexpectedly.\n *\n * The Will message is stored on the server when a client connects.\n * It is published if the client connection is lost without the server\n * receiving a DISCONNECT packet.\n *\n * [MQTT - 3.1.2 - 8]\n *\n * @category MQTT\n */\nclass MqttWill {\n    constructor(\n    /** Topic to publish Will message on. */\n    topic, \n    /** QoS used when publishing the Will message. */\n    qos, \n    /** Content of Will message. */\n    payload, \n    /** Whether the Will message is to be retained when it is published. */\n    retain = false) {\n        this.topic = topic;\n        this.qos = qos;\n        this.payload = payload;\n        this.retain = retain;\n    }\n}\nexports.MqttWill = MqttWill;\n/**\n * Const value for max reconnection back off time\n *\n * @category MQTT\n */\nexports.DEFAULT_RECONNECT_MAX_SEC = 128;\n/**\n * Const value for min reconnection back off time\n *\n * @category MQTT\n */\nexports.DEFAULT_RECONNECT_MIN_SEC = 1;\n//# sourceMappingURL=mqtt.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXdzLWNydC9kaXN0L2NvbW1vbi9tcXR0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUNBQWlDLEdBQUcsaUNBQWlDLEdBQUcsZ0JBQWdCLEdBQUcsV0FBVztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3QkFBd0IsV0FBVyxLQUFLO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wYXl3aW5kLy4vbm9kZV9tb2R1bGVzL2F3cy1jcnQvZGlzdC9jb21tb24vbXF0dC5qcz9hMWU2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjAuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuREVGQVVMVF9SRUNPTk5FQ1RfTUlOX1NFQyA9IGV4cG9ydHMuREVGQVVMVF9SRUNPTk5FQ1RfTUFYX1NFQyA9IGV4cG9ydHMuTXF0dFdpbGwgPSBleHBvcnRzLlFvUyA9IHZvaWQgMDtcbi8qKlxuICogUXVhbGl0eSBvZiBzZXJ2aWNlIGNvbnRyb2wgZm9yIG1xdHQgcHVibGlzaCBvcGVyYXRpb25zXG4gKlxuICogQGNhdGVnb3J5IE1RVFRcbiAqL1xudmFyIFFvUztcbihmdW5jdGlvbiAoUW9TKSB7XG4gICAgLyoqXG4gICAgICogUW9TIDAgLSBBdCBtb3N0IG9uY2UgZGVsaXZlcnlcbiAgICAgKiBUaGUgbWVzc2FnZSBpcyBkZWxpdmVyZWQgYWNjb3JkaW5nIHRvIHRoZSBjYXBhYmlsaXRpZXMgb2YgdGhlIHVuZGVybHlpbmcgbmV0d29yay5cbiAgICAgKiBObyByZXNwb25zZSBpcyBzZW50IGJ5IHRoZSByZWNlaXZlciBhbmQgbm8gcmV0cnkgaXMgcGVyZm9ybWVkIGJ5IHRoZSBzZW5kZXIuXG4gICAgICogVGhlIG1lc3NhZ2UgYXJyaXZlcyBhdCB0aGUgcmVjZWl2ZXIgZWl0aGVyIG9uY2Ugb3Igbm90IGF0IGFsbC5cbiAgICAgKi9cbiAgICBRb1NbUW9TW1wiQXRNb3N0T25jZVwiXSA9IDBdID0gXCJBdE1vc3RPbmNlXCI7XG4gICAgLyoqXG4gICAgICogUW9TIDEgLSBBdCBsZWFzdCBvbmNlIGRlbGl2ZXJ5XG4gICAgICogVGhpcyBxdWFsaXR5IG9mIHNlcnZpY2UgZW5zdXJlcyB0aGF0IHRoZSBtZXNzYWdlIGFycml2ZXMgYXQgdGhlIHJlY2VpdmVyIGF0IGxlYXN0IG9uY2UuXG4gICAgICovXG4gICAgUW9TW1FvU1tcIkF0TGVhc3RPbmNlXCJdID0gMV0gPSBcIkF0TGVhc3RPbmNlXCI7XG4gICAgLyoqXG4gICAgICogUW9TIDIgLSBFeGFjdGx5IG9uY2UgZGVsaXZlcnlcblxuICAgICAqIFRoaXMgaXMgdGhlIGhpZ2hlc3QgcXVhbGl0eSBvZiBzZXJ2aWNlLCBmb3IgdXNlIHdoZW4gbmVpdGhlciBsb3NzIG5vclxuICAgICAqIGR1cGxpY2F0aW9uIG9mIG1lc3NhZ2VzIGFyZSBhY2NlcHRhYmxlLiBUaGVyZSBpcyBhbiBpbmNyZWFzZWQgb3ZlcmhlYWRcbiAgICAgKiBhc3NvY2lhdGVkIHdpdGggdGhpcyBxdWFsaXR5IG9mIHNlcnZpY2UuXG5cbiAgICAgKiBOb3RlIHRoYXQsIHdoaWxlIHRoaXMgY2xpZW50IHN1cHBvcnRzIFFvUyAyLCB0aGUgQVdTIElvVCBDb3JlIHNlcnZpY2VcbiAgICAgKiBkb2VzIG5vdCBzdXBwb3J0IFFvUyAyIGF0IHRpbWUgb2Ygd3JpdGluZyAoTWF5IDIwMjApLlxuICAgICAqL1xuICAgIFFvU1tRb1NbXCJFeGFjdGx5T25jZVwiXSA9IDJdID0gXCJFeGFjdGx5T25jZVwiO1xufSkoUW9TID0gZXhwb3J0cy5Rb1MgfHwgKGV4cG9ydHMuUW9TID0ge30pKTtcbi8qKlxuICogQSBXaWxsIG1lc3NhZ2UgaXMgcHVibGlzaGVkIGJ5IHRoZSBzZXJ2ZXIgaWYgYSBjbGllbnQgaXMgbG9zdCB1bmV4cGVjdGVkbHkuXG4gKlxuICogVGhlIFdpbGwgbWVzc2FnZSBpcyBzdG9yZWQgb24gdGhlIHNlcnZlciB3aGVuIGEgY2xpZW50IGNvbm5lY3RzLlxuICogSXQgaXMgcHVibGlzaGVkIGlmIHRoZSBjbGllbnQgY29ubmVjdGlvbiBpcyBsb3N0IHdpdGhvdXQgdGhlIHNlcnZlclxuICogcmVjZWl2aW5nIGEgRElTQ09OTkVDVCBwYWNrZXQuXG4gKlxuICogW01RVFQgLSAzLjEuMiAtIDhdXG4gKlxuICogQGNhdGVnb3J5IE1RVFRcbiAqL1xuY2xhc3MgTXF0dFdpbGwge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKiBUb3BpYyB0byBwdWJsaXNoIFdpbGwgbWVzc2FnZSBvbi4gKi9cbiAgICB0b3BpYywgXG4gICAgLyoqIFFvUyB1c2VkIHdoZW4gcHVibGlzaGluZyB0aGUgV2lsbCBtZXNzYWdlLiAqL1xuICAgIHFvcywgXG4gICAgLyoqIENvbnRlbnQgb2YgV2lsbCBtZXNzYWdlLiAqL1xuICAgIHBheWxvYWQsIFxuICAgIC8qKiBXaGV0aGVyIHRoZSBXaWxsIG1lc3NhZ2UgaXMgdG8gYmUgcmV0YWluZWQgd2hlbiBpdCBpcyBwdWJsaXNoZWQuICovXG4gICAgcmV0YWluID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy50b3BpYyA9IHRvcGljO1xuICAgICAgICB0aGlzLnFvcyA9IHFvcztcbiAgICAgICAgdGhpcy5wYXlsb2FkID0gcGF5bG9hZDtcbiAgICAgICAgdGhpcy5yZXRhaW4gPSByZXRhaW47XG4gICAgfVxufVxuZXhwb3J0cy5NcXR0V2lsbCA9IE1xdHRXaWxsO1xuLyoqXG4gKiBDb25zdCB2YWx1ZSBmb3IgbWF4IHJlY29ubmVjdGlvbiBiYWNrIG9mZiB0aW1lXG4gKlxuICogQGNhdGVnb3J5IE1RVFRcbiAqL1xuZXhwb3J0cy5ERUZBVUxUX1JFQ09OTkVDVF9NQVhfU0VDID0gMTI4O1xuLyoqXG4gKiBDb25zdCB2YWx1ZSBmb3IgbWluIHJlY29ubmVjdGlvbiBiYWNrIG9mZiB0aW1lXG4gKlxuICogQGNhdGVnb3J5IE1RVFRcbiAqL1xuZXhwb3J0cy5ERUZBVUxUX1JFQ09OTkVDVF9NSU5fU0VDID0gMTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1xdHQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/aws-crt/dist/common/mqtt.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/aws-crt/dist/common/mqtt5.js":
/*!***************************************************!*\
  !*** ./node_modules/aws-crt/dist/common/mqtt5.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n * SPDX-License-Identifier: Apache-2.0.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RetryJitterType = exports.ClientSessionBehavior = void 0;\n/**\n * Controls how the MQTT5 client should behave with respect to MQTT sessions.\n */\nvar ClientSessionBehavior;\n(function (ClientSessionBehavior) {\n    /** Maps to Clean */\n    ClientSessionBehavior[ClientSessionBehavior[\"Default\"] = 0] = \"Default\";\n    /**\n     * Always ask for a clean session when connecting\n     */\n    ClientSessionBehavior[ClientSessionBehavior[\"Clean\"] = 1] = \"Clean\";\n    /**\n     * Always attempt to rejoin an existing session after an initial connection success.\n     *\n     * Session rejoin requires an appropriate non-zero session expiry interval in the client's CONNECT options.\n     */\n    ClientSessionBehavior[ClientSessionBehavior[\"RejoinPostSuccess\"] = 2] = \"RejoinPostSuccess\";\n    /**\n     * Always attempt to rejoin an existing session.  Since the client does not yet support durable session persistence,\n     * this option is not guaranteed to be spec compliant because any unacknowledged qos1 publishes (which are\n     * part of the client session state) will not be present on the initial connection.  Until we support\n     * durable session resumption, this option is technically spec-breaking, but useful.\n     */\n    ClientSessionBehavior[ClientSessionBehavior[\"RejoinAlways\"] = 3] = \"RejoinAlways\";\n})(ClientSessionBehavior = exports.ClientSessionBehavior || (exports.ClientSessionBehavior = {}));\n/**\n * Controls how the reconnect delay is modified in order to smooth out the distribution of reconnection attempt\n * timepoints for a large set of reconnecting clients.\n *\n * See [Exponential Backoff and Jitter](https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/)\n */\nvar RetryJitterType;\n(function (RetryJitterType) {\n    /**\n     * Maps to Full\n     */\n    RetryJitterType[RetryJitterType[\"Default\"] = 0] = \"Default\";\n    /**\n     * Do not perform any randomization on the reconnect delay:\n     * ```NextReconnectDelay = CurrentExponentialBackoffValue```\n     */\n    RetryJitterType[RetryJitterType[\"None\"] = 1] = \"None\";\n    /**\n     * Fully random between no delay and the current exponential backoff value.\n     * ```NextReconnectDelay = Random(0, CurrentExponentialBackoffValue)```\n     */\n    RetryJitterType[RetryJitterType[\"Full\"] = 2] = \"Full\";\n    /**\n     * ```NextReconnectDelay = Min(MaxReconnectDelay, Random(MinReconnectDelay, 3 * CurrentReconnectDelay)```\n     */\n    RetryJitterType[RetryJitterType[\"Decorrelated\"] = 3] = \"Decorrelated\";\n})(RetryJitterType = exports.RetryJitterType || (exports.RetryJitterType = {}));\n//# sourceMappingURL=mqtt5.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXdzLWNydC9kaXN0L2NvbW1vbi9tcXR0NS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QixHQUFHLDZCQUE2QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDREQUE0RCw2QkFBNkIsS0FBSztBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnREFBZ0QsdUJBQXVCLEtBQUs7QUFDN0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wYXl3aW5kLy4vbm9kZV9tb2R1bGVzL2F3cy1jcnQvZGlzdC9jb21tb24vbXF0dDUuanM/YWMyYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJldHJ5Sml0dGVyVHlwZSA9IGV4cG9ydHMuQ2xpZW50U2Vzc2lvbkJlaGF2aW9yID0gdm9pZCAwO1xuLyoqXG4gKiBDb250cm9scyBob3cgdGhlIE1RVFQ1IGNsaWVudCBzaG91bGQgYmVoYXZlIHdpdGggcmVzcGVjdCB0byBNUVRUIHNlc3Npb25zLlxuICovXG52YXIgQ2xpZW50U2Vzc2lvbkJlaGF2aW9yO1xuKGZ1bmN0aW9uIChDbGllbnRTZXNzaW9uQmVoYXZpb3IpIHtcbiAgICAvKiogTWFwcyB0byBDbGVhbiAqL1xuICAgIENsaWVudFNlc3Npb25CZWhhdmlvcltDbGllbnRTZXNzaW9uQmVoYXZpb3JbXCJEZWZhdWx0XCJdID0gMF0gPSBcIkRlZmF1bHRcIjtcbiAgICAvKipcbiAgICAgKiBBbHdheXMgYXNrIGZvciBhIGNsZWFuIHNlc3Npb24gd2hlbiBjb25uZWN0aW5nXG4gICAgICovXG4gICAgQ2xpZW50U2Vzc2lvbkJlaGF2aW9yW0NsaWVudFNlc3Npb25CZWhhdmlvcltcIkNsZWFuXCJdID0gMV0gPSBcIkNsZWFuXCI7XG4gICAgLyoqXG4gICAgICogQWx3YXlzIGF0dGVtcHQgdG8gcmVqb2luIGFuIGV4aXN0aW5nIHNlc3Npb24gYWZ0ZXIgYW4gaW5pdGlhbCBjb25uZWN0aW9uIHN1Y2Nlc3MuXG4gICAgICpcbiAgICAgKiBTZXNzaW9uIHJlam9pbiByZXF1aXJlcyBhbiBhcHByb3ByaWF0ZSBub24temVybyBzZXNzaW9uIGV4cGlyeSBpbnRlcnZhbCBpbiB0aGUgY2xpZW50J3MgQ09OTkVDVCBvcHRpb25zLlxuICAgICAqL1xuICAgIENsaWVudFNlc3Npb25CZWhhdmlvcltDbGllbnRTZXNzaW9uQmVoYXZpb3JbXCJSZWpvaW5Qb3N0U3VjY2Vzc1wiXSA9IDJdID0gXCJSZWpvaW5Qb3N0U3VjY2Vzc1wiO1xuICAgIC8qKlxuICAgICAqIEFsd2F5cyBhdHRlbXB0IHRvIHJlam9pbiBhbiBleGlzdGluZyBzZXNzaW9uLiAgU2luY2UgdGhlIGNsaWVudCBkb2VzIG5vdCB5ZXQgc3VwcG9ydCBkdXJhYmxlIHNlc3Npb24gcGVyc2lzdGVuY2UsXG4gICAgICogdGhpcyBvcHRpb24gaXMgbm90IGd1YXJhbnRlZWQgdG8gYmUgc3BlYyBjb21wbGlhbnQgYmVjYXVzZSBhbnkgdW5hY2tub3dsZWRnZWQgcW9zMSBwdWJsaXNoZXMgKHdoaWNoIGFyZVxuICAgICAqIHBhcnQgb2YgdGhlIGNsaWVudCBzZXNzaW9uIHN0YXRlKSB3aWxsIG5vdCBiZSBwcmVzZW50IG9uIHRoZSBpbml0aWFsIGNvbm5lY3Rpb24uICBVbnRpbCB3ZSBzdXBwb3J0XG4gICAgICogZHVyYWJsZSBzZXNzaW9uIHJlc3VtcHRpb24sIHRoaXMgb3B0aW9uIGlzIHRlY2huaWNhbGx5IHNwZWMtYnJlYWtpbmcsIGJ1dCB1c2VmdWwuXG4gICAgICovXG4gICAgQ2xpZW50U2Vzc2lvbkJlaGF2aW9yW0NsaWVudFNlc3Npb25CZWhhdmlvcltcIlJlam9pbkFsd2F5c1wiXSA9IDNdID0gXCJSZWpvaW5BbHdheXNcIjtcbn0pKENsaWVudFNlc3Npb25CZWhhdmlvciA9IGV4cG9ydHMuQ2xpZW50U2Vzc2lvbkJlaGF2aW9yIHx8IChleHBvcnRzLkNsaWVudFNlc3Npb25CZWhhdmlvciA9IHt9KSk7XG4vKipcbiAqIENvbnRyb2xzIGhvdyB0aGUgcmVjb25uZWN0IGRlbGF5IGlzIG1vZGlmaWVkIGluIG9yZGVyIHRvIHNtb290aCBvdXQgdGhlIGRpc3RyaWJ1dGlvbiBvZiByZWNvbm5lY3Rpb24gYXR0ZW1wdFxuICogdGltZXBvaW50cyBmb3IgYSBsYXJnZSBzZXQgb2YgcmVjb25uZWN0aW5nIGNsaWVudHMuXG4gKlxuICogU2VlIFtFeHBvbmVudGlhbCBCYWNrb2ZmIGFuZCBKaXR0ZXJdKGh0dHBzOi8vYXdzLmFtYXpvbi5jb20vYmxvZ3MvYXJjaGl0ZWN0dXJlL2V4cG9uZW50aWFsLWJhY2tvZmYtYW5kLWppdHRlci8pXG4gKi9cbnZhciBSZXRyeUppdHRlclR5cGU7XG4oZnVuY3Rpb24gKFJldHJ5Sml0dGVyVHlwZSkge1xuICAgIC8qKlxuICAgICAqIE1hcHMgdG8gRnVsbFxuICAgICAqL1xuICAgIFJldHJ5Sml0dGVyVHlwZVtSZXRyeUppdHRlclR5cGVbXCJEZWZhdWx0XCJdID0gMF0gPSBcIkRlZmF1bHRcIjtcbiAgICAvKipcbiAgICAgKiBEbyBub3QgcGVyZm9ybSBhbnkgcmFuZG9taXphdGlvbiBvbiB0aGUgcmVjb25uZWN0IGRlbGF5OlxuICAgICAqIGBgYE5leHRSZWNvbm5lY3REZWxheSA9IEN1cnJlbnRFeHBvbmVudGlhbEJhY2tvZmZWYWx1ZWBgYFxuICAgICAqL1xuICAgIFJldHJ5Sml0dGVyVHlwZVtSZXRyeUppdHRlclR5cGVbXCJOb25lXCJdID0gMV0gPSBcIk5vbmVcIjtcbiAgICAvKipcbiAgICAgKiBGdWxseSByYW5kb20gYmV0d2VlbiBubyBkZWxheSBhbmQgdGhlIGN1cnJlbnQgZXhwb25lbnRpYWwgYmFja29mZiB2YWx1ZS5cbiAgICAgKiBgYGBOZXh0UmVjb25uZWN0RGVsYXkgPSBSYW5kb20oMCwgQ3VycmVudEV4cG9uZW50aWFsQmFja29mZlZhbHVlKWBgYFxuICAgICAqL1xuICAgIFJldHJ5Sml0dGVyVHlwZVtSZXRyeUppdHRlclR5cGVbXCJGdWxsXCJdID0gMl0gPSBcIkZ1bGxcIjtcbiAgICAvKipcbiAgICAgKiBgYGBOZXh0UmVjb25uZWN0RGVsYXkgPSBNaW4oTWF4UmVjb25uZWN0RGVsYXksIFJhbmRvbShNaW5SZWNvbm5lY3REZWxheSwgMyAqIEN1cnJlbnRSZWNvbm5lY3REZWxheSlgYGBcbiAgICAgKi9cbiAgICBSZXRyeUppdHRlclR5cGVbUmV0cnlKaXR0ZXJUeXBlW1wiRGVjb3JyZWxhdGVkXCJdID0gM10gPSBcIkRlY29ycmVsYXRlZFwiO1xufSkoUmV0cnlKaXR0ZXJUeXBlID0gZXhwb3J0cy5SZXRyeUppdHRlclR5cGUgfHwgKGV4cG9ydHMuUmV0cnlKaXR0ZXJUeXBlID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1xdHQ1LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/aws-crt/dist/common/mqtt5.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/aws-crt/dist/common/mqtt5_packet.js":
/*!**********************************************************!*\
  !*** ./node_modules/aws-crt/dist/common/mqtt5_packet.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n * SPDX-License-Identifier: Apache-2.0.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PacketType = exports.RetainHandlingType = exports.QoS = exports.PayloadFormatIndicator = exports.isSuccessfulPubackReasonCode = exports.PubackReasonCode = exports.isSuccessfulUnsubackReasonCode = exports.UnsubackReasonCode = exports.isSuccessfulSubackReasonCode = exports.SubackReasonCode = exports.isSuccessfulDisconnectReasonCode = exports.DisconnectReasonCode = exports.isSuccessfulConnectReasonCode = exports.ConnectReasonCode = void 0;\n/**\n * Server return code for connect attempts.\n *\n * Enum values match [MQTT5 spec](https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901079) encoding values.\n */\nvar ConnectReasonCode;\n(function (ConnectReasonCode) {\n    /**\n     * Returned when the connection is accepted.\n     */\n    ConnectReasonCode[ConnectReasonCode[\"Success\"] = 0] = \"Success\";\n    /**\n     * Returned when the server has a failure but does not want to specify a reason or none\n     * of the other reason codes apply.\n     */\n    ConnectReasonCode[ConnectReasonCode[\"UnspecifiedError\"] = 128] = \"UnspecifiedError\";\n    /**\n     * Returned when data in the CONNECT packet could not be correctly parsed by the server.\n     */\n    ConnectReasonCode[ConnectReasonCode[\"MalformedPacket\"] = 129] = \"MalformedPacket\";\n    /**\n     * Returned when data in the CONNECT packet does not conform to the MQTT5 specification requirements.\n     */\n    ConnectReasonCode[ConnectReasonCode[\"ProtocolError\"] = 130] = \"ProtocolError\";\n    /**\n     * Returned when the CONNECT packet is valid but was not accepted by the server.\n     */\n    ConnectReasonCode[ConnectReasonCode[\"ImplementationSpecificError\"] = 131] = \"ImplementationSpecificError\";\n    /**\n     * Returned when the server does not support MQTT5 protocol version specified in the connection.\n     */\n    ConnectReasonCode[ConnectReasonCode[\"UnsupportedProtocolVersion\"] = 132] = \"UnsupportedProtocolVersion\";\n    /**\n     * Returned when the client identifier in the CONNECT packet is a valid string but not one that\n     * is allowed on the server.\n     */\n    ConnectReasonCode[ConnectReasonCode[\"ClientIdentifierNotValid\"] = 133] = \"ClientIdentifierNotValid\";\n    /**\n     * Returned when the server does not accept the username and/or password specified by the client\n     * in the connection packet.\n     */\n    ConnectReasonCode[ConnectReasonCode[\"BadUsernameOrPassword\"] = 134] = \"BadUsernameOrPassword\";\n    /**\n     * Returned when the client is not authorized to connect to the server.\n     */\n    ConnectReasonCode[ConnectReasonCode[\"NotAuthorized\"] = 135] = \"NotAuthorized\";\n    /**\n     * Returned when the MQTT5 server is not available.\n     */\n    ConnectReasonCode[ConnectReasonCode[\"ServerUnavailable\"] = 136] = \"ServerUnavailable\";\n    /**\n     * Returned when the server is too busy to make a connection. It is recommended that the client try again later.\n     */\n    ConnectReasonCode[ConnectReasonCode[\"ServerBusy\"] = 137] = \"ServerBusy\";\n    /**\n     * Returned when the client has been banned by the server.\n     */\n    ConnectReasonCode[ConnectReasonCode[\"Banned\"] = 138] = \"Banned\";\n    /**\n     * Returned when the authentication method used in the connection is either not supported on the server or it does\n     * not match the authentication method currently in use in the CONNECT packet.\n     */\n    ConnectReasonCode[ConnectReasonCode[\"BadAuthenticationMethod\"] = 140] = \"BadAuthenticationMethod\";\n    /**\n     * Returned when the Will topic name sent in the connection packet is correctly formed, but is not accepted by\n     * the server.\n     */\n    ConnectReasonCode[ConnectReasonCode[\"TopicNameInvalid\"] = 144] = \"TopicNameInvalid\";\n    /**\n     * Returned when the connection packet exceeded the maximum permissible size on the server.\n     */\n    ConnectReasonCode[ConnectReasonCode[\"PacketTooLarge\"] = 149] = \"PacketTooLarge\";\n    /**\n     * Returned when the quota limits set on the server have been met and/or exceeded.\n     */\n    ConnectReasonCode[ConnectReasonCode[\"QuotaExceeded\"] = 151] = \"QuotaExceeded\";\n    /**\n     * Returned when the Will payload in the CONNECT packet does not match the specified payload format indicator.\n     */\n    ConnectReasonCode[ConnectReasonCode[\"PayloadFormatInvalid\"] = 153] = \"PayloadFormatInvalid\";\n    /**\n     * Returned when the server does not retain messages but the connection packet on the client had Will retain enabled.\n     */\n    ConnectReasonCode[ConnectReasonCode[\"RetainNotSupported\"] = 154] = \"RetainNotSupported\";\n    /**\n     * Returned when the server does not support the QOS setting in the Will QOS in the connection packet.\n     */\n    ConnectReasonCode[ConnectReasonCode[\"QosNotSupported\"] = 155] = \"QosNotSupported\";\n    /**\n     * Returned when the server is telling the client to temporarily use another server instead of the one they\n     * are trying to connect to.\n     */\n    ConnectReasonCode[ConnectReasonCode[\"UseAnotherServer\"] = 156] = \"UseAnotherServer\";\n    /**\n     * Returned when the server is telling the client to permanently use another server instead of the one they\n     * are trying to connect to.\n     */\n    ConnectReasonCode[ConnectReasonCode[\"ServerMoved\"] = 157] = \"ServerMoved\";\n    /**\n     * Returned when the server connection rate limit has been exceeded.\n     */\n    ConnectReasonCode[ConnectReasonCode[\"ConnectionRateExceeded\"] = 159] = \"ConnectionRateExceeded\";\n})(ConnectReasonCode = exports.ConnectReasonCode || (exports.ConnectReasonCode = {}));\n/**\n * Determines if a reason code represents a successful connect operation\n *\n * @param reasonCode reason code to check success for\n */\nfunction isSuccessfulConnectReasonCode(reasonCode) {\n    return reasonCode < 128;\n}\nexports.isSuccessfulConnectReasonCode = isSuccessfulConnectReasonCode;\n/**\n * Reason code inside DISCONNECT packets.  Helps determine why a connection was terminated.\n *\n * Enum values match [MQTT5 spec](https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901208) encoding values.\n */\nvar DisconnectReasonCode;\n(function (DisconnectReasonCode) {\n    /**\n     * Returned when the remote endpoint wishes to disconnect normally. Will not trigger the publish of a Will message if a\n     * Will message was configured on the connection.\n     *\n     * May be sent by the client or server.\n     */\n    DisconnectReasonCode[DisconnectReasonCode[\"NormalDisconnection\"] = 0] = \"NormalDisconnection\";\n    /**\n     * Returns that the client wants to disconnect but requires that the server publish the Will message configured\n     * on the connection.\n     *\n     * May only be sent by the client.\n     */\n    DisconnectReasonCode[DisconnectReasonCode[\"DisconnectWithWillMessage\"] = 4] = \"DisconnectWithWillMessage\";\n    /**\n     * Returned when the connection was closed but the sender does not want to specify a reason or none\n     * of the other reason codes apply.\n     *\n     * May be sent by the client or the server.\n     */\n    DisconnectReasonCode[DisconnectReasonCode[\"UnspecifiedError\"] = 128] = \"UnspecifiedError\";\n    /**\n     * Indicates the remote endpoint received a packet that does not conform to the MQTT specification.\n     *\n     * May be sent by the client or the server.\n     */\n    DisconnectReasonCode[DisconnectReasonCode[\"MalformedPacket\"] = 129] = \"MalformedPacket\";\n    /**\n     * Returned when an unexpected or out-of-order packet was received by the remote endpoint.\n     *\n     * May be sent by the client or the server.\n     */\n    DisconnectReasonCode[DisconnectReasonCode[\"ProtocolError\"] = 130] = \"ProtocolError\";\n    /**\n     * Returned when a valid packet was received by the remote endpoint, but could not be processed by the current implementation.\n     *\n     * May be sent by the client or the server.\n     */\n    DisconnectReasonCode[DisconnectReasonCode[\"ImplementationSpecificError\"] = 131] = \"ImplementationSpecificError\";\n    /**\n     * Returned when the remote endpoint received a packet that represented an operation that was not authorized within\n     * the current connection.\n     *\n     * May only be sent by the server.\n     */\n    DisconnectReasonCode[DisconnectReasonCode[\"NotAuthorized\"] = 135] = \"NotAuthorized\";\n    /**\n     * Returned when the server is busy and cannot continue processing packets from the client.\n     *\n     * May only be sent by the server.\n     */\n    DisconnectReasonCode[DisconnectReasonCode[\"ServerBusy\"] = 137] = \"ServerBusy\";\n    /**\n     * Returned when the server is shutting down.\n     *\n     * May only be sent by the server.\n     */\n    DisconnectReasonCode[DisconnectReasonCode[\"ServerShuttingDown\"] = 139] = \"ServerShuttingDown\";\n    /**\n     * Returned when the server closes the connection because no packet from the client has been received in\n     * 1.5 times the KeepAlive time set when the connection was established.\n     *\n     * May only be sent by the server.\n     */\n    DisconnectReasonCode[DisconnectReasonCode[\"KeepAliveTimeout\"] = 141] = \"KeepAliveTimeout\";\n    /**\n     * Returned when the server has established another connection with the same client ID as a client's current\n     * connection, causing the current client to become disconnected.\n     *\n     * May only be sent by the server.\n     */\n    DisconnectReasonCode[DisconnectReasonCode[\"SessionTakenOver\"] = 142] = \"SessionTakenOver\";\n    /**\n     * Returned when the topic filter name is correctly formed but not accepted by the server.\n     *\n     * May only be sent by the server.\n     */\n    DisconnectReasonCode[DisconnectReasonCode[\"TopicFilterInvalid\"] = 143] = \"TopicFilterInvalid\";\n    /**\n     * Returned when topic name is correctly formed, but is not accepted.\n     *\n     * May be sent by the client or the server.\n     */\n    DisconnectReasonCode[DisconnectReasonCode[\"TopicNameInvalid\"] = 144] = \"TopicNameInvalid\";\n    /**\n     * Returned when the remote endpoint reached a state where there were more in-progress QoS1+ publishes then the\n     * limit it established for itself when the connection was opened.\n     *\n     * May be sent by the client or the server.\n     */\n    DisconnectReasonCode[DisconnectReasonCode[\"ReceiveMaximumExceeded\"] = 147] = \"ReceiveMaximumExceeded\";\n    /**\n     * Returned when the remote endpoint receives a PUBLISH packet that contained a topic alias greater than the\n     * maximum topic alias limit that it established for itself when the connection was opened.\n     *\n     * May be sent by the client or the server.\n     */\n    DisconnectReasonCode[DisconnectReasonCode[\"TopicAliasInvalid\"] = 148] = \"TopicAliasInvalid\";\n    /**\n     * Returned when the remote endpoint received a packet whose size was greater than the maximum packet size limit\n     * it established for itself when the connection was opened.\n     *\n     * May be sent by the client or the server.\n     */\n    DisconnectReasonCode[DisconnectReasonCode[\"PacketTooLarge\"] = 149] = \"PacketTooLarge\";\n    /**\n     * Returned when the remote endpoint's incoming data rate was too high.\n     *\n     * May be sent by the client or the server.\n     */\n    DisconnectReasonCode[DisconnectReasonCode[\"MessageRateTooHigh\"] = 150] = \"MessageRateTooHigh\";\n    /**\n     * Returned when an internal quota of the remote endpoint was exceeded.\n     *\n     * May be sent by the client or the server.\n     */\n    DisconnectReasonCode[DisconnectReasonCode[\"QuotaExceeded\"] = 151] = \"QuotaExceeded\";\n    /**\n     * Returned when the connection was closed due to an administrative action.\n     *\n     * May be sent by the client or the server.\n     */\n    DisconnectReasonCode[DisconnectReasonCode[\"AdministrativeAction\"] = 152] = \"AdministrativeAction\";\n    /**\n     * Returned when the remote endpoint received a packet where payload format did not match the format specified\n     * by the payload format indicator.\n     *\n     * May be sent by the client or the server.\n     */\n    DisconnectReasonCode[DisconnectReasonCode[\"PayloadFormatInvalid\"] = 153] = \"PayloadFormatInvalid\";\n    /**\n     * Returned when the server does not support retained messages.\n     *\n     * May only be sent by the server.\n     */\n    DisconnectReasonCode[DisconnectReasonCode[\"RetainNotSupported\"] = 154] = \"RetainNotSupported\";\n    /**\n     * Returned when the client sends a QOS that is greater than the maximum QOS established when the connection was\n     * opened.\n     *\n     * May only be sent by the server.\n     */\n    DisconnectReasonCode[DisconnectReasonCode[\"QosNotSupported\"] = 155] = \"QosNotSupported\";\n    /**\n     * Returned by the server to tell the client to temporarily use a different server.\n     *\n     * May only be sent by the server.\n     */\n    DisconnectReasonCode[DisconnectReasonCode[\"UseAnotherServer\"] = 156] = \"UseAnotherServer\";\n    /**\n     * Returned by the server to tell the client to permanently use a different server.\n     *\n     * May only be sent by the server.\n     */\n    DisconnectReasonCode[DisconnectReasonCode[\"ServerMoved\"] = 157] = \"ServerMoved\";\n    /**\n     * Returned by the server to tell the client that shared subscriptions are not supported on the server.\n     *\n     * May only be sent by the server.\n     */\n    DisconnectReasonCode[DisconnectReasonCode[\"SharedSubscriptionsNotSupported\"] = 158] = \"SharedSubscriptionsNotSupported\";\n    /**\n     * Returned when the server disconnects the client due to the connection rate being too high.\n     *\n     * May only be sent by the server.\n     */\n    DisconnectReasonCode[DisconnectReasonCode[\"ConnectionRateExceeded\"] = 159] = \"ConnectionRateExceeded\";\n    /**\n     * Returned by the server when the maximum connection time authorized for the connection was exceeded.\n     *\n     * May only be sent by the server.\n     */\n    DisconnectReasonCode[DisconnectReasonCode[\"MaximumConnectTime\"] = 160] = \"MaximumConnectTime\";\n    /**\n     * Returned by the server when it received a SUBSCRIBE packet with a subscription identifier, but the server does\n     * not support subscription identifiers.\n     *\n     * May only be sent by the server.\n     */\n    DisconnectReasonCode[DisconnectReasonCode[\"SubscriptionIdentifiersNotSupported\"] = 161] = \"SubscriptionIdentifiersNotSupported\";\n    /**\n     * Returned by the server when it received a SUBSCRIBE packet with a wildcard topic filter, but the server does\n     * not support wildcard topic filters.\n     *\n     * May only be sent by the server.\n     */\n    DisconnectReasonCode[DisconnectReasonCode[\"WildcardSubscriptionsNotSupported\"] = 162] = \"WildcardSubscriptionsNotSupported\";\n})(DisconnectReasonCode = exports.DisconnectReasonCode || (exports.DisconnectReasonCode = {}));\n/**\n * Determines if a reason code represents a successful disconnect operation\n *\n * @param reasonCode reason code to check success for\n */\nfunction isSuccessfulDisconnectReasonCode(reasonCode) {\n    return reasonCode < 128;\n}\nexports.isSuccessfulDisconnectReasonCode = isSuccessfulDisconnectReasonCode;\n/**\n * Reason codes inside SUBACK packet payloads that specify the results for each subscription in the associated\n * SUBSCRIBE packet.\n *\n * Enum values match [MQTT5 spec](https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901178) encoding values.\n */\nvar SubackReasonCode;\n(function (SubackReasonCode) {\n    /**\n     * Returned when the subscription was accepted and the maximum QOS sent will be QOS 0.\n     */\n    SubackReasonCode[SubackReasonCode[\"GrantedQoS0\"] = 0] = \"GrantedQoS0\";\n    /**\n     * Returned when the subscription was accepted and the maximum QOS sent will be QOS 1.\n     */\n    SubackReasonCode[SubackReasonCode[\"GrantedQoS1\"] = 1] = \"GrantedQoS1\";\n    /**\n     * Returned when the subscription was accepted and the maximum QOS sent will be QOS 2.\n     */\n    SubackReasonCode[SubackReasonCode[\"GrantedQoS2\"] = 2] = \"GrantedQoS2\";\n    /**\n     * Returned when the connection was closed but the sender does not want to specify a reason or none\n     * of the other reason codes apply.\n     */\n    SubackReasonCode[SubackReasonCode[\"UnspecifiedError\"] = 128] = \"UnspecifiedError\";\n    /**\n     * Returned when the subscription was valid but the server did not accept it.\n     */\n    SubackReasonCode[SubackReasonCode[\"ImplementationSpecificError\"] = 131] = \"ImplementationSpecificError\";\n    /**\n     * Returned when the client was not authorized to make the subscription on the server.\n     */\n    SubackReasonCode[SubackReasonCode[\"NotAuthorized\"] = 135] = \"NotAuthorized\";\n    /**\n     * Returned when the subscription topic filter was correctly formed but not allowed for the client.\n     */\n    SubackReasonCode[SubackReasonCode[\"TopicFilterInvalid\"] = 143] = \"TopicFilterInvalid\";\n    /**\n     * Returned when the packet identifier was already in use on the server.\n     */\n    SubackReasonCode[SubackReasonCode[\"PacketIdentifierInUse\"] = 145] = \"PacketIdentifierInUse\";\n    /**\n     * Returned when a subscribe-related quota set on the server was exceeded.\n     */\n    SubackReasonCode[SubackReasonCode[\"QuotaExceeded\"] = 151] = \"QuotaExceeded\";\n    /**\n     * Returned when the subscription's topic filter was a shared subscription and the server does not support\n     * shared subscriptions.\n     */\n    SubackReasonCode[SubackReasonCode[\"SharedSubscriptionsNotSupported\"] = 158] = \"SharedSubscriptionsNotSupported\";\n    /**\n     * Returned when the SUBSCRIBE packet contained a subscription identifier and the server does not support\n     * subscription identifiers.\n     */\n    SubackReasonCode[SubackReasonCode[\"SubscriptionIdentifiersNotSupported\"] = 161] = \"SubscriptionIdentifiersNotSupported\";\n    /**\n     * Returned when the subscription's topic filter contains a wildcard but the server does not support\n     * wildcard subscriptions.\n     */\n    SubackReasonCode[SubackReasonCode[\"WildcardSubscriptionsNotSupported\"] = 162] = \"WildcardSubscriptionsNotSupported\";\n})(SubackReasonCode = exports.SubackReasonCode || (exports.SubackReasonCode = {}));\n/**\n * Determines if a reason code represents a successful subscribe operation\n *\n * @param reasonCode reason code to check success for\n */\nfunction isSuccessfulSubackReasonCode(reasonCode) {\n    return reasonCode < 128;\n}\nexports.isSuccessfulSubackReasonCode = isSuccessfulSubackReasonCode;\n/**\n * Reason codes inside UNSUBACK packet payloads that specify the results for each topic filter in the associated\n * UNSUBSCRIBE packet.\n *\n * Enum values match [MQTT5 spec](https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901194) encoding values.\n */\nvar UnsubackReasonCode;\n(function (UnsubackReasonCode) {\n    /**\n     * Returned when the unsubscribe was successful and the client is no longer subscribed to the topic filter on the server.\n     */\n    UnsubackReasonCode[UnsubackReasonCode[\"Success\"] = 0] = \"Success\";\n    /**\n     * Returned when the topic filter did not match one of the client's existing subscriptions on the server.\n     */\n    UnsubackReasonCode[UnsubackReasonCode[\"NoSubscriptionExisted\"] = 17] = \"NoSubscriptionExisted\";\n    /**\n     * Returned when the unsubscribe of the topic filter was not accepted and the server does not want to specify a\n     * reason or none of the other reason codes apply.\n     */\n    UnsubackReasonCode[UnsubackReasonCode[\"UnspecifiedError\"] = 128] = \"UnspecifiedError\";\n    /**\n     * Returned when the topic filter was valid but the server does not accept an unsubscribe for it.\n     */\n    UnsubackReasonCode[UnsubackReasonCode[\"ImplementationSpecificError\"] = 131] = \"ImplementationSpecificError\";\n    /**\n     * Returned when the client was not authorized to unsubscribe from that topic filter on the server.\n     */\n    UnsubackReasonCode[UnsubackReasonCode[\"NotAuthorized\"] = 135] = \"NotAuthorized\";\n    /**\n     * Returned when the topic filter was correctly formed but is not allowed for the client on the server.\n     */\n    UnsubackReasonCode[UnsubackReasonCode[\"TopicFilterInvalid\"] = 143] = \"TopicFilterInvalid\";\n    /**\n     * Returned when the packet identifier was already in use on the server.\n     */\n    UnsubackReasonCode[UnsubackReasonCode[\"PacketIdentifierInUse\"] = 145] = \"PacketIdentifierInUse\";\n})(UnsubackReasonCode = exports.UnsubackReasonCode || (exports.UnsubackReasonCode = {}));\n/**\n * Determines if a reason code represents a successful unsubscribe operation\n *\n * @param reasonCode reason code to check success for\n */\nfunction isSuccessfulUnsubackReasonCode(reasonCode) {\n    return reasonCode < 128;\n}\nexports.isSuccessfulUnsubackReasonCode = isSuccessfulUnsubackReasonCode;\n/**\n * Reason code inside PUBACK packets that indicates the result of the associated PUBLISH request.\n *\n * Enum values match [MQTT5 spec](https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901124) encoding values.\n */\nvar PubackReasonCode;\n(function (PubackReasonCode) {\n    /**\n     * Returned when the (QoS 1) publish was accepted by the recipient.\n     *\n     * May be sent by the client or the server.\n     */\n    PubackReasonCode[PubackReasonCode[\"Success\"] = 0] = \"Success\";\n    /**\n     * Returned when the (QoS 1) publish was accepted but there were no matching subscribers.\n     *\n     * May only be sent by the server.\n     */\n    PubackReasonCode[PubackReasonCode[\"NoMatchingSubscribers\"] = 16] = \"NoMatchingSubscribers\";\n    /**\n     * Returned when the (QoS 1) publish was not accepted and the receiver does not want to specify a reason or none\n     * of the other reason codes apply.\n     *\n     * May be sent by the client or the server.\n     */\n    PubackReasonCode[PubackReasonCode[\"UnspecifiedError\"] = 128] = \"UnspecifiedError\";\n    /**\n     * Returned when the (QoS 1) publish was valid but the receiver was not willing to accept it.\n     *\n     * May be sent by the client or the server.\n     */\n    PubackReasonCode[PubackReasonCode[\"ImplementationSpecificError\"] = 131] = \"ImplementationSpecificError\";\n    /**\n     * Returned when the (QoS 1) publish was not authorized by the receiver.\n     *\n     * May be sent by the client or the server.\n     */\n    PubackReasonCode[PubackReasonCode[\"NotAuthorized\"] = 135] = \"NotAuthorized\";\n    /**\n     * Returned when the topic name was valid but the receiver was not willing to accept it.\n     *\n     * May be sent by the client or the server.\n     */\n    PubackReasonCode[PubackReasonCode[\"TopicNameInvalid\"] = 144] = \"TopicNameInvalid\";\n    /**\n     * Returned when the packet identifier used in the associated PUBLISH was already in use.\n     * This can indicate a mismatch in the session state between client and server.\n     *\n     * May be sent by the client or the server.\n     */\n    PubackReasonCode[PubackReasonCode[\"PacketIdentifierInUse\"] = 145] = \"PacketIdentifierInUse\";\n    /**\n     * Returned when the associated PUBLISH failed because an internal quota on the recipient was exceeded.\n     *\n     * May be sent by the client or the server.\n     */\n    PubackReasonCode[PubackReasonCode[\"QuotaExceeded\"] = 151] = \"QuotaExceeded\";\n    /**\n     * Returned when the PUBLISH packet's payload format did not match its payload format indicator property.\n     *\n     * May be sent by the client or the server.\n     */\n    PubackReasonCode[PubackReasonCode[\"PayloadFormatInvalid\"] = 153] = \"PayloadFormatInvalid\";\n})(PubackReasonCode = exports.PubackReasonCode || (exports.PubackReasonCode = {}));\n/**\n * Determines if a reason code represents a successful QoS 1 publish operation\n *\n * @param reasonCode reason code to check success for\n */\nfunction isSuccessfulPubackReasonCode(reasonCode) {\n    return reasonCode < 128;\n}\nexports.isSuccessfulPubackReasonCode = isSuccessfulPubackReasonCode;\n/**\n * Optional property describing a PUBLISH payload's format.\n *\n * Enum values match [MQTT5 spec](https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901111) encoding values.\n */\nvar PayloadFormatIndicator;\n(function (PayloadFormatIndicator) {\n    /**\n     * The payload is arbitrary binary data\n     */\n    PayloadFormatIndicator[PayloadFormatIndicator[\"Bytes\"] = 0] = \"Bytes\";\n    /**\n     * The payload is a well-formed utf-8 string value.\n     */\n    PayloadFormatIndicator[PayloadFormatIndicator[\"Utf8\"] = 1] = \"Utf8\";\n})(PayloadFormatIndicator = exports.PayloadFormatIndicator || (exports.PayloadFormatIndicator = {}));\n/**\n * MQTT message delivery quality of service.\n *\n * Enum values match [MQTT5 spec](https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901234) encoding values.\n */\nvar QoS;\n(function (QoS) {\n    /**\n     * The message is delivered according to the capabilities of the underlying network. No response is sent by the\n     * receiver and no retry is performed by the sender. The message arrives at the receiver either once or not at all.\n     */\n    QoS[QoS[\"AtMostOnce\"] = 0] = \"AtMostOnce\";\n    /**\n     * A level of service that ensures that the message arrives at the receiver at least once.\n     */\n    QoS[QoS[\"AtLeastOnce\"] = 1] = \"AtLeastOnce\";\n    /**\n     * A level of service that ensures that the message arrives at the receiver exactly once.\n     */\n    QoS[QoS[\"ExactlyOnce\"] = 2] = \"ExactlyOnce\";\n})(QoS = exports.QoS || (exports.QoS = {}));\n/**\n * Configures how retained messages should be handled when subscribing with a topic filter that matches topics with\n * associated retained messages.\n *\n * Enum values match [MQTT5 spec](https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901169) encoding values.\n */\nvar RetainHandlingType;\n(function (RetainHandlingType) {\n    /**\n     * The server should always send all retained messages on topics that match a subscription's filter.\n     */\n    RetainHandlingType[RetainHandlingType[\"SendOnSubscribe\"] = 0] = \"SendOnSubscribe\";\n    /**\n     * The server should send retained messages on topics that match the subscription's filter, but only for the\n     * first matching subscription, per session.\n     */\n    RetainHandlingType[RetainHandlingType[\"SendOnSubscribeIfNew\"] = 1] = \"SendOnSubscribeIfNew\";\n    /**\n     * Subscriptions must not trigger any retained message publishes from the server.\n     */\n    RetainHandlingType[RetainHandlingType[\"DontSend\"] = 2] = \"DontSend\";\n})(RetainHandlingType = exports.RetainHandlingType || (exports.RetainHandlingType = {}));\n/**\n * Packet type indicator that allows for basic polymorphism with user-received packets.  Enum values\n * match the mqtt spec's [packet type encoding](https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901022) values.\n */\nvar PacketType;\n(function (PacketType) {\n    PacketType[PacketType[\"Connect\"] = 1] = \"Connect\";\n    PacketType[PacketType[\"Connack\"] = 2] = \"Connack\";\n    PacketType[PacketType[\"Publish\"] = 3] = \"Publish\";\n    PacketType[PacketType[\"Puback\"] = 4] = \"Puback\";\n    PacketType[PacketType[\"Pubrec\"] = 5] = \"Pubrec\";\n    PacketType[PacketType[\"Pubrel\"] = 6] = \"Pubrel\";\n    PacketType[PacketType[\"Pubcomp\"] = 7] = \"Pubcomp\";\n    PacketType[PacketType[\"Subscribe\"] = 8] = \"Subscribe\";\n    PacketType[PacketType[\"Suback\"] = 9] = \"Suback\";\n    PacketType[PacketType[\"Unsubscribe\"] = 10] = \"Unsubscribe\";\n    PacketType[PacketType[\"Unsuback\"] = 11] = \"Unsuback\";\n    PacketType[PacketType[\"Pingreq\"] = 12] = \"Pingreq\";\n    PacketType[PacketType[\"Pingresp\"] = 13] = \"Pingresp\";\n    PacketType[PacketType[\"Disconnect\"] = 14] = \"Disconnect\";\n    PacketType[PacketType[\"Auth\"] = 15] = \"Auth\";\n})(PacketType = exports.PacketType || (exports.PacketType = {}));\n//# sourceMappingURL=mqtt5_packet.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXdzLWNydC9kaXN0L2NvbW1vbi9tcXR0NV9wYWNrZXQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0IsR0FBRywwQkFBMEIsR0FBRyxXQUFXLEdBQUcsOEJBQThCLEdBQUcsb0NBQW9DLEdBQUcsd0JBQXdCLEdBQUcsc0NBQXNDLEdBQUcsMEJBQTBCLEdBQUcsb0NBQW9DLEdBQUcsd0JBQXdCLEdBQUcsd0NBQXdDLEdBQUcsNEJBQTRCLEdBQUcscUNBQXFDLEdBQUcseUJBQXlCO0FBQ3RiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0RBQW9ELHlCQUF5QixLQUFLO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMERBQTBELDRCQUE0QixLQUFLO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrREFBa0Qsd0JBQXdCLEtBQUs7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0RBQXNELDBCQUEwQixLQUFLO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrREFBa0Qsd0JBQXdCLEtBQUs7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhEQUE4RCw4QkFBOEIsS0FBSztBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3QkFBd0IsV0FBVyxLQUFLO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0RBQXNELDBCQUEwQixLQUFLO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0NBQXNDLGtCQUFrQixLQUFLO0FBQzlEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGF5d2luZC8uL25vZGVfbW9kdWxlcy9hd3MtY3J0L2Rpc3QvY29tbW9uL21xdHQ1X3BhY2tldC5qcz9iYTNmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjAuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUGFja2V0VHlwZSA9IGV4cG9ydHMuUmV0YWluSGFuZGxpbmdUeXBlID0gZXhwb3J0cy5Rb1MgPSBleHBvcnRzLlBheWxvYWRGb3JtYXRJbmRpY2F0b3IgPSBleHBvcnRzLmlzU3VjY2Vzc2Z1bFB1YmFja1JlYXNvbkNvZGUgPSBleHBvcnRzLlB1YmFja1JlYXNvbkNvZGUgPSBleHBvcnRzLmlzU3VjY2Vzc2Z1bFVuc3ViYWNrUmVhc29uQ29kZSA9IGV4cG9ydHMuVW5zdWJhY2tSZWFzb25Db2RlID0gZXhwb3J0cy5pc1N1Y2Nlc3NmdWxTdWJhY2tSZWFzb25Db2RlID0gZXhwb3J0cy5TdWJhY2tSZWFzb25Db2RlID0gZXhwb3J0cy5pc1N1Y2Nlc3NmdWxEaXNjb25uZWN0UmVhc29uQ29kZSA9IGV4cG9ydHMuRGlzY29ubmVjdFJlYXNvbkNvZGUgPSBleHBvcnRzLmlzU3VjY2Vzc2Z1bENvbm5lY3RSZWFzb25Db2RlID0gZXhwb3J0cy5Db25uZWN0UmVhc29uQ29kZSA9IHZvaWQgMDtcbi8qKlxuICogU2VydmVyIHJldHVybiBjb2RlIGZvciBjb25uZWN0IGF0dGVtcHRzLlxuICpcbiAqIEVudW0gdmFsdWVzIG1hdGNoIFtNUVRUNSBzcGVjXShodHRwczovL2RvY3Mub2FzaXMtb3Blbi5vcmcvbXF0dC9tcXR0L3Y1LjAvb3MvbXF0dC12NS4wLW9zLmh0bWwjX1RvYzM5MDEwNzkpIGVuY29kaW5nIHZhbHVlcy5cbiAqL1xudmFyIENvbm5lY3RSZWFzb25Db2RlO1xuKGZ1bmN0aW9uIChDb25uZWN0UmVhc29uQ29kZSkge1xuICAgIC8qKlxuICAgICAqIFJldHVybmVkIHdoZW4gdGhlIGNvbm5lY3Rpb24gaXMgYWNjZXB0ZWQuXG4gICAgICovXG4gICAgQ29ubmVjdFJlYXNvbkNvZGVbQ29ubmVjdFJlYXNvbkNvZGVbXCJTdWNjZXNzXCJdID0gMF0gPSBcIlN1Y2Nlc3NcIjtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5lZCB3aGVuIHRoZSBzZXJ2ZXIgaGFzIGEgZmFpbHVyZSBidXQgZG9lcyBub3Qgd2FudCB0byBzcGVjaWZ5IGEgcmVhc29uIG9yIG5vbmVcbiAgICAgKiBvZiB0aGUgb3RoZXIgcmVhc29uIGNvZGVzIGFwcGx5LlxuICAgICAqL1xuICAgIENvbm5lY3RSZWFzb25Db2RlW0Nvbm5lY3RSZWFzb25Db2RlW1wiVW5zcGVjaWZpZWRFcnJvclwiXSA9IDEyOF0gPSBcIlVuc3BlY2lmaWVkRXJyb3JcIjtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5lZCB3aGVuIGRhdGEgaW4gdGhlIENPTk5FQ1QgcGFja2V0IGNvdWxkIG5vdCBiZSBjb3JyZWN0bHkgcGFyc2VkIGJ5IHRoZSBzZXJ2ZXIuXG4gICAgICovXG4gICAgQ29ubmVjdFJlYXNvbkNvZGVbQ29ubmVjdFJlYXNvbkNvZGVbXCJNYWxmb3JtZWRQYWNrZXRcIl0gPSAxMjldID0gXCJNYWxmb3JtZWRQYWNrZXRcIjtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5lZCB3aGVuIGRhdGEgaW4gdGhlIENPTk5FQ1QgcGFja2V0IGRvZXMgbm90IGNvbmZvcm0gdG8gdGhlIE1RVFQ1IHNwZWNpZmljYXRpb24gcmVxdWlyZW1lbnRzLlxuICAgICAqL1xuICAgIENvbm5lY3RSZWFzb25Db2RlW0Nvbm5lY3RSZWFzb25Db2RlW1wiUHJvdG9jb2xFcnJvclwiXSA9IDEzMF0gPSBcIlByb3RvY29sRXJyb3JcIjtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5lZCB3aGVuIHRoZSBDT05ORUNUIHBhY2tldCBpcyB2YWxpZCBidXQgd2FzIG5vdCBhY2NlcHRlZCBieSB0aGUgc2VydmVyLlxuICAgICAqL1xuICAgIENvbm5lY3RSZWFzb25Db2RlW0Nvbm5lY3RSZWFzb25Db2RlW1wiSW1wbGVtZW50YXRpb25TcGVjaWZpY0Vycm9yXCJdID0gMTMxXSA9IFwiSW1wbGVtZW50YXRpb25TcGVjaWZpY0Vycm9yXCI7XG4gICAgLyoqXG4gICAgICogUmV0dXJuZWQgd2hlbiB0aGUgc2VydmVyIGRvZXMgbm90IHN1cHBvcnQgTVFUVDUgcHJvdG9jb2wgdmVyc2lvbiBzcGVjaWZpZWQgaW4gdGhlIGNvbm5lY3Rpb24uXG4gICAgICovXG4gICAgQ29ubmVjdFJlYXNvbkNvZGVbQ29ubmVjdFJlYXNvbkNvZGVbXCJVbnN1cHBvcnRlZFByb3RvY29sVmVyc2lvblwiXSA9IDEzMl0gPSBcIlVuc3VwcG9ydGVkUHJvdG9jb2xWZXJzaW9uXCI7XG4gICAgLyoqXG4gICAgICogUmV0dXJuZWQgd2hlbiB0aGUgY2xpZW50IGlkZW50aWZpZXIgaW4gdGhlIENPTk5FQ1QgcGFja2V0IGlzIGEgdmFsaWQgc3RyaW5nIGJ1dCBub3Qgb25lIHRoYXRcbiAgICAgKiBpcyBhbGxvd2VkIG9uIHRoZSBzZXJ2ZXIuXG4gICAgICovXG4gICAgQ29ubmVjdFJlYXNvbkNvZGVbQ29ubmVjdFJlYXNvbkNvZGVbXCJDbGllbnRJZGVudGlmaWVyTm90VmFsaWRcIl0gPSAxMzNdID0gXCJDbGllbnRJZGVudGlmaWVyTm90VmFsaWRcIjtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5lZCB3aGVuIHRoZSBzZXJ2ZXIgZG9lcyBub3QgYWNjZXB0IHRoZSB1c2VybmFtZSBhbmQvb3IgcGFzc3dvcmQgc3BlY2lmaWVkIGJ5IHRoZSBjbGllbnRcbiAgICAgKiBpbiB0aGUgY29ubmVjdGlvbiBwYWNrZXQuXG4gICAgICovXG4gICAgQ29ubmVjdFJlYXNvbkNvZGVbQ29ubmVjdFJlYXNvbkNvZGVbXCJCYWRVc2VybmFtZU9yUGFzc3dvcmRcIl0gPSAxMzRdID0gXCJCYWRVc2VybmFtZU9yUGFzc3dvcmRcIjtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5lZCB3aGVuIHRoZSBjbGllbnQgaXMgbm90IGF1dGhvcml6ZWQgdG8gY29ubmVjdCB0byB0aGUgc2VydmVyLlxuICAgICAqL1xuICAgIENvbm5lY3RSZWFzb25Db2RlW0Nvbm5lY3RSZWFzb25Db2RlW1wiTm90QXV0aG9yaXplZFwiXSA9IDEzNV0gPSBcIk5vdEF1dGhvcml6ZWRcIjtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5lZCB3aGVuIHRoZSBNUVRUNSBzZXJ2ZXIgaXMgbm90IGF2YWlsYWJsZS5cbiAgICAgKi9cbiAgICBDb25uZWN0UmVhc29uQ29kZVtDb25uZWN0UmVhc29uQ29kZVtcIlNlcnZlclVuYXZhaWxhYmxlXCJdID0gMTM2XSA9IFwiU2VydmVyVW5hdmFpbGFibGVcIjtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5lZCB3aGVuIHRoZSBzZXJ2ZXIgaXMgdG9vIGJ1c3kgdG8gbWFrZSBhIGNvbm5lY3Rpb24uIEl0IGlzIHJlY29tbWVuZGVkIHRoYXQgdGhlIGNsaWVudCB0cnkgYWdhaW4gbGF0ZXIuXG4gICAgICovXG4gICAgQ29ubmVjdFJlYXNvbkNvZGVbQ29ubmVjdFJlYXNvbkNvZGVbXCJTZXJ2ZXJCdXN5XCJdID0gMTM3XSA9IFwiU2VydmVyQnVzeVwiO1xuICAgIC8qKlxuICAgICAqIFJldHVybmVkIHdoZW4gdGhlIGNsaWVudCBoYXMgYmVlbiBiYW5uZWQgYnkgdGhlIHNlcnZlci5cbiAgICAgKi9cbiAgICBDb25uZWN0UmVhc29uQ29kZVtDb25uZWN0UmVhc29uQ29kZVtcIkJhbm5lZFwiXSA9IDEzOF0gPSBcIkJhbm5lZFwiO1xuICAgIC8qKlxuICAgICAqIFJldHVybmVkIHdoZW4gdGhlIGF1dGhlbnRpY2F0aW9uIG1ldGhvZCB1c2VkIGluIHRoZSBjb25uZWN0aW9uIGlzIGVpdGhlciBub3Qgc3VwcG9ydGVkIG9uIHRoZSBzZXJ2ZXIgb3IgaXQgZG9lc1xuICAgICAqIG5vdCBtYXRjaCB0aGUgYXV0aGVudGljYXRpb24gbWV0aG9kIGN1cnJlbnRseSBpbiB1c2UgaW4gdGhlIENPTk5FQ1QgcGFja2V0LlxuICAgICAqL1xuICAgIENvbm5lY3RSZWFzb25Db2RlW0Nvbm5lY3RSZWFzb25Db2RlW1wiQmFkQXV0aGVudGljYXRpb25NZXRob2RcIl0gPSAxNDBdID0gXCJCYWRBdXRoZW50aWNhdGlvbk1ldGhvZFwiO1xuICAgIC8qKlxuICAgICAqIFJldHVybmVkIHdoZW4gdGhlIFdpbGwgdG9waWMgbmFtZSBzZW50IGluIHRoZSBjb25uZWN0aW9uIHBhY2tldCBpcyBjb3JyZWN0bHkgZm9ybWVkLCBidXQgaXMgbm90IGFjY2VwdGVkIGJ5XG4gICAgICogdGhlIHNlcnZlci5cbiAgICAgKi9cbiAgICBDb25uZWN0UmVhc29uQ29kZVtDb25uZWN0UmVhc29uQ29kZVtcIlRvcGljTmFtZUludmFsaWRcIl0gPSAxNDRdID0gXCJUb3BpY05hbWVJbnZhbGlkXCI7XG4gICAgLyoqXG4gICAgICogUmV0dXJuZWQgd2hlbiB0aGUgY29ubmVjdGlvbiBwYWNrZXQgZXhjZWVkZWQgdGhlIG1heGltdW0gcGVybWlzc2libGUgc2l6ZSBvbiB0aGUgc2VydmVyLlxuICAgICAqL1xuICAgIENvbm5lY3RSZWFzb25Db2RlW0Nvbm5lY3RSZWFzb25Db2RlW1wiUGFja2V0VG9vTGFyZ2VcIl0gPSAxNDldID0gXCJQYWNrZXRUb29MYXJnZVwiO1xuICAgIC8qKlxuICAgICAqIFJldHVybmVkIHdoZW4gdGhlIHF1b3RhIGxpbWl0cyBzZXQgb24gdGhlIHNlcnZlciBoYXZlIGJlZW4gbWV0IGFuZC9vciBleGNlZWRlZC5cbiAgICAgKi9cbiAgICBDb25uZWN0UmVhc29uQ29kZVtDb25uZWN0UmVhc29uQ29kZVtcIlF1b3RhRXhjZWVkZWRcIl0gPSAxNTFdID0gXCJRdW90YUV4Y2VlZGVkXCI7XG4gICAgLyoqXG4gICAgICogUmV0dXJuZWQgd2hlbiB0aGUgV2lsbCBwYXlsb2FkIGluIHRoZSBDT05ORUNUIHBhY2tldCBkb2VzIG5vdCBtYXRjaCB0aGUgc3BlY2lmaWVkIHBheWxvYWQgZm9ybWF0IGluZGljYXRvci5cbiAgICAgKi9cbiAgICBDb25uZWN0UmVhc29uQ29kZVtDb25uZWN0UmVhc29uQ29kZVtcIlBheWxvYWRGb3JtYXRJbnZhbGlkXCJdID0gMTUzXSA9IFwiUGF5bG9hZEZvcm1hdEludmFsaWRcIjtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5lZCB3aGVuIHRoZSBzZXJ2ZXIgZG9lcyBub3QgcmV0YWluIG1lc3NhZ2VzIGJ1dCB0aGUgY29ubmVjdGlvbiBwYWNrZXQgb24gdGhlIGNsaWVudCBoYWQgV2lsbCByZXRhaW4gZW5hYmxlZC5cbiAgICAgKi9cbiAgICBDb25uZWN0UmVhc29uQ29kZVtDb25uZWN0UmVhc29uQ29kZVtcIlJldGFpbk5vdFN1cHBvcnRlZFwiXSA9IDE1NF0gPSBcIlJldGFpbk5vdFN1cHBvcnRlZFwiO1xuICAgIC8qKlxuICAgICAqIFJldHVybmVkIHdoZW4gdGhlIHNlcnZlciBkb2VzIG5vdCBzdXBwb3J0IHRoZSBRT1Mgc2V0dGluZyBpbiB0aGUgV2lsbCBRT1MgaW4gdGhlIGNvbm5lY3Rpb24gcGFja2V0LlxuICAgICAqL1xuICAgIENvbm5lY3RSZWFzb25Db2RlW0Nvbm5lY3RSZWFzb25Db2RlW1wiUW9zTm90U3VwcG9ydGVkXCJdID0gMTU1XSA9IFwiUW9zTm90U3VwcG9ydGVkXCI7XG4gICAgLyoqXG4gICAgICogUmV0dXJuZWQgd2hlbiB0aGUgc2VydmVyIGlzIHRlbGxpbmcgdGhlIGNsaWVudCB0byB0ZW1wb3JhcmlseSB1c2UgYW5vdGhlciBzZXJ2ZXIgaW5zdGVhZCBvZiB0aGUgb25lIHRoZXlcbiAgICAgKiBhcmUgdHJ5aW5nIHRvIGNvbm5lY3QgdG8uXG4gICAgICovXG4gICAgQ29ubmVjdFJlYXNvbkNvZGVbQ29ubmVjdFJlYXNvbkNvZGVbXCJVc2VBbm90aGVyU2VydmVyXCJdID0gMTU2XSA9IFwiVXNlQW5vdGhlclNlcnZlclwiO1xuICAgIC8qKlxuICAgICAqIFJldHVybmVkIHdoZW4gdGhlIHNlcnZlciBpcyB0ZWxsaW5nIHRoZSBjbGllbnQgdG8gcGVybWFuZW50bHkgdXNlIGFub3RoZXIgc2VydmVyIGluc3RlYWQgb2YgdGhlIG9uZSB0aGV5XG4gICAgICogYXJlIHRyeWluZyB0byBjb25uZWN0IHRvLlxuICAgICAqL1xuICAgIENvbm5lY3RSZWFzb25Db2RlW0Nvbm5lY3RSZWFzb25Db2RlW1wiU2VydmVyTW92ZWRcIl0gPSAxNTddID0gXCJTZXJ2ZXJNb3ZlZFwiO1xuICAgIC8qKlxuICAgICAqIFJldHVybmVkIHdoZW4gdGhlIHNlcnZlciBjb25uZWN0aW9uIHJhdGUgbGltaXQgaGFzIGJlZW4gZXhjZWVkZWQuXG4gICAgICovXG4gICAgQ29ubmVjdFJlYXNvbkNvZGVbQ29ubmVjdFJlYXNvbkNvZGVbXCJDb25uZWN0aW9uUmF0ZUV4Y2VlZGVkXCJdID0gMTU5XSA9IFwiQ29ubmVjdGlvblJhdGVFeGNlZWRlZFwiO1xufSkoQ29ubmVjdFJlYXNvbkNvZGUgPSBleHBvcnRzLkNvbm5lY3RSZWFzb25Db2RlIHx8IChleHBvcnRzLkNvbm5lY3RSZWFzb25Db2RlID0ge30pKTtcbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBhIHJlYXNvbiBjb2RlIHJlcHJlc2VudHMgYSBzdWNjZXNzZnVsIGNvbm5lY3Qgb3BlcmF0aW9uXG4gKlxuICogQHBhcmFtIHJlYXNvbkNvZGUgcmVhc29uIGNvZGUgdG8gY2hlY2sgc3VjY2VzcyBmb3JcbiAqL1xuZnVuY3Rpb24gaXNTdWNjZXNzZnVsQ29ubmVjdFJlYXNvbkNvZGUocmVhc29uQ29kZSkge1xuICAgIHJldHVybiByZWFzb25Db2RlIDwgMTI4O1xufVxuZXhwb3J0cy5pc1N1Y2Nlc3NmdWxDb25uZWN0UmVhc29uQ29kZSA9IGlzU3VjY2Vzc2Z1bENvbm5lY3RSZWFzb25Db2RlO1xuLyoqXG4gKiBSZWFzb24gY29kZSBpbnNpZGUgRElTQ09OTkVDVCBwYWNrZXRzLiAgSGVscHMgZGV0ZXJtaW5lIHdoeSBhIGNvbm5lY3Rpb24gd2FzIHRlcm1pbmF0ZWQuXG4gKlxuICogRW51bSB2YWx1ZXMgbWF0Y2ggW01RVFQ1IHNwZWNdKGh0dHBzOi8vZG9jcy5vYXNpcy1vcGVuLm9yZy9tcXR0L21xdHQvdjUuMC9vcy9tcXR0LXY1LjAtb3MuaHRtbCNfVG9jMzkwMTIwOCkgZW5jb2RpbmcgdmFsdWVzLlxuICovXG52YXIgRGlzY29ubmVjdFJlYXNvbkNvZGU7XG4oZnVuY3Rpb24gKERpc2Nvbm5lY3RSZWFzb25Db2RlKSB7XG4gICAgLyoqXG4gICAgICogUmV0dXJuZWQgd2hlbiB0aGUgcmVtb3RlIGVuZHBvaW50IHdpc2hlcyB0byBkaXNjb25uZWN0IG5vcm1hbGx5LiBXaWxsIG5vdCB0cmlnZ2VyIHRoZSBwdWJsaXNoIG9mIGEgV2lsbCBtZXNzYWdlIGlmIGFcbiAgICAgKiBXaWxsIG1lc3NhZ2Ugd2FzIGNvbmZpZ3VyZWQgb24gdGhlIGNvbm5lY3Rpb24uXG4gICAgICpcbiAgICAgKiBNYXkgYmUgc2VudCBieSB0aGUgY2xpZW50IG9yIHNlcnZlci5cbiAgICAgKi9cbiAgICBEaXNjb25uZWN0UmVhc29uQ29kZVtEaXNjb25uZWN0UmVhc29uQ29kZVtcIk5vcm1hbERpc2Nvbm5lY3Rpb25cIl0gPSAwXSA9IFwiTm9ybWFsRGlzY29ubmVjdGlvblwiO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhhdCB0aGUgY2xpZW50IHdhbnRzIHRvIGRpc2Nvbm5lY3QgYnV0IHJlcXVpcmVzIHRoYXQgdGhlIHNlcnZlciBwdWJsaXNoIHRoZSBXaWxsIG1lc3NhZ2UgY29uZmlndXJlZFxuICAgICAqIG9uIHRoZSBjb25uZWN0aW9uLlxuICAgICAqXG4gICAgICogTWF5IG9ubHkgYmUgc2VudCBieSB0aGUgY2xpZW50LlxuICAgICAqL1xuICAgIERpc2Nvbm5lY3RSZWFzb25Db2RlW0Rpc2Nvbm5lY3RSZWFzb25Db2RlW1wiRGlzY29ubmVjdFdpdGhXaWxsTWVzc2FnZVwiXSA9IDRdID0gXCJEaXNjb25uZWN0V2l0aFdpbGxNZXNzYWdlXCI7XG4gICAgLyoqXG4gICAgICogUmV0dXJuZWQgd2hlbiB0aGUgY29ubmVjdGlvbiB3YXMgY2xvc2VkIGJ1dCB0aGUgc2VuZGVyIGRvZXMgbm90IHdhbnQgdG8gc3BlY2lmeSBhIHJlYXNvbiBvciBub25lXG4gICAgICogb2YgdGhlIG90aGVyIHJlYXNvbiBjb2RlcyBhcHBseS5cbiAgICAgKlxuICAgICAqIE1heSBiZSBzZW50IGJ5IHRoZSBjbGllbnQgb3IgdGhlIHNlcnZlci5cbiAgICAgKi9cbiAgICBEaXNjb25uZWN0UmVhc29uQ29kZVtEaXNjb25uZWN0UmVhc29uQ29kZVtcIlVuc3BlY2lmaWVkRXJyb3JcIl0gPSAxMjhdID0gXCJVbnNwZWNpZmllZEVycm9yXCI7XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoZSByZW1vdGUgZW5kcG9pbnQgcmVjZWl2ZWQgYSBwYWNrZXQgdGhhdCBkb2VzIG5vdCBjb25mb3JtIHRvIHRoZSBNUVRUIHNwZWNpZmljYXRpb24uXG4gICAgICpcbiAgICAgKiBNYXkgYmUgc2VudCBieSB0aGUgY2xpZW50IG9yIHRoZSBzZXJ2ZXIuXG4gICAgICovXG4gICAgRGlzY29ubmVjdFJlYXNvbkNvZGVbRGlzY29ubmVjdFJlYXNvbkNvZGVbXCJNYWxmb3JtZWRQYWNrZXRcIl0gPSAxMjldID0gXCJNYWxmb3JtZWRQYWNrZXRcIjtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5lZCB3aGVuIGFuIHVuZXhwZWN0ZWQgb3Igb3V0LW9mLW9yZGVyIHBhY2tldCB3YXMgcmVjZWl2ZWQgYnkgdGhlIHJlbW90ZSBlbmRwb2ludC5cbiAgICAgKlxuICAgICAqIE1heSBiZSBzZW50IGJ5IHRoZSBjbGllbnQgb3IgdGhlIHNlcnZlci5cbiAgICAgKi9cbiAgICBEaXNjb25uZWN0UmVhc29uQ29kZVtEaXNjb25uZWN0UmVhc29uQ29kZVtcIlByb3RvY29sRXJyb3JcIl0gPSAxMzBdID0gXCJQcm90b2NvbEVycm9yXCI7XG4gICAgLyoqXG4gICAgICogUmV0dXJuZWQgd2hlbiBhIHZhbGlkIHBhY2tldCB3YXMgcmVjZWl2ZWQgYnkgdGhlIHJlbW90ZSBlbmRwb2ludCwgYnV0IGNvdWxkIG5vdCBiZSBwcm9jZXNzZWQgYnkgdGhlIGN1cnJlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICpcbiAgICAgKiBNYXkgYmUgc2VudCBieSB0aGUgY2xpZW50IG9yIHRoZSBzZXJ2ZXIuXG4gICAgICovXG4gICAgRGlzY29ubmVjdFJlYXNvbkNvZGVbRGlzY29ubmVjdFJlYXNvbkNvZGVbXCJJbXBsZW1lbnRhdGlvblNwZWNpZmljRXJyb3JcIl0gPSAxMzFdID0gXCJJbXBsZW1lbnRhdGlvblNwZWNpZmljRXJyb3JcIjtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5lZCB3aGVuIHRoZSByZW1vdGUgZW5kcG9pbnQgcmVjZWl2ZWQgYSBwYWNrZXQgdGhhdCByZXByZXNlbnRlZCBhbiBvcGVyYXRpb24gdGhhdCB3YXMgbm90IGF1dGhvcml6ZWQgd2l0aGluXG4gICAgICogdGhlIGN1cnJlbnQgY29ubmVjdGlvbi5cbiAgICAgKlxuICAgICAqIE1heSBvbmx5IGJlIHNlbnQgYnkgdGhlIHNlcnZlci5cbiAgICAgKi9cbiAgICBEaXNjb25uZWN0UmVhc29uQ29kZVtEaXNjb25uZWN0UmVhc29uQ29kZVtcIk5vdEF1dGhvcml6ZWRcIl0gPSAxMzVdID0gXCJOb3RBdXRob3JpemVkXCI7XG4gICAgLyoqXG4gICAgICogUmV0dXJuZWQgd2hlbiB0aGUgc2VydmVyIGlzIGJ1c3kgYW5kIGNhbm5vdCBjb250aW51ZSBwcm9jZXNzaW5nIHBhY2tldHMgZnJvbSB0aGUgY2xpZW50LlxuICAgICAqXG4gICAgICogTWF5IG9ubHkgYmUgc2VudCBieSB0aGUgc2VydmVyLlxuICAgICAqL1xuICAgIERpc2Nvbm5lY3RSZWFzb25Db2RlW0Rpc2Nvbm5lY3RSZWFzb25Db2RlW1wiU2VydmVyQnVzeVwiXSA9IDEzN10gPSBcIlNlcnZlckJ1c3lcIjtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5lZCB3aGVuIHRoZSBzZXJ2ZXIgaXMgc2h1dHRpbmcgZG93bi5cbiAgICAgKlxuICAgICAqIE1heSBvbmx5IGJlIHNlbnQgYnkgdGhlIHNlcnZlci5cbiAgICAgKi9cbiAgICBEaXNjb25uZWN0UmVhc29uQ29kZVtEaXNjb25uZWN0UmVhc29uQ29kZVtcIlNlcnZlclNodXR0aW5nRG93blwiXSA9IDEzOV0gPSBcIlNlcnZlclNodXR0aW5nRG93blwiO1xuICAgIC8qKlxuICAgICAqIFJldHVybmVkIHdoZW4gdGhlIHNlcnZlciBjbG9zZXMgdGhlIGNvbm5lY3Rpb24gYmVjYXVzZSBubyBwYWNrZXQgZnJvbSB0aGUgY2xpZW50IGhhcyBiZWVuIHJlY2VpdmVkIGluXG4gICAgICogMS41IHRpbWVzIHRoZSBLZWVwQWxpdmUgdGltZSBzZXQgd2hlbiB0aGUgY29ubmVjdGlvbiB3YXMgZXN0YWJsaXNoZWQuXG4gICAgICpcbiAgICAgKiBNYXkgb25seSBiZSBzZW50IGJ5IHRoZSBzZXJ2ZXIuXG4gICAgICovXG4gICAgRGlzY29ubmVjdFJlYXNvbkNvZGVbRGlzY29ubmVjdFJlYXNvbkNvZGVbXCJLZWVwQWxpdmVUaW1lb3V0XCJdID0gMTQxXSA9IFwiS2VlcEFsaXZlVGltZW91dFwiO1xuICAgIC8qKlxuICAgICAqIFJldHVybmVkIHdoZW4gdGhlIHNlcnZlciBoYXMgZXN0YWJsaXNoZWQgYW5vdGhlciBjb25uZWN0aW9uIHdpdGggdGhlIHNhbWUgY2xpZW50IElEIGFzIGEgY2xpZW50J3MgY3VycmVudFxuICAgICAqIGNvbm5lY3Rpb24sIGNhdXNpbmcgdGhlIGN1cnJlbnQgY2xpZW50IHRvIGJlY29tZSBkaXNjb25uZWN0ZWQuXG4gICAgICpcbiAgICAgKiBNYXkgb25seSBiZSBzZW50IGJ5IHRoZSBzZXJ2ZXIuXG4gICAgICovXG4gICAgRGlzY29ubmVjdFJlYXNvbkNvZGVbRGlzY29ubmVjdFJlYXNvbkNvZGVbXCJTZXNzaW9uVGFrZW5PdmVyXCJdID0gMTQyXSA9IFwiU2Vzc2lvblRha2VuT3ZlclwiO1xuICAgIC8qKlxuICAgICAqIFJldHVybmVkIHdoZW4gdGhlIHRvcGljIGZpbHRlciBuYW1lIGlzIGNvcnJlY3RseSBmb3JtZWQgYnV0IG5vdCBhY2NlcHRlZCBieSB0aGUgc2VydmVyLlxuICAgICAqXG4gICAgICogTWF5IG9ubHkgYmUgc2VudCBieSB0aGUgc2VydmVyLlxuICAgICAqL1xuICAgIERpc2Nvbm5lY3RSZWFzb25Db2RlW0Rpc2Nvbm5lY3RSZWFzb25Db2RlW1wiVG9waWNGaWx0ZXJJbnZhbGlkXCJdID0gMTQzXSA9IFwiVG9waWNGaWx0ZXJJbnZhbGlkXCI7XG4gICAgLyoqXG4gICAgICogUmV0dXJuZWQgd2hlbiB0b3BpYyBuYW1lIGlzIGNvcnJlY3RseSBmb3JtZWQsIGJ1dCBpcyBub3QgYWNjZXB0ZWQuXG4gICAgICpcbiAgICAgKiBNYXkgYmUgc2VudCBieSB0aGUgY2xpZW50IG9yIHRoZSBzZXJ2ZXIuXG4gICAgICovXG4gICAgRGlzY29ubmVjdFJlYXNvbkNvZGVbRGlzY29ubmVjdFJlYXNvbkNvZGVbXCJUb3BpY05hbWVJbnZhbGlkXCJdID0gMTQ0XSA9IFwiVG9waWNOYW1lSW52YWxpZFwiO1xuICAgIC8qKlxuICAgICAqIFJldHVybmVkIHdoZW4gdGhlIHJlbW90ZSBlbmRwb2ludCByZWFjaGVkIGEgc3RhdGUgd2hlcmUgdGhlcmUgd2VyZSBtb3JlIGluLXByb2dyZXNzIFFvUzErIHB1Ymxpc2hlcyB0aGVuIHRoZVxuICAgICAqIGxpbWl0IGl0IGVzdGFibGlzaGVkIGZvciBpdHNlbGYgd2hlbiB0aGUgY29ubmVjdGlvbiB3YXMgb3BlbmVkLlxuICAgICAqXG4gICAgICogTWF5IGJlIHNlbnQgYnkgdGhlIGNsaWVudCBvciB0aGUgc2VydmVyLlxuICAgICAqL1xuICAgIERpc2Nvbm5lY3RSZWFzb25Db2RlW0Rpc2Nvbm5lY3RSZWFzb25Db2RlW1wiUmVjZWl2ZU1heGltdW1FeGNlZWRlZFwiXSA9IDE0N10gPSBcIlJlY2VpdmVNYXhpbXVtRXhjZWVkZWRcIjtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5lZCB3aGVuIHRoZSByZW1vdGUgZW5kcG9pbnQgcmVjZWl2ZXMgYSBQVUJMSVNIIHBhY2tldCB0aGF0IGNvbnRhaW5lZCBhIHRvcGljIGFsaWFzIGdyZWF0ZXIgdGhhbiB0aGVcbiAgICAgKiBtYXhpbXVtIHRvcGljIGFsaWFzIGxpbWl0IHRoYXQgaXQgZXN0YWJsaXNoZWQgZm9yIGl0c2VsZiB3aGVuIHRoZSBjb25uZWN0aW9uIHdhcyBvcGVuZWQuXG4gICAgICpcbiAgICAgKiBNYXkgYmUgc2VudCBieSB0aGUgY2xpZW50IG9yIHRoZSBzZXJ2ZXIuXG4gICAgICovXG4gICAgRGlzY29ubmVjdFJlYXNvbkNvZGVbRGlzY29ubmVjdFJlYXNvbkNvZGVbXCJUb3BpY0FsaWFzSW52YWxpZFwiXSA9IDE0OF0gPSBcIlRvcGljQWxpYXNJbnZhbGlkXCI7XG4gICAgLyoqXG4gICAgICogUmV0dXJuZWQgd2hlbiB0aGUgcmVtb3RlIGVuZHBvaW50IHJlY2VpdmVkIGEgcGFja2V0IHdob3NlIHNpemUgd2FzIGdyZWF0ZXIgdGhhbiB0aGUgbWF4aW11bSBwYWNrZXQgc2l6ZSBsaW1pdFxuICAgICAqIGl0IGVzdGFibGlzaGVkIGZvciBpdHNlbGYgd2hlbiB0aGUgY29ubmVjdGlvbiB3YXMgb3BlbmVkLlxuICAgICAqXG4gICAgICogTWF5IGJlIHNlbnQgYnkgdGhlIGNsaWVudCBvciB0aGUgc2VydmVyLlxuICAgICAqL1xuICAgIERpc2Nvbm5lY3RSZWFzb25Db2RlW0Rpc2Nvbm5lY3RSZWFzb25Db2RlW1wiUGFja2V0VG9vTGFyZ2VcIl0gPSAxNDldID0gXCJQYWNrZXRUb29MYXJnZVwiO1xuICAgIC8qKlxuICAgICAqIFJldHVybmVkIHdoZW4gdGhlIHJlbW90ZSBlbmRwb2ludCdzIGluY29taW5nIGRhdGEgcmF0ZSB3YXMgdG9vIGhpZ2guXG4gICAgICpcbiAgICAgKiBNYXkgYmUgc2VudCBieSB0aGUgY2xpZW50IG9yIHRoZSBzZXJ2ZXIuXG4gICAgICovXG4gICAgRGlzY29ubmVjdFJlYXNvbkNvZGVbRGlzY29ubmVjdFJlYXNvbkNvZGVbXCJNZXNzYWdlUmF0ZVRvb0hpZ2hcIl0gPSAxNTBdID0gXCJNZXNzYWdlUmF0ZVRvb0hpZ2hcIjtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5lZCB3aGVuIGFuIGludGVybmFsIHF1b3RhIG9mIHRoZSByZW1vdGUgZW5kcG9pbnQgd2FzIGV4Y2VlZGVkLlxuICAgICAqXG4gICAgICogTWF5IGJlIHNlbnQgYnkgdGhlIGNsaWVudCBvciB0aGUgc2VydmVyLlxuICAgICAqL1xuICAgIERpc2Nvbm5lY3RSZWFzb25Db2RlW0Rpc2Nvbm5lY3RSZWFzb25Db2RlW1wiUXVvdGFFeGNlZWRlZFwiXSA9IDE1MV0gPSBcIlF1b3RhRXhjZWVkZWRcIjtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5lZCB3aGVuIHRoZSBjb25uZWN0aW9uIHdhcyBjbG9zZWQgZHVlIHRvIGFuIGFkbWluaXN0cmF0aXZlIGFjdGlvbi5cbiAgICAgKlxuICAgICAqIE1heSBiZSBzZW50IGJ5IHRoZSBjbGllbnQgb3IgdGhlIHNlcnZlci5cbiAgICAgKi9cbiAgICBEaXNjb25uZWN0UmVhc29uQ29kZVtEaXNjb25uZWN0UmVhc29uQ29kZVtcIkFkbWluaXN0cmF0aXZlQWN0aW9uXCJdID0gMTUyXSA9IFwiQWRtaW5pc3RyYXRpdmVBY3Rpb25cIjtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5lZCB3aGVuIHRoZSByZW1vdGUgZW5kcG9pbnQgcmVjZWl2ZWQgYSBwYWNrZXQgd2hlcmUgcGF5bG9hZCBmb3JtYXQgZGlkIG5vdCBtYXRjaCB0aGUgZm9ybWF0IHNwZWNpZmllZFxuICAgICAqIGJ5IHRoZSBwYXlsb2FkIGZvcm1hdCBpbmRpY2F0b3IuXG4gICAgICpcbiAgICAgKiBNYXkgYmUgc2VudCBieSB0aGUgY2xpZW50IG9yIHRoZSBzZXJ2ZXIuXG4gICAgICovXG4gICAgRGlzY29ubmVjdFJlYXNvbkNvZGVbRGlzY29ubmVjdFJlYXNvbkNvZGVbXCJQYXlsb2FkRm9ybWF0SW52YWxpZFwiXSA9IDE1M10gPSBcIlBheWxvYWRGb3JtYXRJbnZhbGlkXCI7XG4gICAgLyoqXG4gICAgICogUmV0dXJuZWQgd2hlbiB0aGUgc2VydmVyIGRvZXMgbm90IHN1cHBvcnQgcmV0YWluZWQgbWVzc2FnZXMuXG4gICAgICpcbiAgICAgKiBNYXkgb25seSBiZSBzZW50IGJ5IHRoZSBzZXJ2ZXIuXG4gICAgICovXG4gICAgRGlzY29ubmVjdFJlYXNvbkNvZGVbRGlzY29ubmVjdFJlYXNvbkNvZGVbXCJSZXRhaW5Ob3RTdXBwb3J0ZWRcIl0gPSAxNTRdID0gXCJSZXRhaW5Ob3RTdXBwb3J0ZWRcIjtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5lZCB3aGVuIHRoZSBjbGllbnQgc2VuZHMgYSBRT1MgdGhhdCBpcyBncmVhdGVyIHRoYW4gdGhlIG1heGltdW0gUU9TIGVzdGFibGlzaGVkIHdoZW4gdGhlIGNvbm5lY3Rpb24gd2FzXG4gICAgICogb3BlbmVkLlxuICAgICAqXG4gICAgICogTWF5IG9ubHkgYmUgc2VudCBieSB0aGUgc2VydmVyLlxuICAgICAqL1xuICAgIERpc2Nvbm5lY3RSZWFzb25Db2RlW0Rpc2Nvbm5lY3RSZWFzb25Db2RlW1wiUW9zTm90U3VwcG9ydGVkXCJdID0gMTU1XSA9IFwiUW9zTm90U3VwcG9ydGVkXCI7XG4gICAgLyoqXG4gICAgICogUmV0dXJuZWQgYnkgdGhlIHNlcnZlciB0byB0ZWxsIHRoZSBjbGllbnQgdG8gdGVtcG9yYXJpbHkgdXNlIGEgZGlmZmVyZW50IHNlcnZlci5cbiAgICAgKlxuICAgICAqIE1heSBvbmx5IGJlIHNlbnQgYnkgdGhlIHNlcnZlci5cbiAgICAgKi9cbiAgICBEaXNjb25uZWN0UmVhc29uQ29kZVtEaXNjb25uZWN0UmVhc29uQ29kZVtcIlVzZUFub3RoZXJTZXJ2ZXJcIl0gPSAxNTZdID0gXCJVc2VBbm90aGVyU2VydmVyXCI7XG4gICAgLyoqXG4gICAgICogUmV0dXJuZWQgYnkgdGhlIHNlcnZlciB0byB0ZWxsIHRoZSBjbGllbnQgdG8gcGVybWFuZW50bHkgdXNlIGEgZGlmZmVyZW50IHNlcnZlci5cbiAgICAgKlxuICAgICAqIE1heSBvbmx5IGJlIHNlbnQgYnkgdGhlIHNlcnZlci5cbiAgICAgKi9cbiAgICBEaXNjb25uZWN0UmVhc29uQ29kZVtEaXNjb25uZWN0UmVhc29uQ29kZVtcIlNlcnZlck1vdmVkXCJdID0gMTU3XSA9IFwiU2VydmVyTW92ZWRcIjtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5lZCBieSB0aGUgc2VydmVyIHRvIHRlbGwgdGhlIGNsaWVudCB0aGF0IHNoYXJlZCBzdWJzY3JpcHRpb25zIGFyZSBub3Qgc3VwcG9ydGVkIG9uIHRoZSBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBNYXkgb25seSBiZSBzZW50IGJ5IHRoZSBzZXJ2ZXIuXG4gICAgICovXG4gICAgRGlzY29ubmVjdFJlYXNvbkNvZGVbRGlzY29ubmVjdFJlYXNvbkNvZGVbXCJTaGFyZWRTdWJzY3JpcHRpb25zTm90U3VwcG9ydGVkXCJdID0gMTU4XSA9IFwiU2hhcmVkU3Vic2NyaXB0aW9uc05vdFN1cHBvcnRlZFwiO1xuICAgIC8qKlxuICAgICAqIFJldHVybmVkIHdoZW4gdGhlIHNlcnZlciBkaXNjb25uZWN0cyB0aGUgY2xpZW50IGR1ZSB0byB0aGUgY29ubmVjdGlvbiByYXRlIGJlaW5nIHRvbyBoaWdoLlxuICAgICAqXG4gICAgICogTWF5IG9ubHkgYmUgc2VudCBieSB0aGUgc2VydmVyLlxuICAgICAqL1xuICAgIERpc2Nvbm5lY3RSZWFzb25Db2RlW0Rpc2Nvbm5lY3RSZWFzb25Db2RlW1wiQ29ubmVjdGlvblJhdGVFeGNlZWRlZFwiXSA9IDE1OV0gPSBcIkNvbm5lY3Rpb25SYXRlRXhjZWVkZWRcIjtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5lZCBieSB0aGUgc2VydmVyIHdoZW4gdGhlIG1heGltdW0gY29ubmVjdGlvbiB0aW1lIGF1dGhvcml6ZWQgZm9yIHRoZSBjb25uZWN0aW9uIHdhcyBleGNlZWRlZC5cbiAgICAgKlxuICAgICAqIE1heSBvbmx5IGJlIHNlbnQgYnkgdGhlIHNlcnZlci5cbiAgICAgKi9cbiAgICBEaXNjb25uZWN0UmVhc29uQ29kZVtEaXNjb25uZWN0UmVhc29uQ29kZVtcIk1heGltdW1Db25uZWN0VGltZVwiXSA9IDE2MF0gPSBcIk1heGltdW1Db25uZWN0VGltZVwiO1xuICAgIC8qKlxuICAgICAqIFJldHVybmVkIGJ5IHRoZSBzZXJ2ZXIgd2hlbiBpdCByZWNlaXZlZCBhIFNVQlNDUklCRSBwYWNrZXQgd2l0aCBhIHN1YnNjcmlwdGlvbiBpZGVudGlmaWVyLCBidXQgdGhlIHNlcnZlciBkb2VzXG4gICAgICogbm90IHN1cHBvcnQgc3Vic2NyaXB0aW9uIGlkZW50aWZpZXJzLlxuICAgICAqXG4gICAgICogTWF5IG9ubHkgYmUgc2VudCBieSB0aGUgc2VydmVyLlxuICAgICAqL1xuICAgIERpc2Nvbm5lY3RSZWFzb25Db2RlW0Rpc2Nvbm5lY3RSZWFzb25Db2RlW1wiU3Vic2NyaXB0aW9uSWRlbnRpZmllcnNOb3RTdXBwb3J0ZWRcIl0gPSAxNjFdID0gXCJTdWJzY3JpcHRpb25JZGVudGlmaWVyc05vdFN1cHBvcnRlZFwiO1xuICAgIC8qKlxuICAgICAqIFJldHVybmVkIGJ5IHRoZSBzZXJ2ZXIgd2hlbiBpdCByZWNlaXZlZCBhIFNVQlNDUklCRSBwYWNrZXQgd2l0aCBhIHdpbGRjYXJkIHRvcGljIGZpbHRlciwgYnV0IHRoZSBzZXJ2ZXIgZG9lc1xuICAgICAqIG5vdCBzdXBwb3J0IHdpbGRjYXJkIHRvcGljIGZpbHRlcnMuXG4gICAgICpcbiAgICAgKiBNYXkgb25seSBiZSBzZW50IGJ5IHRoZSBzZXJ2ZXIuXG4gICAgICovXG4gICAgRGlzY29ubmVjdFJlYXNvbkNvZGVbRGlzY29ubmVjdFJlYXNvbkNvZGVbXCJXaWxkY2FyZFN1YnNjcmlwdGlvbnNOb3RTdXBwb3J0ZWRcIl0gPSAxNjJdID0gXCJXaWxkY2FyZFN1YnNjcmlwdGlvbnNOb3RTdXBwb3J0ZWRcIjtcbn0pKERpc2Nvbm5lY3RSZWFzb25Db2RlID0gZXhwb3J0cy5EaXNjb25uZWN0UmVhc29uQ29kZSB8fCAoZXhwb3J0cy5EaXNjb25uZWN0UmVhc29uQ29kZSA9IHt9KSk7XG4vKipcbiAqIERldGVybWluZXMgaWYgYSByZWFzb24gY29kZSByZXByZXNlbnRzIGEgc3VjY2Vzc2Z1bCBkaXNjb25uZWN0IG9wZXJhdGlvblxuICpcbiAqIEBwYXJhbSByZWFzb25Db2RlIHJlYXNvbiBjb2RlIHRvIGNoZWNrIHN1Y2Nlc3MgZm9yXG4gKi9cbmZ1bmN0aW9uIGlzU3VjY2Vzc2Z1bERpc2Nvbm5lY3RSZWFzb25Db2RlKHJlYXNvbkNvZGUpIHtcbiAgICByZXR1cm4gcmVhc29uQ29kZSA8IDEyODtcbn1cbmV4cG9ydHMuaXNTdWNjZXNzZnVsRGlzY29ubmVjdFJlYXNvbkNvZGUgPSBpc1N1Y2Nlc3NmdWxEaXNjb25uZWN0UmVhc29uQ29kZTtcbi8qKlxuICogUmVhc29uIGNvZGVzIGluc2lkZSBTVUJBQ0sgcGFja2V0IHBheWxvYWRzIHRoYXQgc3BlY2lmeSB0aGUgcmVzdWx0cyBmb3IgZWFjaCBzdWJzY3JpcHRpb24gaW4gdGhlIGFzc29jaWF0ZWRcbiAqIFNVQlNDUklCRSBwYWNrZXQuXG4gKlxuICogRW51bSB2YWx1ZXMgbWF0Y2ggW01RVFQ1IHNwZWNdKGh0dHBzOi8vZG9jcy5vYXNpcy1vcGVuLm9yZy9tcXR0L21xdHQvdjUuMC9vcy9tcXR0LXY1LjAtb3MuaHRtbCNfVG9jMzkwMTE3OCkgZW5jb2RpbmcgdmFsdWVzLlxuICovXG52YXIgU3ViYWNrUmVhc29uQ29kZTtcbihmdW5jdGlvbiAoU3ViYWNrUmVhc29uQ29kZSkge1xuICAgIC8qKlxuICAgICAqIFJldHVybmVkIHdoZW4gdGhlIHN1YnNjcmlwdGlvbiB3YXMgYWNjZXB0ZWQgYW5kIHRoZSBtYXhpbXVtIFFPUyBzZW50IHdpbGwgYmUgUU9TIDAuXG4gICAgICovXG4gICAgU3ViYWNrUmVhc29uQ29kZVtTdWJhY2tSZWFzb25Db2RlW1wiR3JhbnRlZFFvUzBcIl0gPSAwXSA9IFwiR3JhbnRlZFFvUzBcIjtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5lZCB3aGVuIHRoZSBzdWJzY3JpcHRpb24gd2FzIGFjY2VwdGVkIGFuZCB0aGUgbWF4aW11bSBRT1Mgc2VudCB3aWxsIGJlIFFPUyAxLlxuICAgICAqL1xuICAgIFN1YmFja1JlYXNvbkNvZGVbU3ViYWNrUmVhc29uQ29kZVtcIkdyYW50ZWRRb1MxXCJdID0gMV0gPSBcIkdyYW50ZWRRb1MxXCI7XG4gICAgLyoqXG4gICAgICogUmV0dXJuZWQgd2hlbiB0aGUgc3Vic2NyaXB0aW9uIHdhcyBhY2NlcHRlZCBhbmQgdGhlIG1heGltdW0gUU9TIHNlbnQgd2lsbCBiZSBRT1MgMi5cbiAgICAgKi9cbiAgICBTdWJhY2tSZWFzb25Db2RlW1N1YmFja1JlYXNvbkNvZGVbXCJHcmFudGVkUW9TMlwiXSA9IDJdID0gXCJHcmFudGVkUW9TMlwiO1xuICAgIC8qKlxuICAgICAqIFJldHVybmVkIHdoZW4gdGhlIGNvbm5lY3Rpb24gd2FzIGNsb3NlZCBidXQgdGhlIHNlbmRlciBkb2VzIG5vdCB3YW50IHRvIHNwZWNpZnkgYSByZWFzb24gb3Igbm9uZVxuICAgICAqIG9mIHRoZSBvdGhlciByZWFzb24gY29kZXMgYXBwbHkuXG4gICAgICovXG4gICAgU3ViYWNrUmVhc29uQ29kZVtTdWJhY2tSZWFzb25Db2RlW1wiVW5zcGVjaWZpZWRFcnJvclwiXSA9IDEyOF0gPSBcIlVuc3BlY2lmaWVkRXJyb3JcIjtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5lZCB3aGVuIHRoZSBzdWJzY3JpcHRpb24gd2FzIHZhbGlkIGJ1dCB0aGUgc2VydmVyIGRpZCBub3QgYWNjZXB0IGl0LlxuICAgICAqL1xuICAgIFN1YmFja1JlYXNvbkNvZGVbU3ViYWNrUmVhc29uQ29kZVtcIkltcGxlbWVudGF0aW9uU3BlY2lmaWNFcnJvclwiXSA9IDEzMV0gPSBcIkltcGxlbWVudGF0aW9uU3BlY2lmaWNFcnJvclwiO1xuICAgIC8qKlxuICAgICAqIFJldHVybmVkIHdoZW4gdGhlIGNsaWVudCB3YXMgbm90IGF1dGhvcml6ZWQgdG8gbWFrZSB0aGUgc3Vic2NyaXB0aW9uIG9uIHRoZSBzZXJ2ZXIuXG4gICAgICovXG4gICAgU3ViYWNrUmVhc29uQ29kZVtTdWJhY2tSZWFzb25Db2RlW1wiTm90QXV0aG9yaXplZFwiXSA9IDEzNV0gPSBcIk5vdEF1dGhvcml6ZWRcIjtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5lZCB3aGVuIHRoZSBzdWJzY3JpcHRpb24gdG9waWMgZmlsdGVyIHdhcyBjb3JyZWN0bHkgZm9ybWVkIGJ1dCBub3QgYWxsb3dlZCBmb3IgdGhlIGNsaWVudC5cbiAgICAgKi9cbiAgICBTdWJhY2tSZWFzb25Db2RlW1N1YmFja1JlYXNvbkNvZGVbXCJUb3BpY0ZpbHRlckludmFsaWRcIl0gPSAxNDNdID0gXCJUb3BpY0ZpbHRlckludmFsaWRcIjtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5lZCB3aGVuIHRoZSBwYWNrZXQgaWRlbnRpZmllciB3YXMgYWxyZWFkeSBpbiB1c2Ugb24gdGhlIHNlcnZlci5cbiAgICAgKi9cbiAgICBTdWJhY2tSZWFzb25Db2RlW1N1YmFja1JlYXNvbkNvZGVbXCJQYWNrZXRJZGVudGlmaWVySW5Vc2VcIl0gPSAxNDVdID0gXCJQYWNrZXRJZGVudGlmaWVySW5Vc2VcIjtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5lZCB3aGVuIGEgc3Vic2NyaWJlLXJlbGF0ZWQgcXVvdGEgc2V0IG9uIHRoZSBzZXJ2ZXIgd2FzIGV4Y2VlZGVkLlxuICAgICAqL1xuICAgIFN1YmFja1JlYXNvbkNvZGVbU3ViYWNrUmVhc29uQ29kZVtcIlF1b3RhRXhjZWVkZWRcIl0gPSAxNTFdID0gXCJRdW90YUV4Y2VlZGVkXCI7XG4gICAgLyoqXG4gICAgICogUmV0dXJuZWQgd2hlbiB0aGUgc3Vic2NyaXB0aW9uJ3MgdG9waWMgZmlsdGVyIHdhcyBhIHNoYXJlZCBzdWJzY3JpcHRpb24gYW5kIHRoZSBzZXJ2ZXIgZG9lcyBub3Qgc3VwcG9ydFxuICAgICAqIHNoYXJlZCBzdWJzY3JpcHRpb25zLlxuICAgICAqL1xuICAgIFN1YmFja1JlYXNvbkNvZGVbU3ViYWNrUmVhc29uQ29kZVtcIlNoYXJlZFN1YnNjcmlwdGlvbnNOb3RTdXBwb3J0ZWRcIl0gPSAxNThdID0gXCJTaGFyZWRTdWJzY3JpcHRpb25zTm90U3VwcG9ydGVkXCI7XG4gICAgLyoqXG4gICAgICogUmV0dXJuZWQgd2hlbiB0aGUgU1VCU0NSSUJFIHBhY2tldCBjb250YWluZWQgYSBzdWJzY3JpcHRpb24gaWRlbnRpZmllciBhbmQgdGhlIHNlcnZlciBkb2VzIG5vdCBzdXBwb3J0XG4gICAgICogc3Vic2NyaXB0aW9uIGlkZW50aWZpZXJzLlxuICAgICAqL1xuICAgIFN1YmFja1JlYXNvbkNvZGVbU3ViYWNrUmVhc29uQ29kZVtcIlN1YnNjcmlwdGlvbklkZW50aWZpZXJzTm90U3VwcG9ydGVkXCJdID0gMTYxXSA9IFwiU3Vic2NyaXB0aW9uSWRlbnRpZmllcnNOb3RTdXBwb3J0ZWRcIjtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5lZCB3aGVuIHRoZSBzdWJzY3JpcHRpb24ncyB0b3BpYyBmaWx0ZXIgY29udGFpbnMgYSB3aWxkY2FyZCBidXQgdGhlIHNlcnZlciBkb2VzIG5vdCBzdXBwb3J0XG4gICAgICogd2lsZGNhcmQgc3Vic2NyaXB0aW9ucy5cbiAgICAgKi9cbiAgICBTdWJhY2tSZWFzb25Db2RlW1N1YmFja1JlYXNvbkNvZGVbXCJXaWxkY2FyZFN1YnNjcmlwdGlvbnNOb3RTdXBwb3J0ZWRcIl0gPSAxNjJdID0gXCJXaWxkY2FyZFN1YnNjcmlwdGlvbnNOb3RTdXBwb3J0ZWRcIjtcbn0pKFN1YmFja1JlYXNvbkNvZGUgPSBleHBvcnRzLlN1YmFja1JlYXNvbkNvZGUgfHwgKGV4cG9ydHMuU3ViYWNrUmVhc29uQ29kZSA9IHt9KSk7XG4vKipcbiAqIERldGVybWluZXMgaWYgYSByZWFzb24gY29kZSByZXByZXNlbnRzIGEgc3VjY2Vzc2Z1bCBzdWJzY3JpYmUgb3BlcmF0aW9uXG4gKlxuICogQHBhcmFtIHJlYXNvbkNvZGUgcmVhc29uIGNvZGUgdG8gY2hlY2sgc3VjY2VzcyBmb3JcbiAqL1xuZnVuY3Rpb24gaXNTdWNjZXNzZnVsU3ViYWNrUmVhc29uQ29kZShyZWFzb25Db2RlKSB7XG4gICAgcmV0dXJuIHJlYXNvbkNvZGUgPCAxMjg7XG59XG5leHBvcnRzLmlzU3VjY2Vzc2Z1bFN1YmFja1JlYXNvbkNvZGUgPSBpc1N1Y2Nlc3NmdWxTdWJhY2tSZWFzb25Db2RlO1xuLyoqXG4gKiBSZWFzb24gY29kZXMgaW5zaWRlIFVOU1VCQUNLIHBhY2tldCBwYXlsb2FkcyB0aGF0IHNwZWNpZnkgdGhlIHJlc3VsdHMgZm9yIGVhY2ggdG9waWMgZmlsdGVyIGluIHRoZSBhc3NvY2lhdGVkXG4gKiBVTlNVQlNDUklCRSBwYWNrZXQuXG4gKlxuICogRW51bSB2YWx1ZXMgbWF0Y2ggW01RVFQ1IHNwZWNdKGh0dHBzOi8vZG9jcy5vYXNpcy1vcGVuLm9yZy9tcXR0L21xdHQvdjUuMC9vcy9tcXR0LXY1LjAtb3MuaHRtbCNfVG9jMzkwMTE5NCkgZW5jb2RpbmcgdmFsdWVzLlxuICovXG52YXIgVW5zdWJhY2tSZWFzb25Db2RlO1xuKGZ1bmN0aW9uIChVbnN1YmFja1JlYXNvbkNvZGUpIHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5lZCB3aGVuIHRoZSB1bnN1YnNjcmliZSB3YXMgc3VjY2Vzc2Z1bCBhbmQgdGhlIGNsaWVudCBpcyBubyBsb25nZXIgc3Vic2NyaWJlZCB0byB0aGUgdG9waWMgZmlsdGVyIG9uIHRoZSBzZXJ2ZXIuXG4gICAgICovXG4gICAgVW5zdWJhY2tSZWFzb25Db2RlW1Vuc3ViYWNrUmVhc29uQ29kZVtcIlN1Y2Nlc3NcIl0gPSAwXSA9IFwiU3VjY2Vzc1wiO1xuICAgIC8qKlxuICAgICAqIFJldHVybmVkIHdoZW4gdGhlIHRvcGljIGZpbHRlciBkaWQgbm90IG1hdGNoIG9uZSBvZiB0aGUgY2xpZW50J3MgZXhpc3Rpbmcgc3Vic2NyaXB0aW9ucyBvbiB0aGUgc2VydmVyLlxuICAgICAqL1xuICAgIFVuc3ViYWNrUmVhc29uQ29kZVtVbnN1YmFja1JlYXNvbkNvZGVbXCJOb1N1YnNjcmlwdGlvbkV4aXN0ZWRcIl0gPSAxN10gPSBcIk5vU3Vic2NyaXB0aW9uRXhpc3RlZFwiO1xuICAgIC8qKlxuICAgICAqIFJldHVybmVkIHdoZW4gdGhlIHVuc3Vic2NyaWJlIG9mIHRoZSB0b3BpYyBmaWx0ZXIgd2FzIG5vdCBhY2NlcHRlZCBhbmQgdGhlIHNlcnZlciBkb2VzIG5vdCB3YW50IHRvIHNwZWNpZnkgYVxuICAgICAqIHJlYXNvbiBvciBub25lIG9mIHRoZSBvdGhlciByZWFzb24gY29kZXMgYXBwbHkuXG4gICAgICovXG4gICAgVW5zdWJhY2tSZWFzb25Db2RlW1Vuc3ViYWNrUmVhc29uQ29kZVtcIlVuc3BlY2lmaWVkRXJyb3JcIl0gPSAxMjhdID0gXCJVbnNwZWNpZmllZEVycm9yXCI7XG4gICAgLyoqXG4gICAgICogUmV0dXJuZWQgd2hlbiB0aGUgdG9waWMgZmlsdGVyIHdhcyB2YWxpZCBidXQgdGhlIHNlcnZlciBkb2VzIG5vdCBhY2NlcHQgYW4gdW5zdWJzY3JpYmUgZm9yIGl0LlxuICAgICAqL1xuICAgIFVuc3ViYWNrUmVhc29uQ29kZVtVbnN1YmFja1JlYXNvbkNvZGVbXCJJbXBsZW1lbnRhdGlvblNwZWNpZmljRXJyb3JcIl0gPSAxMzFdID0gXCJJbXBsZW1lbnRhdGlvblNwZWNpZmljRXJyb3JcIjtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5lZCB3aGVuIHRoZSBjbGllbnQgd2FzIG5vdCBhdXRob3JpemVkIHRvIHVuc3Vic2NyaWJlIGZyb20gdGhhdCB0b3BpYyBmaWx0ZXIgb24gdGhlIHNlcnZlci5cbiAgICAgKi9cbiAgICBVbnN1YmFja1JlYXNvbkNvZGVbVW5zdWJhY2tSZWFzb25Db2RlW1wiTm90QXV0aG9yaXplZFwiXSA9IDEzNV0gPSBcIk5vdEF1dGhvcml6ZWRcIjtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5lZCB3aGVuIHRoZSB0b3BpYyBmaWx0ZXIgd2FzIGNvcnJlY3RseSBmb3JtZWQgYnV0IGlzIG5vdCBhbGxvd2VkIGZvciB0aGUgY2xpZW50IG9uIHRoZSBzZXJ2ZXIuXG4gICAgICovXG4gICAgVW5zdWJhY2tSZWFzb25Db2RlW1Vuc3ViYWNrUmVhc29uQ29kZVtcIlRvcGljRmlsdGVySW52YWxpZFwiXSA9IDE0M10gPSBcIlRvcGljRmlsdGVySW52YWxpZFwiO1xuICAgIC8qKlxuICAgICAqIFJldHVybmVkIHdoZW4gdGhlIHBhY2tldCBpZGVudGlmaWVyIHdhcyBhbHJlYWR5IGluIHVzZSBvbiB0aGUgc2VydmVyLlxuICAgICAqL1xuICAgIFVuc3ViYWNrUmVhc29uQ29kZVtVbnN1YmFja1JlYXNvbkNvZGVbXCJQYWNrZXRJZGVudGlmaWVySW5Vc2VcIl0gPSAxNDVdID0gXCJQYWNrZXRJZGVudGlmaWVySW5Vc2VcIjtcbn0pKFVuc3ViYWNrUmVhc29uQ29kZSA9IGV4cG9ydHMuVW5zdWJhY2tSZWFzb25Db2RlIHx8IChleHBvcnRzLlVuc3ViYWNrUmVhc29uQ29kZSA9IHt9KSk7XG4vKipcbiAqIERldGVybWluZXMgaWYgYSByZWFzb24gY29kZSByZXByZXNlbnRzIGEgc3VjY2Vzc2Z1bCB1bnN1YnNjcmliZSBvcGVyYXRpb25cbiAqXG4gKiBAcGFyYW0gcmVhc29uQ29kZSByZWFzb24gY29kZSB0byBjaGVjayBzdWNjZXNzIGZvclxuICovXG5mdW5jdGlvbiBpc1N1Y2Nlc3NmdWxVbnN1YmFja1JlYXNvbkNvZGUocmVhc29uQ29kZSkge1xuICAgIHJldHVybiByZWFzb25Db2RlIDwgMTI4O1xufVxuZXhwb3J0cy5pc1N1Y2Nlc3NmdWxVbnN1YmFja1JlYXNvbkNvZGUgPSBpc1N1Y2Nlc3NmdWxVbnN1YmFja1JlYXNvbkNvZGU7XG4vKipcbiAqIFJlYXNvbiBjb2RlIGluc2lkZSBQVUJBQ0sgcGFja2V0cyB0aGF0IGluZGljYXRlcyB0aGUgcmVzdWx0IG9mIHRoZSBhc3NvY2lhdGVkIFBVQkxJU0ggcmVxdWVzdC5cbiAqXG4gKiBFbnVtIHZhbHVlcyBtYXRjaCBbTVFUVDUgc3BlY10oaHR0cHM6Ly9kb2NzLm9hc2lzLW9wZW4ub3JnL21xdHQvbXF0dC92NS4wL29zL21xdHQtdjUuMC1vcy5odG1sI19Ub2MzOTAxMTI0KSBlbmNvZGluZyB2YWx1ZXMuXG4gKi9cbnZhciBQdWJhY2tSZWFzb25Db2RlO1xuKGZ1bmN0aW9uIChQdWJhY2tSZWFzb25Db2RlKSB7XG4gICAgLyoqXG4gICAgICogUmV0dXJuZWQgd2hlbiB0aGUgKFFvUyAxKSBwdWJsaXNoIHdhcyBhY2NlcHRlZCBieSB0aGUgcmVjaXBpZW50LlxuICAgICAqXG4gICAgICogTWF5IGJlIHNlbnQgYnkgdGhlIGNsaWVudCBvciB0aGUgc2VydmVyLlxuICAgICAqL1xuICAgIFB1YmFja1JlYXNvbkNvZGVbUHViYWNrUmVhc29uQ29kZVtcIlN1Y2Nlc3NcIl0gPSAwXSA9IFwiU3VjY2Vzc1wiO1xuICAgIC8qKlxuICAgICAqIFJldHVybmVkIHdoZW4gdGhlIChRb1MgMSkgcHVibGlzaCB3YXMgYWNjZXB0ZWQgYnV0IHRoZXJlIHdlcmUgbm8gbWF0Y2hpbmcgc3Vic2NyaWJlcnMuXG4gICAgICpcbiAgICAgKiBNYXkgb25seSBiZSBzZW50IGJ5IHRoZSBzZXJ2ZXIuXG4gICAgICovXG4gICAgUHViYWNrUmVhc29uQ29kZVtQdWJhY2tSZWFzb25Db2RlW1wiTm9NYXRjaGluZ1N1YnNjcmliZXJzXCJdID0gMTZdID0gXCJOb01hdGNoaW5nU3Vic2NyaWJlcnNcIjtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5lZCB3aGVuIHRoZSAoUW9TIDEpIHB1Ymxpc2ggd2FzIG5vdCBhY2NlcHRlZCBhbmQgdGhlIHJlY2VpdmVyIGRvZXMgbm90IHdhbnQgdG8gc3BlY2lmeSBhIHJlYXNvbiBvciBub25lXG4gICAgICogb2YgdGhlIG90aGVyIHJlYXNvbiBjb2RlcyBhcHBseS5cbiAgICAgKlxuICAgICAqIE1heSBiZSBzZW50IGJ5IHRoZSBjbGllbnQgb3IgdGhlIHNlcnZlci5cbiAgICAgKi9cbiAgICBQdWJhY2tSZWFzb25Db2RlW1B1YmFja1JlYXNvbkNvZGVbXCJVbnNwZWNpZmllZEVycm9yXCJdID0gMTI4XSA9IFwiVW5zcGVjaWZpZWRFcnJvclwiO1xuICAgIC8qKlxuICAgICAqIFJldHVybmVkIHdoZW4gdGhlIChRb1MgMSkgcHVibGlzaCB3YXMgdmFsaWQgYnV0IHRoZSByZWNlaXZlciB3YXMgbm90IHdpbGxpbmcgdG8gYWNjZXB0IGl0LlxuICAgICAqXG4gICAgICogTWF5IGJlIHNlbnQgYnkgdGhlIGNsaWVudCBvciB0aGUgc2VydmVyLlxuICAgICAqL1xuICAgIFB1YmFja1JlYXNvbkNvZGVbUHViYWNrUmVhc29uQ29kZVtcIkltcGxlbWVudGF0aW9uU3BlY2lmaWNFcnJvclwiXSA9IDEzMV0gPSBcIkltcGxlbWVudGF0aW9uU3BlY2lmaWNFcnJvclwiO1xuICAgIC8qKlxuICAgICAqIFJldHVybmVkIHdoZW4gdGhlIChRb1MgMSkgcHVibGlzaCB3YXMgbm90IGF1dGhvcml6ZWQgYnkgdGhlIHJlY2VpdmVyLlxuICAgICAqXG4gICAgICogTWF5IGJlIHNlbnQgYnkgdGhlIGNsaWVudCBvciB0aGUgc2VydmVyLlxuICAgICAqL1xuICAgIFB1YmFja1JlYXNvbkNvZGVbUHViYWNrUmVhc29uQ29kZVtcIk5vdEF1dGhvcml6ZWRcIl0gPSAxMzVdID0gXCJOb3RBdXRob3JpemVkXCI7XG4gICAgLyoqXG4gICAgICogUmV0dXJuZWQgd2hlbiB0aGUgdG9waWMgbmFtZSB3YXMgdmFsaWQgYnV0IHRoZSByZWNlaXZlciB3YXMgbm90IHdpbGxpbmcgdG8gYWNjZXB0IGl0LlxuICAgICAqXG4gICAgICogTWF5IGJlIHNlbnQgYnkgdGhlIGNsaWVudCBvciB0aGUgc2VydmVyLlxuICAgICAqL1xuICAgIFB1YmFja1JlYXNvbkNvZGVbUHViYWNrUmVhc29uQ29kZVtcIlRvcGljTmFtZUludmFsaWRcIl0gPSAxNDRdID0gXCJUb3BpY05hbWVJbnZhbGlkXCI7XG4gICAgLyoqXG4gICAgICogUmV0dXJuZWQgd2hlbiB0aGUgcGFja2V0IGlkZW50aWZpZXIgdXNlZCBpbiB0aGUgYXNzb2NpYXRlZCBQVUJMSVNIIHdhcyBhbHJlYWR5IGluIHVzZS5cbiAgICAgKiBUaGlzIGNhbiBpbmRpY2F0ZSBhIG1pc21hdGNoIGluIHRoZSBzZXNzaW9uIHN0YXRlIGJldHdlZW4gY2xpZW50IGFuZCBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBNYXkgYmUgc2VudCBieSB0aGUgY2xpZW50IG9yIHRoZSBzZXJ2ZXIuXG4gICAgICovXG4gICAgUHViYWNrUmVhc29uQ29kZVtQdWJhY2tSZWFzb25Db2RlW1wiUGFja2V0SWRlbnRpZmllckluVXNlXCJdID0gMTQ1XSA9IFwiUGFja2V0SWRlbnRpZmllckluVXNlXCI7XG4gICAgLyoqXG4gICAgICogUmV0dXJuZWQgd2hlbiB0aGUgYXNzb2NpYXRlZCBQVUJMSVNIIGZhaWxlZCBiZWNhdXNlIGFuIGludGVybmFsIHF1b3RhIG9uIHRoZSByZWNpcGllbnQgd2FzIGV4Y2VlZGVkLlxuICAgICAqXG4gICAgICogTWF5IGJlIHNlbnQgYnkgdGhlIGNsaWVudCBvciB0aGUgc2VydmVyLlxuICAgICAqL1xuICAgIFB1YmFja1JlYXNvbkNvZGVbUHViYWNrUmVhc29uQ29kZVtcIlF1b3RhRXhjZWVkZWRcIl0gPSAxNTFdID0gXCJRdW90YUV4Y2VlZGVkXCI7XG4gICAgLyoqXG4gICAgICogUmV0dXJuZWQgd2hlbiB0aGUgUFVCTElTSCBwYWNrZXQncyBwYXlsb2FkIGZvcm1hdCBkaWQgbm90IG1hdGNoIGl0cyBwYXlsb2FkIGZvcm1hdCBpbmRpY2F0b3IgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBNYXkgYmUgc2VudCBieSB0aGUgY2xpZW50IG9yIHRoZSBzZXJ2ZXIuXG4gICAgICovXG4gICAgUHViYWNrUmVhc29uQ29kZVtQdWJhY2tSZWFzb25Db2RlW1wiUGF5bG9hZEZvcm1hdEludmFsaWRcIl0gPSAxNTNdID0gXCJQYXlsb2FkRm9ybWF0SW52YWxpZFwiO1xufSkoUHViYWNrUmVhc29uQ29kZSA9IGV4cG9ydHMuUHViYWNrUmVhc29uQ29kZSB8fCAoZXhwb3J0cy5QdWJhY2tSZWFzb25Db2RlID0ge30pKTtcbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBhIHJlYXNvbiBjb2RlIHJlcHJlc2VudHMgYSBzdWNjZXNzZnVsIFFvUyAxIHB1Ymxpc2ggb3BlcmF0aW9uXG4gKlxuICogQHBhcmFtIHJlYXNvbkNvZGUgcmVhc29uIGNvZGUgdG8gY2hlY2sgc3VjY2VzcyBmb3JcbiAqL1xuZnVuY3Rpb24gaXNTdWNjZXNzZnVsUHViYWNrUmVhc29uQ29kZShyZWFzb25Db2RlKSB7XG4gICAgcmV0dXJuIHJlYXNvbkNvZGUgPCAxMjg7XG59XG5leHBvcnRzLmlzU3VjY2Vzc2Z1bFB1YmFja1JlYXNvbkNvZGUgPSBpc1N1Y2Nlc3NmdWxQdWJhY2tSZWFzb25Db2RlO1xuLyoqXG4gKiBPcHRpb25hbCBwcm9wZXJ0eSBkZXNjcmliaW5nIGEgUFVCTElTSCBwYXlsb2FkJ3MgZm9ybWF0LlxuICpcbiAqIEVudW0gdmFsdWVzIG1hdGNoIFtNUVRUNSBzcGVjXShodHRwczovL2RvY3Mub2FzaXMtb3Blbi5vcmcvbXF0dC9tcXR0L3Y1LjAvb3MvbXF0dC12NS4wLW9zLmh0bWwjX1RvYzM5MDExMTEpIGVuY29kaW5nIHZhbHVlcy5cbiAqL1xudmFyIFBheWxvYWRGb3JtYXRJbmRpY2F0b3I7XG4oZnVuY3Rpb24gKFBheWxvYWRGb3JtYXRJbmRpY2F0b3IpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgcGF5bG9hZCBpcyBhcmJpdHJhcnkgYmluYXJ5IGRhdGFcbiAgICAgKi9cbiAgICBQYXlsb2FkRm9ybWF0SW5kaWNhdG9yW1BheWxvYWRGb3JtYXRJbmRpY2F0b3JbXCJCeXRlc1wiXSA9IDBdID0gXCJCeXRlc1wiO1xuICAgIC8qKlxuICAgICAqIFRoZSBwYXlsb2FkIGlzIGEgd2VsbC1mb3JtZWQgdXRmLTggc3RyaW5nIHZhbHVlLlxuICAgICAqL1xuICAgIFBheWxvYWRGb3JtYXRJbmRpY2F0b3JbUGF5bG9hZEZvcm1hdEluZGljYXRvcltcIlV0ZjhcIl0gPSAxXSA9IFwiVXRmOFwiO1xufSkoUGF5bG9hZEZvcm1hdEluZGljYXRvciA9IGV4cG9ydHMuUGF5bG9hZEZvcm1hdEluZGljYXRvciB8fCAoZXhwb3J0cy5QYXlsb2FkRm9ybWF0SW5kaWNhdG9yID0ge30pKTtcbi8qKlxuICogTVFUVCBtZXNzYWdlIGRlbGl2ZXJ5IHF1YWxpdHkgb2Ygc2VydmljZS5cbiAqXG4gKiBFbnVtIHZhbHVlcyBtYXRjaCBbTVFUVDUgc3BlY10oaHR0cHM6Ly9kb2NzLm9hc2lzLW9wZW4ub3JnL21xdHQvbXF0dC92NS4wL29zL21xdHQtdjUuMC1vcy5odG1sI19Ub2MzOTAxMjM0KSBlbmNvZGluZyB2YWx1ZXMuXG4gKi9cbnZhciBRb1M7XG4oZnVuY3Rpb24gKFFvUykge1xuICAgIC8qKlxuICAgICAqIFRoZSBtZXNzYWdlIGlzIGRlbGl2ZXJlZCBhY2NvcmRpbmcgdG8gdGhlIGNhcGFiaWxpdGllcyBvZiB0aGUgdW5kZXJseWluZyBuZXR3b3JrLiBObyByZXNwb25zZSBpcyBzZW50IGJ5IHRoZVxuICAgICAqIHJlY2VpdmVyIGFuZCBubyByZXRyeSBpcyBwZXJmb3JtZWQgYnkgdGhlIHNlbmRlci4gVGhlIG1lc3NhZ2UgYXJyaXZlcyBhdCB0aGUgcmVjZWl2ZXIgZWl0aGVyIG9uY2Ugb3Igbm90IGF0IGFsbC5cbiAgICAgKi9cbiAgICBRb1NbUW9TW1wiQXRNb3N0T25jZVwiXSA9IDBdID0gXCJBdE1vc3RPbmNlXCI7XG4gICAgLyoqXG4gICAgICogQSBsZXZlbCBvZiBzZXJ2aWNlIHRoYXQgZW5zdXJlcyB0aGF0IHRoZSBtZXNzYWdlIGFycml2ZXMgYXQgdGhlIHJlY2VpdmVyIGF0IGxlYXN0IG9uY2UuXG4gICAgICovXG4gICAgUW9TW1FvU1tcIkF0TGVhc3RPbmNlXCJdID0gMV0gPSBcIkF0TGVhc3RPbmNlXCI7XG4gICAgLyoqXG4gICAgICogQSBsZXZlbCBvZiBzZXJ2aWNlIHRoYXQgZW5zdXJlcyB0aGF0IHRoZSBtZXNzYWdlIGFycml2ZXMgYXQgdGhlIHJlY2VpdmVyIGV4YWN0bHkgb25jZS5cbiAgICAgKi9cbiAgICBRb1NbUW9TW1wiRXhhY3RseU9uY2VcIl0gPSAyXSA9IFwiRXhhY3RseU9uY2VcIjtcbn0pKFFvUyA9IGV4cG9ydHMuUW9TIHx8IChleHBvcnRzLlFvUyA9IHt9KSk7XG4vKipcbiAqIENvbmZpZ3VyZXMgaG93IHJldGFpbmVkIG1lc3NhZ2VzIHNob3VsZCBiZSBoYW5kbGVkIHdoZW4gc3Vic2NyaWJpbmcgd2l0aCBhIHRvcGljIGZpbHRlciB0aGF0IG1hdGNoZXMgdG9waWNzIHdpdGhcbiAqIGFzc29jaWF0ZWQgcmV0YWluZWQgbWVzc2FnZXMuXG4gKlxuICogRW51bSB2YWx1ZXMgbWF0Y2ggW01RVFQ1IHNwZWNdKGh0dHBzOi8vZG9jcy5vYXNpcy1vcGVuLm9yZy9tcXR0L21xdHQvdjUuMC9vcy9tcXR0LXY1LjAtb3MuaHRtbCNfVG9jMzkwMTE2OSkgZW5jb2RpbmcgdmFsdWVzLlxuICovXG52YXIgUmV0YWluSGFuZGxpbmdUeXBlO1xuKGZ1bmN0aW9uIChSZXRhaW5IYW5kbGluZ1R5cGUpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgc2VydmVyIHNob3VsZCBhbHdheXMgc2VuZCBhbGwgcmV0YWluZWQgbWVzc2FnZXMgb24gdG9waWNzIHRoYXQgbWF0Y2ggYSBzdWJzY3JpcHRpb24ncyBmaWx0ZXIuXG4gICAgICovXG4gICAgUmV0YWluSGFuZGxpbmdUeXBlW1JldGFpbkhhbmRsaW5nVHlwZVtcIlNlbmRPblN1YnNjcmliZVwiXSA9IDBdID0gXCJTZW5kT25TdWJzY3JpYmVcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgc2VydmVyIHNob3VsZCBzZW5kIHJldGFpbmVkIG1lc3NhZ2VzIG9uIHRvcGljcyB0aGF0IG1hdGNoIHRoZSBzdWJzY3JpcHRpb24ncyBmaWx0ZXIsIGJ1dCBvbmx5IGZvciB0aGVcbiAgICAgKiBmaXJzdCBtYXRjaGluZyBzdWJzY3JpcHRpb24sIHBlciBzZXNzaW9uLlxuICAgICAqL1xuICAgIFJldGFpbkhhbmRsaW5nVHlwZVtSZXRhaW5IYW5kbGluZ1R5cGVbXCJTZW5kT25TdWJzY3JpYmVJZk5ld1wiXSA9IDFdID0gXCJTZW5kT25TdWJzY3JpYmVJZk5ld1wiO1xuICAgIC8qKlxuICAgICAqIFN1YnNjcmlwdGlvbnMgbXVzdCBub3QgdHJpZ2dlciBhbnkgcmV0YWluZWQgbWVzc2FnZSBwdWJsaXNoZXMgZnJvbSB0aGUgc2VydmVyLlxuICAgICAqL1xuICAgIFJldGFpbkhhbmRsaW5nVHlwZVtSZXRhaW5IYW5kbGluZ1R5cGVbXCJEb250U2VuZFwiXSA9IDJdID0gXCJEb250U2VuZFwiO1xufSkoUmV0YWluSGFuZGxpbmdUeXBlID0gZXhwb3J0cy5SZXRhaW5IYW5kbGluZ1R5cGUgfHwgKGV4cG9ydHMuUmV0YWluSGFuZGxpbmdUeXBlID0ge30pKTtcbi8qKlxuICogUGFja2V0IHR5cGUgaW5kaWNhdG9yIHRoYXQgYWxsb3dzIGZvciBiYXNpYyBwb2x5bW9ycGhpc20gd2l0aCB1c2VyLXJlY2VpdmVkIHBhY2tldHMuICBFbnVtIHZhbHVlc1xuICogbWF0Y2ggdGhlIG1xdHQgc3BlYydzIFtwYWNrZXQgdHlwZSBlbmNvZGluZ10oaHR0cHM6Ly9kb2NzLm9hc2lzLW9wZW4ub3JnL21xdHQvbXF0dC92NS4wL29zL21xdHQtdjUuMC1vcy5odG1sI19Ub2MzOTAxMDIyKSB2YWx1ZXMuXG4gKi9cbnZhciBQYWNrZXRUeXBlO1xuKGZ1bmN0aW9uIChQYWNrZXRUeXBlKSB7XG4gICAgUGFja2V0VHlwZVtQYWNrZXRUeXBlW1wiQ29ubmVjdFwiXSA9IDFdID0gXCJDb25uZWN0XCI7XG4gICAgUGFja2V0VHlwZVtQYWNrZXRUeXBlW1wiQ29ubmFja1wiXSA9IDJdID0gXCJDb25uYWNrXCI7XG4gICAgUGFja2V0VHlwZVtQYWNrZXRUeXBlW1wiUHVibGlzaFwiXSA9IDNdID0gXCJQdWJsaXNoXCI7XG4gICAgUGFja2V0VHlwZVtQYWNrZXRUeXBlW1wiUHViYWNrXCJdID0gNF0gPSBcIlB1YmFja1wiO1xuICAgIFBhY2tldFR5cGVbUGFja2V0VHlwZVtcIlB1YnJlY1wiXSA9IDVdID0gXCJQdWJyZWNcIjtcbiAgICBQYWNrZXRUeXBlW1BhY2tldFR5cGVbXCJQdWJyZWxcIl0gPSA2XSA9IFwiUHVicmVsXCI7XG4gICAgUGFja2V0VHlwZVtQYWNrZXRUeXBlW1wiUHViY29tcFwiXSA9IDddID0gXCJQdWJjb21wXCI7XG4gICAgUGFja2V0VHlwZVtQYWNrZXRUeXBlW1wiU3Vic2NyaWJlXCJdID0gOF0gPSBcIlN1YnNjcmliZVwiO1xuICAgIFBhY2tldFR5cGVbUGFja2V0VHlwZVtcIlN1YmFja1wiXSA9IDldID0gXCJTdWJhY2tcIjtcbiAgICBQYWNrZXRUeXBlW1BhY2tldFR5cGVbXCJVbnN1YnNjcmliZVwiXSA9IDEwXSA9IFwiVW5zdWJzY3JpYmVcIjtcbiAgICBQYWNrZXRUeXBlW1BhY2tldFR5cGVbXCJVbnN1YmFja1wiXSA9IDExXSA9IFwiVW5zdWJhY2tcIjtcbiAgICBQYWNrZXRUeXBlW1BhY2tldFR5cGVbXCJQaW5ncmVxXCJdID0gMTJdID0gXCJQaW5ncmVxXCI7XG4gICAgUGFja2V0VHlwZVtQYWNrZXRUeXBlW1wiUGluZ3Jlc3BcIl0gPSAxM10gPSBcIlBpbmdyZXNwXCI7XG4gICAgUGFja2V0VHlwZVtQYWNrZXRUeXBlW1wiRGlzY29ubmVjdFwiXSA9IDE0XSA9IFwiRGlzY29ubmVjdFwiO1xuICAgIFBhY2tldFR5cGVbUGFja2V0VHlwZVtcIkF1dGhcIl0gPSAxNV0gPSBcIkF1dGhcIjtcbn0pKFBhY2tldFR5cGUgPSBleHBvcnRzLlBhY2tldFR5cGUgfHwgKGV4cG9ydHMuUGFja2V0VHlwZSA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tcXR0NV9wYWNrZXQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/aws-crt/dist/common/mqtt5_packet.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/aws-crt/dist/common/mqtt_shared.js":
/*!*********************************************************!*\
  !*** ./node_modules/aws-crt/dist/common/mqtt_shared.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n * SPDX-License-Identifier: Apache-2.0.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DEFAULT_KEEP_ALIVE = exports.normalize_payload = void 0;\n/**\n * @packageDocumentation\n */\n/**\n * Converts payload to Buffer or string regardless of the supplied type\n * @param payload The payload to convert\n * @internal\n */\nfunction normalize_payload(payload) {\n    if (payload instanceof Buffer) {\n        // pass Buffer through\n        return payload;\n    }\n    if (typeof payload === 'string') {\n        // pass string through\n        return payload;\n    }\n    if (ArrayBuffer.isView(payload)) {\n        // return Buffer with view upon the same bytes (no copy)\n        const view = payload;\n        return Buffer.from(view.buffer, view.byteOffset, view.byteLength);\n    }\n    if (payload instanceof ArrayBuffer) {\n        // return Buffer with view upon the same bytes (no copy)\n        return Buffer.from(payload);\n    }\n    if (typeof payload === 'object') {\n        // Convert Object to JSON string\n        return JSON.stringify(payload);\n    }\n    if (!payload) {\n        return \"\";\n    }\n    throw new TypeError(\"payload parameter must be a string, object, or DataView.\");\n}\nexports.normalize_payload = normalize_payload;\n/** @internal */\nexports.DEFAULT_KEEP_ALIVE = 1200;\n//# sourceMappingURL=mqtt_shared.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXdzLWNydC9kaXN0L2NvbW1vbi9tcXR0X3NoYXJlZC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDBCQUEwQixHQUFHLHlCQUF5QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsMEJBQTBCO0FBQzFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGF5d2luZC8uL25vZGVfbW9kdWxlcy9hd3MtY3J0L2Rpc3QvY29tbW9uL21xdHRfc2hhcmVkLmpzPzZhMTciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IEFtYXpvbi5jb20sIEluYy4gb3IgaXRzIGFmZmlsaWF0ZXMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMC5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ERUZBVUxUX0tFRVBfQUxJVkUgPSBleHBvcnRzLm5vcm1hbGl6ZV9wYXlsb2FkID0gdm9pZCAwO1xuLyoqXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqL1xuLyoqXG4gKiBDb252ZXJ0cyBwYXlsb2FkIHRvIEJ1ZmZlciBvciBzdHJpbmcgcmVnYXJkbGVzcyBvZiB0aGUgc3VwcGxpZWQgdHlwZVxuICogQHBhcmFtIHBheWxvYWQgVGhlIHBheWxvYWQgdG8gY29udmVydFxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZV9wYXlsb2FkKHBheWxvYWQpIHtcbiAgICBpZiAocGF5bG9hZCBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAgICAvLyBwYXNzIEJ1ZmZlciB0aHJvdWdoXG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHBheWxvYWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIHBhc3Mgc3RyaW5nIHRocm91Z2hcbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfVxuICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcocGF5bG9hZCkpIHtcbiAgICAgICAgLy8gcmV0dXJuIEJ1ZmZlciB3aXRoIHZpZXcgdXBvbiB0aGUgc2FtZSBieXRlcyAobm8gY29weSlcbiAgICAgICAgY29uc3QgdmlldyA9IHBheWxvYWQ7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh2aWV3LmJ1ZmZlciwgdmlldy5ieXRlT2Zmc2V0LCB2aWV3LmJ5dGVMZW5ndGgpO1xuICAgIH1cbiAgICBpZiAocGF5bG9hZCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIC8vIHJldHVybiBCdWZmZXIgd2l0aCB2aWV3IHVwb24gdGhlIHNhbWUgYnl0ZXMgKG5vIGNvcHkpXG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShwYXlsb2FkKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwYXlsb2FkID09PSAnb2JqZWN0Jykge1xuICAgICAgICAvLyBDb252ZXJ0IE9iamVjdCB0byBKU09OIHN0cmluZ1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocGF5bG9hZCk7XG4gICAgfVxuICAgIGlmICghcGF5bG9hZCkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInBheWxvYWQgcGFyYW1ldGVyIG11c3QgYmUgYSBzdHJpbmcsIG9iamVjdCwgb3IgRGF0YVZpZXcuXCIpO1xufVxuZXhwb3J0cy5ub3JtYWxpemVfcGF5bG9hZCA9IG5vcm1hbGl6ZV9wYXlsb2FkO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0cy5ERUZBVUxUX0tFRVBfQUxJVkUgPSAxMjAwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bXF0dF9zaGFyZWQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/aws-crt/dist/common/mqtt_shared.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/aws-crt/dist/common/platform.js":
/*!******************************************************!*\
  !*** ./node_modules/aws-crt/dist/common/platform.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n * SPDX-License-Identifier: Apache-2.0.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.crt_version = exports.package_info = exports.is_browser = exports.is_nodejs = void 0;\n/**\n *\n * A module containing miscellaneous platform-related queries\n *\n * @packageDocumentation\n * @module platform\n * @mergeTarget\n */\n/**\n * Returns true if this script is running under nodejs\n *\n * @category System\n */\nfunction is_nodejs() {\n    return (typeof process === 'object' &&\n        typeof process.versions === 'object' &&\n        typeof process.versions.node !== 'undefined');\n}\nexports.is_nodejs = is_nodejs;\n/**\n * Returns true if this script is running in a browser\n *\n * @category System\n */\nfunction is_browser() {\n    return !is_nodejs();\n}\nexports.is_browser = is_browser;\n/**\n * Returns the package information for aws-crt-nodejs\n *\n * @category System\n */\nfunction package_info() {\n    try {\n        const pkg = __webpack_require__(/*! ../../package.json */ \"(ssr)/./node_modules/aws-crt/package.json\");\n        return pkg;\n    }\n    catch (err) {\n        return {\n            name: 'aws-crt-nodejs',\n            version: 'UNKNOWN'\n        };\n    }\n}\nexports.package_info = package_info;\n/**\n * Returns the AWS CRT version\n *\n * @category System\n */\nfunction crt_version() {\n    const pkg = package_info();\n    return pkg.version;\n}\nexports.crt_version = crt_version;\n//# sourceMappingURL=platform.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXdzLWNydC9kaXN0L2NvbW1vbi9wbGF0Zm9ybS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQixHQUFHLG9CQUFvQixHQUFHLGtCQUFrQixHQUFHLGlCQUFpQjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBTyxDQUFDLHFFQUFvQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGF5d2luZC8uL25vZGVfbW9kdWxlcy9hd3MtY3J0L2Rpc3QvY29tbW9uL3BsYXRmb3JtLmpzP2FlMzgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IEFtYXpvbi5jb20sIEluYy4gb3IgaXRzIGFmZmlsaWF0ZXMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMC5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcnRfdmVyc2lvbiA9IGV4cG9ydHMucGFja2FnZV9pbmZvID0gZXhwb3J0cy5pc19icm93c2VyID0gZXhwb3J0cy5pc19ub2RlanMgPSB2b2lkIDA7XG4vKipcbiAqXG4gKiBBIG1vZHVsZSBjb250YWluaW5nIG1pc2NlbGxhbmVvdXMgcGxhdGZvcm0tcmVsYXRlZCBxdWVyaWVzXG4gKlxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKiBAbW9kdWxlIHBsYXRmb3JtXG4gKiBAbWVyZ2VUYXJnZXRcbiAqL1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBzY3JpcHQgaXMgcnVubmluZyB1bmRlciBub2RlanNcbiAqXG4gKiBAY2F0ZWdvcnkgU3lzdGVtXG4gKi9cbmZ1bmN0aW9uIGlzX25vZGVqcygpIHtcbiAgICByZXR1cm4gKHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJlxuICAgICAgICB0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucyA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgdHlwZW9mIHByb2Nlc3MudmVyc2lvbnMubm9kZSAhPT0gJ3VuZGVmaW5lZCcpO1xufVxuZXhwb3J0cy5pc19ub2RlanMgPSBpc19ub2RlanM7XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHNjcmlwdCBpcyBydW5uaW5nIGluIGEgYnJvd3NlclxuICpcbiAqIEBjYXRlZ29yeSBTeXN0ZW1cbiAqL1xuZnVuY3Rpb24gaXNfYnJvd3NlcigpIHtcbiAgICByZXR1cm4gIWlzX25vZGVqcygpO1xufVxuZXhwb3J0cy5pc19icm93c2VyID0gaXNfYnJvd3Nlcjtcbi8qKlxuICogUmV0dXJucyB0aGUgcGFja2FnZSBpbmZvcm1hdGlvbiBmb3IgYXdzLWNydC1ub2RlanNcbiAqXG4gKiBAY2F0ZWdvcnkgU3lzdGVtXG4gKi9cbmZ1bmN0aW9uIHBhY2thZ2VfaW5mbygpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBwa2cgPSByZXF1aXJlKCcuLi8uLi9wYWNrYWdlLmpzb24nKTtcbiAgICAgICAgcmV0dXJuIHBrZztcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogJ2F3cy1jcnQtbm9kZWpzJyxcbiAgICAgICAgICAgIHZlcnNpb246ICdVTktOT1dOJ1xuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMucGFja2FnZV9pbmZvID0gcGFja2FnZV9pbmZvO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBBV1MgQ1JUIHZlcnNpb25cbiAqXG4gKiBAY2F0ZWdvcnkgU3lzdGVtXG4gKi9cbmZ1bmN0aW9uIGNydF92ZXJzaW9uKCkge1xuICAgIGNvbnN0IHBrZyA9IHBhY2thZ2VfaW5mbygpO1xuICAgIHJldHVybiBwa2cudmVyc2lvbjtcbn1cbmV4cG9ydHMuY3J0X3ZlcnNpb24gPSBjcnRfdmVyc2lvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBsYXRmb3JtLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/aws-crt/dist/common/platform.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/aws-crt/dist/common/promise.js":
/*!*****************************************************!*\
  !*** ./node_modules/aws-crt/dist/common/promise.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n * SPDX-License-Identifier: Apache-2.0.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.newLiftedPromise = exports.makeSelfCleaningPromise = void 0;\n/**\n * A helper function that takes a promise and creates a wrapper promise that invokes a cleanup function when the inner\n * promise is completed for any reason.  The primary use is to remove event listeners related to promise completion\n * when the promise actually completes.  This allows us to keep the number of listeners on a CancelController bounded by\n * the number of incomplete promises associated with it.  If we didn't clean up, the listener set would grow\n * without limit.\n *\n * For cancellation, this leads to an internal usage pattern that is strongly recommended:\n *\n * ```\n * async doSomethingCancellable(...) : Promise<...> {\n *    removeListenerFunctor = undefined;\n *\n *    innerPromise = new Promise(async (resolve, reject) => {\n *       ...\n *\n *       cancelListenerFunction = () => { clean up and reject innerPromise };\n *       removeListenerFunctor = cancelController.addListener(cancelListenerFunction);\n *\n *       ...\n *    }\n *\n *    return makeSelfCleaningPromise(innerPromise, removeListenerFunctor);\n * }\n * ```\n *\n * @param promise promise to wrap with automatic cleanup\n * @param cleaner cleaner function to invoke when the promise is completed\n *\n * @return a promise with matching result/err, that invokes the cleaner function on inner promise completion\n */\nfunction makeSelfCleaningPromise(promise, cleaner) {\n    if (!cleaner) {\n        return promise;\n    }\n    return promise.finally(() => { cleaner(); });\n}\nexports.makeSelfCleaningPromise = makeSelfCleaningPromise;\n/**\n * Factory function to create a new LiftedPromise\n *\n * @param promiseBody optional body function to invoke as part of promise creation\n *\n * @return a promise whose resolve and reject methods have been lifted out of the internal body function and made\n * available to external actors\n */\nfunction newLiftedPromise(promiseBody) {\n    let localResolve = undefined;\n    let localReject = undefined;\n    let promise = new Promise((resolve, reject) => {\n        localResolve = resolve;\n        localReject = reject;\n    });\n    if (!localResolve || !localReject) {\n        // should never happen\n        throw new Error(\"Failed to bind resolve and reject when making lifted promise\");\n    }\n    if (promiseBody) {\n        promiseBody(localResolve, localReject);\n    }\n    return {\n        promise: promise,\n        resolve: localResolve,\n        reject: localReject\n    };\n}\nexports.newLiftedPromise = newLiftedPromise;\n//# sourceMappingURL=promise.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXdzLWNydC9kaXN0L2NvbW1vbi9wcm9taXNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCLEdBQUcsK0JBQStCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxZQUFZO0FBQy9DO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wYXl3aW5kLy4vbm9kZV9tb2R1bGVzL2F3cy1jcnQvZGlzdC9jb21tb24vcHJvbWlzZS5qcz8yZmU1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjAuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubmV3TGlmdGVkUHJvbWlzZSA9IGV4cG9ydHMubWFrZVNlbGZDbGVhbmluZ1Byb21pc2UgPSB2b2lkIDA7XG4vKipcbiAqIEEgaGVscGVyIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBwcm9taXNlIGFuZCBjcmVhdGVzIGEgd3JhcHBlciBwcm9taXNlIHRoYXQgaW52b2tlcyBhIGNsZWFudXAgZnVuY3Rpb24gd2hlbiB0aGUgaW5uZXJcbiAqIHByb21pc2UgaXMgY29tcGxldGVkIGZvciBhbnkgcmVhc29uLiAgVGhlIHByaW1hcnkgdXNlIGlzIHRvIHJlbW92ZSBldmVudCBsaXN0ZW5lcnMgcmVsYXRlZCB0byBwcm9taXNlIGNvbXBsZXRpb25cbiAqIHdoZW4gdGhlIHByb21pc2UgYWN0dWFsbHkgY29tcGxldGVzLiAgVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0aGUgbnVtYmVyIG9mIGxpc3RlbmVycyBvbiBhIENhbmNlbENvbnRyb2xsZXIgYm91bmRlZCBieVxuICogdGhlIG51bWJlciBvZiBpbmNvbXBsZXRlIHByb21pc2VzIGFzc29jaWF0ZWQgd2l0aCBpdC4gIElmIHdlIGRpZG4ndCBjbGVhbiB1cCwgdGhlIGxpc3RlbmVyIHNldCB3b3VsZCBncm93XG4gKiB3aXRob3V0IGxpbWl0LlxuICpcbiAqIEZvciBjYW5jZWxsYXRpb24sIHRoaXMgbGVhZHMgdG8gYW4gaW50ZXJuYWwgdXNhZ2UgcGF0dGVybiB0aGF0IGlzIHN0cm9uZ2x5IHJlY29tbWVuZGVkOlxuICpcbiAqIGBgYFxuICogYXN5bmMgZG9Tb21ldGhpbmdDYW5jZWxsYWJsZSguLi4pIDogUHJvbWlzZTwuLi4+IHtcbiAqICAgIHJlbW92ZUxpc3RlbmVyRnVuY3RvciA9IHVuZGVmaW5lZDtcbiAqXG4gKiAgICBpbm5lclByb21pc2UgPSBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gKiAgICAgICAuLi5cbiAqXG4gKiAgICAgICBjYW5jZWxMaXN0ZW5lckZ1bmN0aW9uID0gKCkgPT4geyBjbGVhbiB1cCBhbmQgcmVqZWN0IGlubmVyUHJvbWlzZSB9O1xuICogICAgICAgcmVtb3ZlTGlzdGVuZXJGdW5jdG9yID0gY2FuY2VsQ29udHJvbGxlci5hZGRMaXN0ZW5lcihjYW5jZWxMaXN0ZW5lckZ1bmN0aW9uKTtcbiAqXG4gKiAgICAgICAuLi5cbiAqICAgIH1cbiAqXG4gKiAgICByZXR1cm4gbWFrZVNlbGZDbGVhbmluZ1Byb21pc2UoaW5uZXJQcm9taXNlLCByZW1vdmVMaXN0ZW5lckZ1bmN0b3IpO1xuICogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHByb21pc2UgcHJvbWlzZSB0byB3cmFwIHdpdGggYXV0b21hdGljIGNsZWFudXBcbiAqIEBwYXJhbSBjbGVhbmVyIGNsZWFuZXIgZnVuY3Rpb24gdG8gaW52b2tlIHdoZW4gdGhlIHByb21pc2UgaXMgY29tcGxldGVkXG4gKlxuICogQHJldHVybiBhIHByb21pc2Ugd2l0aCBtYXRjaGluZyByZXN1bHQvZXJyLCB0aGF0IGludm9rZXMgdGhlIGNsZWFuZXIgZnVuY3Rpb24gb24gaW5uZXIgcHJvbWlzZSBjb21wbGV0aW9uXG4gKi9cbmZ1bmN0aW9uIG1ha2VTZWxmQ2xlYW5pbmdQcm9taXNlKHByb21pc2UsIGNsZWFuZXIpIHtcbiAgICBpZiAoIWNsZWFuZXIpIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIHJldHVybiBwcm9taXNlLmZpbmFsbHkoKCkgPT4geyBjbGVhbmVyKCk7IH0pO1xufVxuZXhwb3J0cy5tYWtlU2VsZkNsZWFuaW5nUHJvbWlzZSA9IG1ha2VTZWxmQ2xlYW5pbmdQcm9taXNlO1xuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIG5ldyBMaWZ0ZWRQcm9taXNlXG4gKlxuICogQHBhcmFtIHByb21pc2VCb2R5IG9wdGlvbmFsIGJvZHkgZnVuY3Rpb24gdG8gaW52b2tlIGFzIHBhcnQgb2YgcHJvbWlzZSBjcmVhdGlvblxuICpcbiAqIEByZXR1cm4gYSBwcm9taXNlIHdob3NlIHJlc29sdmUgYW5kIHJlamVjdCBtZXRob2RzIGhhdmUgYmVlbiBsaWZ0ZWQgb3V0IG9mIHRoZSBpbnRlcm5hbCBib2R5IGZ1bmN0aW9uIGFuZCBtYWRlXG4gKiBhdmFpbGFibGUgdG8gZXh0ZXJuYWwgYWN0b3JzXG4gKi9cbmZ1bmN0aW9uIG5ld0xpZnRlZFByb21pc2UocHJvbWlzZUJvZHkpIHtcbiAgICBsZXQgbG9jYWxSZXNvbHZlID0gdW5kZWZpbmVkO1xuICAgIGxldCBsb2NhbFJlamVjdCA9IHVuZGVmaW5lZDtcbiAgICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgbG9jYWxSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgbG9jYWxSZWplY3QgPSByZWplY3Q7XG4gICAgfSk7XG4gICAgaWYgKCFsb2NhbFJlc29sdmUgfHwgIWxvY2FsUmVqZWN0KSB7XG4gICAgICAgIC8vIHNob3VsZCBuZXZlciBoYXBwZW5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGJpbmQgcmVzb2x2ZSBhbmQgcmVqZWN0IHdoZW4gbWFraW5nIGxpZnRlZCBwcm9taXNlXCIpO1xuICAgIH1cbiAgICBpZiAocHJvbWlzZUJvZHkpIHtcbiAgICAgICAgcHJvbWlzZUJvZHkobG9jYWxSZXNvbHZlLCBsb2NhbFJlamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHByb21pc2U6IHByb21pc2UsXG4gICAgICAgIHJlc29sdmU6IGxvY2FsUmVzb2x2ZSxcbiAgICAgICAgcmVqZWN0OiBsb2NhbFJlamVjdFxuICAgIH07XG59XG5leHBvcnRzLm5ld0xpZnRlZFByb21pc2UgPSBuZXdMaWZ0ZWRQcm9taXNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvbWlzZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/aws-crt/dist/common/promise.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/aws-crt/dist/common/resource_safety.js":
/*!*************************************************************!*\
  !*** ./node_modules/aws-crt/dist/common/resource_safety.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\n/*\n * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n * SPDX-License-Identifier: Apache-2.0.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.using = void 0;\n/**\n * Use this function to create a resource in an async context. This will make sure the\n * resources are cleaned up before returning.\n *\n * Example:\n * ```\n * await using(res = new SomeResource(), async (res) =>  {\n *     res.do_the_thing();\n * });\n * ```\n *\n * @category System\n */\nfunction using(resource, func) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            yield func(resource);\n        }\n        finally {\n            resource.close();\n        }\n    });\n}\nexports.using = using;\n//# sourceMappingURL=resource_safety.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXdzLWNydC9kaXN0L2NvbW1vbi9yZXNvdXJjZV9zYWZldHkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsYUFBYTtBQUNiIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGF5d2luZC8uL25vZGVfbW9kdWxlcy9hd3MtY3J0L2Rpc3QvY29tbW9uL3Jlc291cmNlX3NhZmV0eS5qcz8yNDU1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjAuXG4gKi9cbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy51c2luZyA9IHZvaWQgMDtcbi8qKlxuICogVXNlIHRoaXMgZnVuY3Rpb24gdG8gY3JlYXRlIGEgcmVzb3VyY2UgaW4gYW4gYXN5bmMgY29udGV4dC4gVGhpcyB3aWxsIG1ha2Ugc3VyZSB0aGVcbiAqIHJlc291cmNlcyBhcmUgY2xlYW5lZCB1cCBiZWZvcmUgcmV0dXJuaW5nLlxuICpcbiAqIEV4YW1wbGU6XG4gKiBgYGBcbiAqIGF3YWl0IHVzaW5nKHJlcyA9IG5ldyBTb21lUmVzb3VyY2UoKSwgYXN5bmMgKHJlcykgPT4gIHtcbiAqICAgICByZXMuZG9fdGhlX3RoaW5nKCk7XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEBjYXRlZ29yeSBTeXN0ZW1cbiAqL1xuZnVuY3Rpb24gdXNpbmcocmVzb3VyY2UsIGZ1bmMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgeWllbGQgZnVuYyhyZXNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICByZXNvdXJjZS5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLnVzaW5nID0gdXNpbmc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvdXJjZV9zYWZldHkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/aws-crt/dist/common/resource_safety.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/aws-crt/dist/index.js":
/*!********************************************!*\
  !*** ./node_modules/aws-crt/dist/index.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n * SPDX-License-Identifier: Apache-2.0.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CrtError = exports.resource_safety = exports.promise = exports.platform = exports.mqtt5 = exports.mqtt = exports.iot = exports.io = exports.http = exports.eventstream = exports.crt = exports.crypto = exports.checksums = exports.cancel = exports.auth = void 0;\n// This is the entry point for the AWS CRT nodejs native libraries\n/* common libs */\nconst cancel = __importStar(__webpack_require__(/*! ./common/cancel */ \"(ssr)/./node_modules/aws-crt/dist/common/cancel.js\"));\nexports.cancel = cancel;\nconst platform = __importStar(__webpack_require__(/*! ./common/platform */ \"(ssr)/./node_modules/aws-crt/dist/common/platform.js\"));\nexports.platform = platform;\nconst promise = __importStar(__webpack_require__(/*! ./common/promise */ \"(ssr)/./node_modules/aws-crt/dist/common/promise.js\"));\nexports.promise = promise;\nconst resource_safety = __importStar(__webpack_require__(/*! ./common/resource_safety */ \"(ssr)/./node_modules/aws-crt/dist/common/resource_safety.js\"));\nexports.resource_safety = resource_safety;\n/* node specific libs */\nconst auth = __importStar(__webpack_require__(/*! ./native/auth */ \"(ssr)/./node_modules/aws-crt/dist/native/auth.js\"));\nexports.auth = auth;\nconst checksums = __importStar(__webpack_require__(/*! ./native/checksums */ \"(ssr)/./node_modules/aws-crt/dist/native/checksums.js\"));\nexports.checksums = checksums;\nconst crt = __importStar(__webpack_require__(/*! ./native/crt */ \"(ssr)/./node_modules/aws-crt/dist/native/crt.js\"));\nexports.crt = crt;\nconst crypto = __importStar(__webpack_require__(/*! ./native/crypto */ \"(ssr)/./node_modules/aws-crt/dist/native/crypto.js\"));\nexports.crypto = crypto;\nconst eventstream = __importStar(__webpack_require__(/*! ./native/eventstream */ \"(ssr)/./node_modules/aws-crt/dist/native/eventstream.js\"));\nexports.eventstream = eventstream;\nconst http = __importStar(__webpack_require__(/*! ./native/http */ \"(ssr)/./node_modules/aws-crt/dist/native/http.js\"));\nexports.http = http;\nconst io = __importStar(__webpack_require__(/*! ./native/io */ \"(ssr)/./node_modules/aws-crt/dist/native/io.js\"));\nexports.io = io;\nconst iot = __importStar(__webpack_require__(/*! ./native/iot */ \"(ssr)/./node_modules/aws-crt/dist/native/iot.js\"));\nexports.iot = iot;\nconst mqtt = __importStar(__webpack_require__(/*! ./native/mqtt */ \"(ssr)/./node_modules/aws-crt/dist/native/mqtt.js\"));\nexports.mqtt = mqtt;\nconst mqtt5 = __importStar(__webpack_require__(/*! ./native/mqtt5 */ \"(ssr)/./node_modules/aws-crt/dist/native/mqtt5.js\"));\nexports.mqtt5 = mqtt5;\nconst error_1 = __webpack_require__(/*! ./native/error */ \"(ssr)/./node_modules/aws-crt/dist/native/error.js\");\nObject.defineProperty(exports, \"CrtError\", ({ enumerable: true, get: function () { return error_1.CrtError; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXdzLWNydC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQixHQUFHLHVCQUF1QixHQUFHLGVBQWUsR0FBRyxnQkFBZ0IsR0FBRyxhQUFhLEdBQUcsWUFBWSxHQUFHLFdBQVcsR0FBRyxVQUFVLEdBQUcsWUFBWSxHQUFHLG1CQUFtQixHQUFHLFdBQVcsR0FBRyxjQUFjLEdBQUcsaUJBQWlCLEdBQUcsY0FBYyxHQUFHLFlBQVk7QUFDalE7QUFDQTtBQUNBLDRCQUE0QixtQkFBTyxDQUFDLDJFQUFpQjtBQUNyRCxjQUFjO0FBQ2QsOEJBQThCLG1CQUFPLENBQUMsK0VBQW1CO0FBQ3pELGdCQUFnQjtBQUNoQiw2QkFBNkIsbUJBQU8sQ0FBQyw2RUFBa0I7QUFDdkQsZUFBZTtBQUNmLHFDQUFxQyxtQkFBTyxDQUFDLDZGQUEwQjtBQUN2RSx1QkFBdUI7QUFDdkI7QUFDQSwwQkFBMEIsbUJBQU8sQ0FBQyx1RUFBZTtBQUNqRCxZQUFZO0FBQ1osK0JBQStCLG1CQUFPLENBQUMsaUZBQW9CO0FBQzNELGlCQUFpQjtBQUNqQix5QkFBeUIsbUJBQU8sQ0FBQyxxRUFBYztBQUMvQyxXQUFXO0FBQ1gsNEJBQTRCLG1CQUFPLENBQUMsMkVBQWlCO0FBQ3JELGNBQWM7QUFDZCxpQ0FBaUMsbUJBQU8sQ0FBQyxxRkFBc0I7QUFDL0QsbUJBQW1CO0FBQ25CLDBCQUEwQixtQkFBTyxDQUFDLHVFQUFlO0FBQ2pELFlBQVk7QUFDWix3QkFBd0IsbUJBQU8sQ0FBQyxtRUFBYTtBQUM3QyxVQUFVO0FBQ1YseUJBQXlCLG1CQUFPLENBQUMscUVBQWM7QUFDL0MsV0FBVztBQUNYLDBCQUEwQixtQkFBTyxDQUFDLHVFQUFlO0FBQ2pELFlBQVk7QUFDWiwyQkFBMkIsbUJBQU8sQ0FBQyx5RUFBZ0I7QUFDbkQsYUFBYTtBQUNiLGdCQUFnQixtQkFBTyxDQUFDLHlFQUFnQjtBQUN4Qyw0Q0FBMkMsRUFBRSxxQ0FBcUMsNEJBQTRCLEVBQUM7QUFDL0ciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wYXl3aW5kLy4vbm9kZV9tb2R1bGVzL2F3cy1jcnQvZGlzdC9pbmRleC5qcz9hMzNhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjAuXG4gKi9cbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DcnRFcnJvciA9IGV4cG9ydHMucmVzb3VyY2Vfc2FmZXR5ID0gZXhwb3J0cy5wcm9taXNlID0gZXhwb3J0cy5wbGF0Zm9ybSA9IGV4cG9ydHMubXF0dDUgPSBleHBvcnRzLm1xdHQgPSBleHBvcnRzLmlvdCA9IGV4cG9ydHMuaW8gPSBleHBvcnRzLmh0dHAgPSBleHBvcnRzLmV2ZW50c3RyZWFtID0gZXhwb3J0cy5jcnQgPSBleHBvcnRzLmNyeXB0byA9IGV4cG9ydHMuY2hlY2tzdW1zID0gZXhwb3J0cy5jYW5jZWwgPSBleHBvcnRzLmF1dGggPSB2b2lkIDA7XG4vLyBUaGlzIGlzIHRoZSBlbnRyeSBwb2ludCBmb3IgdGhlIEFXUyBDUlQgbm9kZWpzIG5hdGl2ZSBsaWJyYXJpZXNcbi8qIGNvbW1vbiBsaWJzICovXG5jb25zdCBjYW5jZWwgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vY29tbW9uL2NhbmNlbFwiKSk7XG5leHBvcnRzLmNhbmNlbCA9IGNhbmNlbDtcbmNvbnN0IHBsYXRmb3JtID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvbW1vbi9wbGF0Zm9ybVwiKSk7XG5leHBvcnRzLnBsYXRmb3JtID0gcGxhdGZvcm07XG5jb25zdCBwcm9taXNlID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvbW1vbi9wcm9taXNlXCIpKTtcbmV4cG9ydHMucHJvbWlzZSA9IHByb21pc2U7XG5jb25zdCByZXNvdXJjZV9zYWZldHkgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vY29tbW9uL3Jlc291cmNlX3NhZmV0eVwiKSk7XG5leHBvcnRzLnJlc291cmNlX3NhZmV0eSA9IHJlc291cmNlX3NhZmV0eTtcbi8qIG5vZGUgc3BlY2lmaWMgbGlicyAqL1xuY29uc3QgYXV0aCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9uYXRpdmUvYXV0aFwiKSk7XG5leHBvcnRzLmF1dGggPSBhdXRoO1xuY29uc3QgY2hlY2tzdW1zID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL25hdGl2ZS9jaGVja3N1bXNcIikpO1xuZXhwb3J0cy5jaGVja3N1bXMgPSBjaGVja3N1bXM7XG5jb25zdCBjcnQgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vbmF0aXZlL2NydFwiKSk7XG5leHBvcnRzLmNydCA9IGNydDtcbmNvbnN0IGNyeXB0byA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9uYXRpdmUvY3J5cHRvXCIpKTtcbmV4cG9ydHMuY3J5cHRvID0gY3J5cHRvO1xuY29uc3QgZXZlbnRzdHJlYW0gPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vbmF0aXZlL2V2ZW50c3RyZWFtXCIpKTtcbmV4cG9ydHMuZXZlbnRzdHJlYW0gPSBldmVudHN0cmVhbTtcbmNvbnN0IGh0dHAgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vbmF0aXZlL2h0dHBcIikpO1xuZXhwb3J0cy5odHRwID0gaHR0cDtcbmNvbnN0IGlvID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL25hdGl2ZS9pb1wiKSk7XG5leHBvcnRzLmlvID0gaW87XG5jb25zdCBpb3QgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vbmF0aXZlL2lvdFwiKSk7XG5leHBvcnRzLmlvdCA9IGlvdDtcbmNvbnN0IG1xdHQgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vbmF0aXZlL21xdHRcIikpO1xuZXhwb3J0cy5tcXR0ID0gbXF0dDtcbmNvbnN0IG1xdHQ1ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL25hdGl2ZS9tcXR0NVwiKSk7XG5leHBvcnRzLm1xdHQ1ID0gbXF0dDU7XG5jb25zdCBlcnJvcl8xID0gcmVxdWlyZShcIi4vbmF0aXZlL2Vycm9yXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ3J0RXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVycm9yXzEuQ3J0RXJyb3I7IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/aws-crt/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/aws-crt/dist/native/auth.js":
/*!**************************************************!*\
  !*** ./node_modules/aws-crt/dist/native/auth.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n * SPDX-License-Identifier: Apache-2.0.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.aws_verify_sigv4a_signing = exports.aws_sign_request = exports.AwsSignedBodyHeaderType = exports.AwsSignedBodyValue = exports.AwsSignatureType = exports.AwsSigningAlgorithm = exports.AwsCredentialsProvider = void 0;\nconst binding_1 = __importDefault(__webpack_require__(/*! ./binding */ \"(ssr)/./node_modules/aws-crt/dist/native/binding.js\"));\nconst error_1 = __webpack_require__(/*! ./error */ \"(ssr)/./node_modules/aws-crt/dist/native/error.js\");\nconst io_1 = __webpack_require__(/*! ./io */ \"(ssr)/./node_modules/aws-crt/dist/native/io.js\");\n/**\n * Credentials providers source the AwsCredentials needed to sign an authenticated AWS request.\n *\n * We don't currently expose an interface for fetching credentials from Javascript.\n *\n * @category Auth\n */\n/* Subclass for the purpose of exposing a non-NativeHandle based API */\nclass AwsCredentialsProvider extends binding_1.default.AwsCredentialsProvider {\n    /**\n     * Creates a new default credentials provider to be used internally for AWS credentials resolution:\n     *\n     *   The CRT's default provider chain currently sources in this order:\n     *\n     *     1. Environment\n     *     2. Profile\n     *     3. (conditional, off by default) ECS\n     *     4. (conditional, on by default) EC2 Instance Metadata\n     *\n     * @param bootstrap (optional) client bootstrap to be used to establish any required network connections\n     *\n     * @returns a new credentials provider using default credentials resolution rules\n     */\n    static newDefault(bootstrap = undefined) {\n        return super.newDefault(bootstrap != null ? bootstrap.native_handle() : null);\n    }\n    /**\n     * Creates a new credentials provider that returns a fixed set of credentials.\n     *\n     * @param access_key access key to use in the static credentials\n     * @param secret_key secret key to use in the static credentials\n     * @param session_token (optional) session token to use in the static credentials\n     *\n     * @returns a new credentials provider that will return a fixed set of AWS credentials\n     */\n    static newStatic(access_key, secret_key, session_token) {\n        return super.newStatic(access_key, secret_key, session_token);\n    }\n    /**\n     * Creates a new credentials provider that sources credentials from the AWS Cognito Identity service via the\n     * GetCredentialsForIdentity http API.\n     *\n     * @param config provider configuration necessary to make GetCredentialsForIdentity web requests\n     *\n     * @returns a new credentials provider that returns credentials sourced from the AWS Cognito Identity service\n     */\n    static newCognito(config) {\n        if (config == null || config == undefined) {\n            throw new error_1.CrtError(\"AwsCredentialsProvider newCognito: Cognito config not defined\");\n        }\n        return super.newCognito(config, config.tlsContext != null ? config.tlsContext.native_handle() : new io_1.ClientTlsContext().native_handle(), config.bootstrap != null ? config.bootstrap.native_handle() : null, config.httpProxyOptions ? config.httpProxyOptions.create_native_handle() : null);\n    }\n    /**\n     * Creates a new credentials provider that sources credentials from the the X509 service on AWS IoT Core.\n     *\n     * @param config provider configuration necessary to source credentials via X509\n     *\n     * @returns a new credentials provider that returns credentials sourced from the AWS X509 service\n     */\n    static newX509(config) {\n        if (config == null || config == undefined) {\n            throw new error_1.CrtError(\"AwsCredentialsProvider newX509: X509 config not defined\");\n        }\n        return super.newX509(config, config.tlsContext.native_handle(), config.httpProxyOptions ? config.httpProxyOptions.create_native_handle() : null);\n    }\n}\nexports.AwsCredentialsProvider = AwsCredentialsProvider;\n/**\n * AWS signing algorithm enumeration.\n *\n * @category Auth\n */\nvar AwsSigningAlgorithm;\n(function (AwsSigningAlgorithm) {\n    /** Use the Aws signature version 4 signing process to sign the request */\n    AwsSigningAlgorithm[AwsSigningAlgorithm[\"SigV4\"] = 0] = \"SigV4\";\n    /** Use the Aws signature version 4 Asymmetric signing process to sign the request */\n    AwsSigningAlgorithm[AwsSigningAlgorithm[\"SigV4Asymmetric\"] = 1] = \"SigV4Asymmetric\";\n})(AwsSigningAlgorithm = exports.AwsSigningAlgorithm || (exports.AwsSigningAlgorithm = {}));\n/**\n * AWS signature type enumeration.\n *\n * @category Auth\n */\nvar AwsSignatureType;\n(function (AwsSignatureType) {\n    /** Sign an http request and apply the signing results as headers */\n    AwsSignatureType[AwsSignatureType[\"HttpRequestViaHeaders\"] = 0] = \"HttpRequestViaHeaders\";\n    /** Sign an http request and apply the signing results as query params */\n    AwsSignatureType[AwsSignatureType[\"HttpRequestViaQueryParams\"] = 1] = \"HttpRequestViaQueryParams\";\n    /** Sign an http request payload chunk */\n    AwsSignatureType[AwsSignatureType[\"HttpRequestChunk\"] = 2] = \"HttpRequestChunk\";\n    /** Sign an event stream event */\n    AwsSignatureType[AwsSignatureType[\"HttpRequestEvent\"] = 3] = \"HttpRequestEvent\";\n})(AwsSignatureType = exports.AwsSignatureType || (exports.AwsSignatureType = {}));\n/**\n * Values for use with {@link AwsSigningConfig.signed_body_value}.\n *\n * Some services use special values (e.g. 'UNSIGNED-PAYLOAD') when the body\n * is not being signed in the usual way.\n *\n * @category Auth\n */\nvar AwsSignedBodyValue;\n(function (AwsSignedBodyValue) {\n    /** Use the SHA-256 of the empty string as the canonical request payload value */\n    AwsSignedBodyValue[\"EmptySha256\"] = \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\";\n    /** Use the literal string 'UNSIGNED-PAYLOAD' as the canonical request payload value  */\n    AwsSignedBodyValue[\"UnsignedPayload\"] = \"UNSIGNED-PAYLOAD\";\n    /** Use the literal string 'STREAMING-AWS4-HMAC-SHA256-PAYLOAD' as the canonical request payload value  */\n    AwsSignedBodyValue[\"StreamingAws4HmacSha256Payload\"] = \"STREAMING-AWS4-HMAC-SHA256-PAYLOAD\";\n    /** Use the literal string 'STREAMING-AWS4-HMAC-SHA256-EVENTS' as the canonical request payload value  */\n    AwsSignedBodyValue[\"StreamingAws4HmacSha256Events\"] = \"STREAMING-AWS4-HMAC-SHA256-EVENTS\";\n})(AwsSignedBodyValue = exports.AwsSignedBodyValue || (exports.AwsSignedBodyValue = {}));\n/**\n * AWS signed body header enumeration.\n *\n * @category Auth\n */\nvar AwsSignedBodyHeaderType;\n(function (AwsSignedBodyHeaderType) {\n    /** Do not add a header containing the canonical request payload value */\n    AwsSignedBodyHeaderType[AwsSignedBodyHeaderType[\"None\"] = 0] = \"None\";\n    /** Add the X-Amz-Content-Sha256 header with the canonical request payload value */\n    AwsSignedBodyHeaderType[AwsSignedBodyHeaderType[\"XAmzContentSha256\"] = 1] = \"XAmzContentSha256\";\n})(AwsSignedBodyHeaderType = exports.AwsSignedBodyHeaderType || (exports.AwsSignedBodyHeaderType = {}));\n/**\n * Perform AWS HTTP request signing.\n *\n * The {@link HttpRequest} is transformed asynchronously,\n * according to the {@link AwsSigningConfig}.\n *\n * When signing:\n *  1.  It is good practice to use a new config for each signature,\n *      or the date might get too old.\n *\n *  2.  Do not add the following headers to requests before signing, they may be added by the signer:\n *      x-amz-content-sha256,\n *      X-Amz-Date,\n *      Authorization\n *\n *  3.  Do not add the following query params to requests before signing, they may be added by the signer:\n *      X-Amz-Signature,\n *      X-Amz-Date,\n *      X-Amz-Credential,\n *      X-Amz-Algorithm,\n *      X-Amz-SignedHeaders\n * @param request The HTTP request to sign.\n * @param config Configuration for signing.\n * @returns A promise whose result will be the signed\n *       {@link HttpRequest}. The future will contain an exception\n *       if the signing process fails.\n *\n * @category Auth\n */\nfunction aws_sign_request(request, config) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return new Promise((resolve, reject) => {\n            try {\n                /* Note: if the body of request has not fully loaded, it will lead to an endless loop.\n                 * User should set the signed_body_value of config to prevent this endless loop in this case */\n                binding_1.default.aws_sign_request(request, config, (error_code) => {\n                    if (error_code == 0) {\n                        resolve(request);\n                    }\n                    else {\n                        reject(new error_1.CrtError(error_code));\n                    }\n                });\n            }\n            catch (error) {\n                reject(error);\n            }\n        });\n    });\n}\nexports.aws_sign_request = aws_sign_request;\n/**\n *\n * @internal\n *\n * Test only.\n * Verifies:\n *  (1) The canonical request generated during sigv4a signing of the request matches what is passed in\n *  (2) The signature passed in is a valid ECDSA signature of the hashed string-to-sign derived from the\n *  canonical request\n *\n * @param request The HTTP request to sign.\n * @param config Configuration for signing.\n * @param expected_canonical_request String type of expected canonical request. Refer to XXX(link to doc?)\n * @param signature The generated signature string from {@link aws_sign_request}, which is verified here.\n * @param ecc_key_pub_x the x coordinate of the public part of the ecc key to verify the signature.\n * @param ecc_key_pub_y the y coordinate of the public part of the ecc key to verify the signature\n * @returns True, if the verification succeed. Otherwise, false.\n */\nfunction aws_verify_sigv4a_signing(request, config, expected_canonical_request, signature, ecc_key_pub_x, ecc_key_pub_y) {\n    return binding_1.default.aws_verify_sigv4a_signing(request, config, expected_canonical_request, signature, ecc_key_pub_x, ecc_key_pub_y);\n}\nexports.aws_verify_sigv4a_signing = aws_verify_sigv4a_signing;\n//# sourceMappingURL=auth.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXdzLWNydC9kaXN0L25hdGl2ZS9hdXRoLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUNBQWlDLEdBQUcsd0JBQXdCLEdBQUcsK0JBQStCLEdBQUcsMEJBQTBCLEdBQUcsd0JBQXdCLEdBQUcsMkJBQTJCLEdBQUcsOEJBQThCO0FBQ3JOLGtDQUFrQyxtQkFBTyxDQUFDLHNFQUFXO0FBQ3JELGdCQUFnQixtQkFBTyxDQUFDLGtFQUFTO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQyw0REFBTTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0RBQXdELDJCQUEyQixLQUFLO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0RBQWtELHdCQUF3QixLQUFLO0FBQ2hGO0FBQ0Esd0JBQXdCLHlDQUF5QztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0RBQXNELDBCQUEwQixLQUFLO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdFQUFnRSwrQkFBK0IsS0FBSztBQUNyRztBQUNBO0FBQ0E7QUFDQSxRQUFRLG1CQUFtQjtBQUMzQixxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrQkFBa0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsdUJBQXVCO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGF5d2luZC8uL25vZGVfbW9kdWxlcy9hd3MtY3J0L2Rpc3QvbmF0aXZlL2F1dGguanM/MTE3NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wLlxuICovXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYXdzX3ZlcmlmeV9zaWd2NGFfc2lnbmluZyA9IGV4cG9ydHMuYXdzX3NpZ25fcmVxdWVzdCA9IGV4cG9ydHMuQXdzU2lnbmVkQm9keUhlYWRlclR5cGUgPSBleHBvcnRzLkF3c1NpZ25lZEJvZHlWYWx1ZSA9IGV4cG9ydHMuQXdzU2lnbmF0dXJlVHlwZSA9IGV4cG9ydHMuQXdzU2lnbmluZ0FsZ29yaXRobSA9IGV4cG9ydHMuQXdzQ3JlZGVudGlhbHNQcm92aWRlciA9IHZvaWQgMDtcbmNvbnN0IGJpbmRpbmdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9iaW5kaW5nXCIpKTtcbmNvbnN0IGVycm9yXzEgPSByZXF1aXJlKFwiLi9lcnJvclwiKTtcbmNvbnN0IGlvXzEgPSByZXF1aXJlKFwiLi9pb1wiKTtcbi8qKlxuICogQ3JlZGVudGlhbHMgcHJvdmlkZXJzIHNvdXJjZSB0aGUgQXdzQ3JlZGVudGlhbHMgbmVlZGVkIHRvIHNpZ24gYW4gYXV0aGVudGljYXRlZCBBV1MgcmVxdWVzdC5cbiAqXG4gKiBXZSBkb24ndCBjdXJyZW50bHkgZXhwb3NlIGFuIGludGVyZmFjZSBmb3IgZmV0Y2hpbmcgY3JlZGVudGlhbHMgZnJvbSBKYXZhc2NyaXB0LlxuICpcbiAqIEBjYXRlZ29yeSBBdXRoXG4gKi9cbi8qIFN1YmNsYXNzIGZvciB0aGUgcHVycG9zZSBvZiBleHBvc2luZyBhIG5vbi1OYXRpdmVIYW5kbGUgYmFzZWQgQVBJICovXG5jbGFzcyBBd3NDcmVkZW50aWFsc1Byb3ZpZGVyIGV4dGVuZHMgYmluZGluZ18xLmRlZmF1bHQuQXdzQ3JlZGVudGlhbHNQcm92aWRlciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBkZWZhdWx0IGNyZWRlbnRpYWxzIHByb3ZpZGVyIHRvIGJlIHVzZWQgaW50ZXJuYWxseSBmb3IgQVdTIGNyZWRlbnRpYWxzIHJlc29sdXRpb246XG4gICAgICpcbiAgICAgKiAgIFRoZSBDUlQncyBkZWZhdWx0IHByb3ZpZGVyIGNoYWluIGN1cnJlbnRseSBzb3VyY2VzIGluIHRoaXMgb3JkZXI6XG4gICAgICpcbiAgICAgKiAgICAgMS4gRW52aXJvbm1lbnRcbiAgICAgKiAgICAgMi4gUHJvZmlsZVxuICAgICAqICAgICAzLiAoY29uZGl0aW9uYWwsIG9mZiBieSBkZWZhdWx0KSBFQ1NcbiAgICAgKiAgICAgNC4gKGNvbmRpdGlvbmFsLCBvbiBieSBkZWZhdWx0KSBFQzIgSW5zdGFuY2UgTWV0YWRhdGFcbiAgICAgKlxuICAgICAqIEBwYXJhbSBib290c3RyYXAgKG9wdGlvbmFsKSBjbGllbnQgYm9vdHN0cmFwIHRvIGJlIHVzZWQgdG8gZXN0YWJsaXNoIGFueSByZXF1aXJlZCBuZXR3b3JrIGNvbm5lY3Rpb25zXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBhIG5ldyBjcmVkZW50aWFscyBwcm92aWRlciB1c2luZyBkZWZhdWx0IGNyZWRlbnRpYWxzIHJlc29sdXRpb24gcnVsZXNcbiAgICAgKi9cbiAgICBzdGF0aWMgbmV3RGVmYXVsdChib290c3RyYXAgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLm5ld0RlZmF1bHQoYm9vdHN0cmFwICE9IG51bGwgPyBib290c3RyYXAubmF0aXZlX2hhbmRsZSgpIDogbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgY3JlZGVudGlhbHMgcHJvdmlkZXIgdGhhdCByZXR1cm5zIGEgZml4ZWQgc2V0IG9mIGNyZWRlbnRpYWxzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFjY2Vzc19rZXkgYWNjZXNzIGtleSB0byB1c2UgaW4gdGhlIHN0YXRpYyBjcmVkZW50aWFsc1xuICAgICAqIEBwYXJhbSBzZWNyZXRfa2V5IHNlY3JldCBrZXkgdG8gdXNlIGluIHRoZSBzdGF0aWMgY3JlZGVudGlhbHNcbiAgICAgKiBAcGFyYW0gc2Vzc2lvbl90b2tlbiAob3B0aW9uYWwpIHNlc3Npb24gdG9rZW4gdG8gdXNlIGluIHRoZSBzdGF0aWMgY3JlZGVudGlhbHNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGEgbmV3IGNyZWRlbnRpYWxzIHByb3ZpZGVyIHRoYXQgd2lsbCByZXR1cm4gYSBmaXhlZCBzZXQgb2YgQVdTIGNyZWRlbnRpYWxzXG4gICAgICovXG4gICAgc3RhdGljIG5ld1N0YXRpYyhhY2Nlc3Nfa2V5LCBzZWNyZXRfa2V5LCBzZXNzaW9uX3Rva2VuKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5uZXdTdGF0aWMoYWNjZXNzX2tleSwgc2VjcmV0X2tleSwgc2Vzc2lvbl90b2tlbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgY3JlZGVudGlhbHMgcHJvdmlkZXIgdGhhdCBzb3VyY2VzIGNyZWRlbnRpYWxzIGZyb20gdGhlIEFXUyBDb2duaXRvIElkZW50aXR5IHNlcnZpY2UgdmlhIHRoZVxuICAgICAqIEdldENyZWRlbnRpYWxzRm9ySWRlbnRpdHkgaHR0cCBBUEkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29uZmlnIHByb3ZpZGVyIGNvbmZpZ3VyYXRpb24gbmVjZXNzYXJ5IHRvIG1ha2UgR2V0Q3JlZGVudGlhbHNGb3JJZGVudGl0eSB3ZWIgcmVxdWVzdHNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGEgbmV3IGNyZWRlbnRpYWxzIHByb3ZpZGVyIHRoYXQgcmV0dXJucyBjcmVkZW50aWFscyBzb3VyY2VkIGZyb20gdGhlIEFXUyBDb2duaXRvIElkZW50aXR5IHNlcnZpY2VcbiAgICAgKi9cbiAgICBzdGF0aWMgbmV3Q29nbml0byhjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZyA9PSBudWxsIHx8IGNvbmZpZyA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcl8xLkNydEVycm9yKFwiQXdzQ3JlZGVudGlhbHNQcm92aWRlciBuZXdDb2duaXRvOiBDb2duaXRvIGNvbmZpZyBub3QgZGVmaW5lZFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIubmV3Q29nbml0byhjb25maWcsIGNvbmZpZy50bHNDb250ZXh0ICE9IG51bGwgPyBjb25maWcudGxzQ29udGV4dC5uYXRpdmVfaGFuZGxlKCkgOiBuZXcgaW9fMS5DbGllbnRUbHNDb250ZXh0KCkubmF0aXZlX2hhbmRsZSgpLCBjb25maWcuYm9vdHN0cmFwICE9IG51bGwgPyBjb25maWcuYm9vdHN0cmFwLm5hdGl2ZV9oYW5kbGUoKSA6IG51bGwsIGNvbmZpZy5odHRwUHJveHlPcHRpb25zID8gY29uZmlnLmh0dHBQcm94eU9wdGlvbnMuY3JlYXRlX25hdGl2ZV9oYW5kbGUoKSA6IG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGNyZWRlbnRpYWxzIHByb3ZpZGVyIHRoYXQgc291cmNlcyBjcmVkZW50aWFscyBmcm9tIHRoZSB0aGUgWDUwOSBzZXJ2aWNlIG9uIEFXUyBJb1QgQ29yZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb25maWcgcHJvdmlkZXIgY29uZmlndXJhdGlvbiBuZWNlc3NhcnkgdG8gc291cmNlIGNyZWRlbnRpYWxzIHZpYSBYNTA5XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBhIG5ldyBjcmVkZW50aWFscyBwcm92aWRlciB0aGF0IHJldHVybnMgY3JlZGVudGlhbHMgc291cmNlZCBmcm9tIHRoZSBBV1MgWDUwOSBzZXJ2aWNlXG4gICAgICovXG4gICAgc3RhdGljIG5ld1g1MDkoY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgPT0gbnVsbCB8fCBjb25maWcgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JfMS5DcnRFcnJvcihcIkF3c0NyZWRlbnRpYWxzUHJvdmlkZXIgbmV3WDUwOTogWDUwOSBjb25maWcgbm90IGRlZmluZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLm5ld1g1MDkoY29uZmlnLCBjb25maWcudGxzQ29udGV4dC5uYXRpdmVfaGFuZGxlKCksIGNvbmZpZy5odHRwUHJveHlPcHRpb25zID8gY29uZmlnLmh0dHBQcm94eU9wdGlvbnMuY3JlYXRlX25hdGl2ZV9oYW5kbGUoKSA6IG51bGwpO1xuICAgIH1cbn1cbmV4cG9ydHMuQXdzQ3JlZGVudGlhbHNQcm92aWRlciA9IEF3c0NyZWRlbnRpYWxzUHJvdmlkZXI7XG4vKipcbiAqIEFXUyBzaWduaW5nIGFsZ29yaXRobSBlbnVtZXJhdGlvbi5cbiAqXG4gKiBAY2F0ZWdvcnkgQXV0aFxuICovXG52YXIgQXdzU2lnbmluZ0FsZ29yaXRobTtcbihmdW5jdGlvbiAoQXdzU2lnbmluZ0FsZ29yaXRobSkge1xuICAgIC8qKiBVc2UgdGhlIEF3cyBzaWduYXR1cmUgdmVyc2lvbiA0IHNpZ25pbmcgcHJvY2VzcyB0byBzaWduIHRoZSByZXF1ZXN0ICovXG4gICAgQXdzU2lnbmluZ0FsZ29yaXRobVtBd3NTaWduaW5nQWxnb3JpdGhtW1wiU2lnVjRcIl0gPSAwXSA9IFwiU2lnVjRcIjtcbiAgICAvKiogVXNlIHRoZSBBd3Mgc2lnbmF0dXJlIHZlcnNpb24gNCBBc3ltbWV0cmljIHNpZ25pbmcgcHJvY2VzcyB0byBzaWduIHRoZSByZXF1ZXN0ICovXG4gICAgQXdzU2lnbmluZ0FsZ29yaXRobVtBd3NTaWduaW5nQWxnb3JpdGhtW1wiU2lnVjRBc3ltbWV0cmljXCJdID0gMV0gPSBcIlNpZ1Y0QXN5bW1ldHJpY1wiO1xufSkoQXdzU2lnbmluZ0FsZ29yaXRobSA9IGV4cG9ydHMuQXdzU2lnbmluZ0FsZ29yaXRobSB8fCAoZXhwb3J0cy5Bd3NTaWduaW5nQWxnb3JpdGhtID0ge30pKTtcbi8qKlxuICogQVdTIHNpZ25hdHVyZSB0eXBlIGVudW1lcmF0aW9uLlxuICpcbiAqIEBjYXRlZ29yeSBBdXRoXG4gKi9cbnZhciBBd3NTaWduYXR1cmVUeXBlO1xuKGZ1bmN0aW9uIChBd3NTaWduYXR1cmVUeXBlKSB7XG4gICAgLyoqIFNpZ24gYW4gaHR0cCByZXF1ZXN0IGFuZCBhcHBseSB0aGUgc2lnbmluZyByZXN1bHRzIGFzIGhlYWRlcnMgKi9cbiAgICBBd3NTaWduYXR1cmVUeXBlW0F3c1NpZ25hdHVyZVR5cGVbXCJIdHRwUmVxdWVzdFZpYUhlYWRlcnNcIl0gPSAwXSA9IFwiSHR0cFJlcXVlc3RWaWFIZWFkZXJzXCI7XG4gICAgLyoqIFNpZ24gYW4gaHR0cCByZXF1ZXN0IGFuZCBhcHBseSB0aGUgc2lnbmluZyByZXN1bHRzIGFzIHF1ZXJ5IHBhcmFtcyAqL1xuICAgIEF3c1NpZ25hdHVyZVR5cGVbQXdzU2lnbmF0dXJlVHlwZVtcIkh0dHBSZXF1ZXN0VmlhUXVlcnlQYXJhbXNcIl0gPSAxXSA9IFwiSHR0cFJlcXVlc3RWaWFRdWVyeVBhcmFtc1wiO1xuICAgIC8qKiBTaWduIGFuIGh0dHAgcmVxdWVzdCBwYXlsb2FkIGNodW5rICovXG4gICAgQXdzU2lnbmF0dXJlVHlwZVtBd3NTaWduYXR1cmVUeXBlW1wiSHR0cFJlcXVlc3RDaHVua1wiXSA9IDJdID0gXCJIdHRwUmVxdWVzdENodW5rXCI7XG4gICAgLyoqIFNpZ24gYW4gZXZlbnQgc3RyZWFtIGV2ZW50ICovXG4gICAgQXdzU2lnbmF0dXJlVHlwZVtBd3NTaWduYXR1cmVUeXBlW1wiSHR0cFJlcXVlc3RFdmVudFwiXSA9IDNdID0gXCJIdHRwUmVxdWVzdEV2ZW50XCI7XG59KShBd3NTaWduYXR1cmVUeXBlID0gZXhwb3J0cy5Bd3NTaWduYXR1cmVUeXBlIHx8IChleHBvcnRzLkF3c1NpZ25hdHVyZVR5cGUgPSB7fSkpO1xuLyoqXG4gKiBWYWx1ZXMgZm9yIHVzZSB3aXRoIHtAbGluayBBd3NTaWduaW5nQ29uZmlnLnNpZ25lZF9ib2R5X3ZhbHVlfS5cbiAqXG4gKiBTb21lIHNlcnZpY2VzIHVzZSBzcGVjaWFsIHZhbHVlcyAoZS5nLiAnVU5TSUdORUQtUEFZTE9BRCcpIHdoZW4gdGhlIGJvZHlcbiAqIGlzIG5vdCBiZWluZyBzaWduZWQgaW4gdGhlIHVzdWFsIHdheS5cbiAqXG4gKiBAY2F0ZWdvcnkgQXV0aFxuICovXG52YXIgQXdzU2lnbmVkQm9keVZhbHVlO1xuKGZ1bmN0aW9uIChBd3NTaWduZWRCb2R5VmFsdWUpIHtcbiAgICAvKiogVXNlIHRoZSBTSEEtMjU2IG9mIHRoZSBlbXB0eSBzdHJpbmcgYXMgdGhlIGNhbm9uaWNhbCByZXF1ZXN0IHBheWxvYWQgdmFsdWUgKi9cbiAgICBBd3NTaWduZWRCb2R5VmFsdWVbXCJFbXB0eVNoYTI1NlwiXSA9IFwiZTNiMGM0NDI5OGZjMWMxNDlhZmJmNGM4OTk2ZmI5MjQyN2FlNDFlNDY0OWI5MzRjYTQ5NTk5MWI3ODUyYjg1NVwiO1xuICAgIC8qKiBVc2UgdGhlIGxpdGVyYWwgc3RyaW5nICdVTlNJR05FRC1QQVlMT0FEJyBhcyB0aGUgY2Fub25pY2FsIHJlcXVlc3QgcGF5bG9hZCB2YWx1ZSAgKi9cbiAgICBBd3NTaWduZWRCb2R5VmFsdWVbXCJVbnNpZ25lZFBheWxvYWRcIl0gPSBcIlVOU0lHTkVELVBBWUxPQURcIjtcbiAgICAvKiogVXNlIHRoZSBsaXRlcmFsIHN0cmluZyAnU1RSRUFNSU5HLUFXUzQtSE1BQy1TSEEyNTYtUEFZTE9BRCcgYXMgdGhlIGNhbm9uaWNhbCByZXF1ZXN0IHBheWxvYWQgdmFsdWUgICovXG4gICAgQXdzU2lnbmVkQm9keVZhbHVlW1wiU3RyZWFtaW5nQXdzNEhtYWNTaGEyNTZQYXlsb2FkXCJdID0gXCJTVFJFQU1JTkctQVdTNC1ITUFDLVNIQTI1Ni1QQVlMT0FEXCI7XG4gICAgLyoqIFVzZSB0aGUgbGl0ZXJhbCBzdHJpbmcgJ1NUUkVBTUlORy1BV1M0LUhNQUMtU0hBMjU2LUVWRU5UUycgYXMgdGhlIGNhbm9uaWNhbCByZXF1ZXN0IHBheWxvYWQgdmFsdWUgICovXG4gICAgQXdzU2lnbmVkQm9keVZhbHVlW1wiU3RyZWFtaW5nQXdzNEhtYWNTaGEyNTZFdmVudHNcIl0gPSBcIlNUUkVBTUlORy1BV1M0LUhNQUMtU0hBMjU2LUVWRU5UU1wiO1xufSkoQXdzU2lnbmVkQm9keVZhbHVlID0gZXhwb3J0cy5Bd3NTaWduZWRCb2R5VmFsdWUgfHwgKGV4cG9ydHMuQXdzU2lnbmVkQm9keVZhbHVlID0ge30pKTtcbi8qKlxuICogQVdTIHNpZ25lZCBib2R5IGhlYWRlciBlbnVtZXJhdGlvbi5cbiAqXG4gKiBAY2F0ZWdvcnkgQXV0aFxuICovXG52YXIgQXdzU2lnbmVkQm9keUhlYWRlclR5cGU7XG4oZnVuY3Rpb24gKEF3c1NpZ25lZEJvZHlIZWFkZXJUeXBlKSB7XG4gICAgLyoqIERvIG5vdCBhZGQgYSBoZWFkZXIgY29udGFpbmluZyB0aGUgY2Fub25pY2FsIHJlcXVlc3QgcGF5bG9hZCB2YWx1ZSAqL1xuICAgIEF3c1NpZ25lZEJvZHlIZWFkZXJUeXBlW0F3c1NpZ25lZEJvZHlIZWFkZXJUeXBlW1wiTm9uZVwiXSA9IDBdID0gXCJOb25lXCI7XG4gICAgLyoqIEFkZCB0aGUgWC1BbXotQ29udGVudC1TaGEyNTYgaGVhZGVyIHdpdGggdGhlIGNhbm9uaWNhbCByZXF1ZXN0IHBheWxvYWQgdmFsdWUgKi9cbiAgICBBd3NTaWduZWRCb2R5SGVhZGVyVHlwZVtBd3NTaWduZWRCb2R5SGVhZGVyVHlwZVtcIlhBbXpDb250ZW50U2hhMjU2XCJdID0gMV0gPSBcIlhBbXpDb250ZW50U2hhMjU2XCI7XG59KShBd3NTaWduZWRCb2R5SGVhZGVyVHlwZSA9IGV4cG9ydHMuQXdzU2lnbmVkQm9keUhlYWRlclR5cGUgfHwgKGV4cG9ydHMuQXdzU2lnbmVkQm9keUhlYWRlclR5cGUgPSB7fSkpO1xuLyoqXG4gKiBQZXJmb3JtIEFXUyBIVFRQIHJlcXVlc3Qgc2lnbmluZy5cbiAqXG4gKiBUaGUge0BsaW5rIEh0dHBSZXF1ZXN0fSBpcyB0cmFuc2Zvcm1lZCBhc3luY2hyb25vdXNseSxcbiAqIGFjY29yZGluZyB0byB0aGUge0BsaW5rIEF3c1NpZ25pbmdDb25maWd9LlxuICpcbiAqIFdoZW4gc2lnbmluZzpcbiAqICAxLiAgSXQgaXMgZ29vZCBwcmFjdGljZSB0byB1c2UgYSBuZXcgY29uZmlnIGZvciBlYWNoIHNpZ25hdHVyZSxcbiAqICAgICAgb3IgdGhlIGRhdGUgbWlnaHQgZ2V0IHRvbyBvbGQuXG4gKlxuICogIDIuICBEbyBub3QgYWRkIHRoZSBmb2xsb3dpbmcgaGVhZGVycyB0byByZXF1ZXN0cyBiZWZvcmUgc2lnbmluZywgdGhleSBtYXkgYmUgYWRkZWQgYnkgdGhlIHNpZ25lcjpcbiAqICAgICAgeC1hbXotY29udGVudC1zaGEyNTYsXG4gKiAgICAgIFgtQW16LURhdGUsXG4gKiAgICAgIEF1dGhvcml6YXRpb25cbiAqXG4gKiAgMy4gIERvIG5vdCBhZGQgdGhlIGZvbGxvd2luZyBxdWVyeSBwYXJhbXMgdG8gcmVxdWVzdHMgYmVmb3JlIHNpZ25pbmcsIHRoZXkgbWF5IGJlIGFkZGVkIGJ5IHRoZSBzaWduZXI6XG4gKiAgICAgIFgtQW16LVNpZ25hdHVyZSxcbiAqICAgICAgWC1BbXotRGF0ZSxcbiAqICAgICAgWC1BbXotQ3JlZGVudGlhbCxcbiAqICAgICAgWC1BbXotQWxnb3JpdGhtLFxuICogICAgICBYLUFtei1TaWduZWRIZWFkZXJzXG4gKiBAcGFyYW0gcmVxdWVzdCBUaGUgSFRUUCByZXF1ZXN0IHRvIHNpZ24uXG4gKiBAcGFyYW0gY29uZmlnIENvbmZpZ3VyYXRpb24gZm9yIHNpZ25pbmcuXG4gKiBAcmV0dXJucyBBIHByb21pc2Ugd2hvc2UgcmVzdWx0IHdpbGwgYmUgdGhlIHNpZ25lZFxuICogICAgICAge0BsaW5rIEh0dHBSZXF1ZXN0fS4gVGhlIGZ1dHVyZSB3aWxsIGNvbnRhaW4gYW4gZXhjZXB0aW9uXG4gKiAgICAgICBpZiB0aGUgc2lnbmluZyBwcm9jZXNzIGZhaWxzLlxuICpcbiAqIEBjYXRlZ29yeSBBdXRoXG4gKi9cbmZ1bmN0aW9uIGF3c19zaWduX3JlcXVlc3QocmVxdWVzdCwgY29uZmlnKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLyogTm90ZTogaWYgdGhlIGJvZHkgb2YgcmVxdWVzdCBoYXMgbm90IGZ1bGx5IGxvYWRlZCwgaXQgd2lsbCBsZWFkIHRvIGFuIGVuZGxlc3MgbG9vcC5cbiAgICAgICAgICAgICAgICAgKiBVc2VyIHNob3VsZCBzZXQgdGhlIHNpZ25lZF9ib2R5X3ZhbHVlIG9mIGNvbmZpZyB0byBwcmV2ZW50IHRoaXMgZW5kbGVzcyBsb29wIGluIHRoaXMgY2FzZSAqL1xuICAgICAgICAgICAgICAgIGJpbmRpbmdfMS5kZWZhdWx0LmF3c19zaWduX3JlcXVlc3QocmVxdWVzdCwgY29uZmlnLCAoZXJyb3JfY29kZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JfY29kZSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlcXVlc3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBlcnJvcl8xLkNydEVycm9yKGVycm9yX2NvZGUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnRzLmF3c19zaWduX3JlcXVlc3QgPSBhd3Nfc2lnbl9yZXF1ZXN0O1xuLyoqXG4gKlxuICogQGludGVybmFsXG4gKlxuICogVGVzdCBvbmx5LlxuICogVmVyaWZpZXM6XG4gKiAgKDEpIFRoZSBjYW5vbmljYWwgcmVxdWVzdCBnZW5lcmF0ZWQgZHVyaW5nIHNpZ3Y0YSBzaWduaW5nIG9mIHRoZSByZXF1ZXN0IG1hdGNoZXMgd2hhdCBpcyBwYXNzZWQgaW5cbiAqICAoMikgVGhlIHNpZ25hdHVyZSBwYXNzZWQgaW4gaXMgYSB2YWxpZCBFQ0RTQSBzaWduYXR1cmUgb2YgdGhlIGhhc2hlZCBzdHJpbmctdG8tc2lnbiBkZXJpdmVkIGZyb20gdGhlXG4gKiAgY2Fub25pY2FsIHJlcXVlc3RcbiAqXG4gKiBAcGFyYW0gcmVxdWVzdCBUaGUgSFRUUCByZXF1ZXN0IHRvIHNpZ24uXG4gKiBAcGFyYW0gY29uZmlnIENvbmZpZ3VyYXRpb24gZm9yIHNpZ25pbmcuXG4gKiBAcGFyYW0gZXhwZWN0ZWRfY2Fub25pY2FsX3JlcXVlc3QgU3RyaW5nIHR5cGUgb2YgZXhwZWN0ZWQgY2Fub25pY2FsIHJlcXVlc3QuIFJlZmVyIHRvIFhYWChsaW5rIHRvIGRvYz8pXG4gKiBAcGFyYW0gc2lnbmF0dXJlIFRoZSBnZW5lcmF0ZWQgc2lnbmF0dXJlIHN0cmluZyBmcm9tIHtAbGluayBhd3Nfc2lnbl9yZXF1ZXN0fSwgd2hpY2ggaXMgdmVyaWZpZWQgaGVyZS5cbiAqIEBwYXJhbSBlY2Nfa2V5X3B1Yl94IHRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIHB1YmxpYyBwYXJ0IG9mIHRoZSBlY2Mga2V5IHRvIHZlcmlmeSB0aGUgc2lnbmF0dXJlLlxuICogQHBhcmFtIGVjY19rZXlfcHViX3kgdGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgcHVibGljIHBhcnQgb2YgdGhlIGVjYyBrZXkgdG8gdmVyaWZ5IHRoZSBzaWduYXR1cmVcbiAqIEByZXR1cm5zIFRydWUsIGlmIHRoZSB2ZXJpZmljYXRpb24gc3VjY2VlZC4gT3RoZXJ3aXNlLCBmYWxzZS5cbiAqL1xuZnVuY3Rpb24gYXdzX3ZlcmlmeV9zaWd2NGFfc2lnbmluZyhyZXF1ZXN0LCBjb25maWcsIGV4cGVjdGVkX2Nhbm9uaWNhbF9yZXF1ZXN0LCBzaWduYXR1cmUsIGVjY19rZXlfcHViX3gsIGVjY19rZXlfcHViX3kpIHtcbiAgICByZXR1cm4gYmluZGluZ18xLmRlZmF1bHQuYXdzX3ZlcmlmeV9zaWd2NGFfc2lnbmluZyhyZXF1ZXN0LCBjb25maWcsIGV4cGVjdGVkX2Nhbm9uaWNhbF9yZXF1ZXN0LCBzaWduYXR1cmUsIGVjY19rZXlfcHViX3gsIGVjY19rZXlfcHViX3kpO1xufVxuZXhwb3J0cy5hd3NfdmVyaWZ5X3NpZ3Y0YV9zaWduaW5nID0gYXdzX3ZlcmlmeV9zaWd2NGFfc2lnbmluZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF1dGguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/aws-crt/dist/native/auth.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/aws-crt/dist/native/aws_iot.js":
/*!*****************************************************!*\
  !*** ./node_modules/aws-crt/dist/native/aws_iot.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n * SPDX-License-Identifier: Apache-2.0.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AwsIotMqttConnectionConfigBuilder = void 0;\nconst mqtt_1 = __webpack_require__(/*! ../common/mqtt */ \"(ssr)/./node_modules/aws-crt/dist/common/mqtt.js\");\nconst io = __importStar(__webpack_require__(/*! ./io */ \"(ssr)/./node_modules/aws-crt/dist/native/io.js\"));\nconst io_1 = __webpack_require__(/*! ./io */ \"(ssr)/./node_modules/aws-crt/dist/native/io.js\");\nconst platform = __importStar(__webpack_require__(/*! ../common/platform */ \"(ssr)/./node_modules/aws-crt/dist/common/platform.js\"));\nconst error_1 = __webpack_require__(/*! ./error */ \"(ssr)/./node_modules/aws-crt/dist/native/error.js\");\nconst auth_1 = __webpack_require__(/*! ./auth */ \"(ssr)/./node_modules/aws-crt/dist/native/auth.js\");\nconst iot_shared = __importStar(__webpack_require__(/*! ../common/aws_iot_shared */ \"(ssr)/./node_modules/aws-crt/dist/common/aws_iot_shared.js\"));\n/**\n * Builder functions to create a {@link MqttConnectionConfig} which can then be used to create\n * a {@link MqttClientConnection}, configured for use with AWS IoT.\n *\n * @category IoT\n */\nclass AwsIotMqttConnectionConfigBuilder {\n    constructor(tls_ctx_options) {\n        this.tls_ctx_options = tls_ctx_options;\n        this.params = {\n            client_id: '',\n            host_name: '',\n            socket_options: new io.SocketOptions(),\n            port: 8883,\n            use_websocket: false,\n            clean_session: false,\n            keep_alive: undefined,\n            will: undefined,\n            username: \"\",\n            password: undefined,\n            tls_ctx: undefined,\n            reconnect_min_sec: mqtt_1.DEFAULT_RECONNECT_MIN_SEC,\n            reconnect_max_sec: mqtt_1.DEFAULT_RECONNECT_MAX_SEC\n        };\n        this.is_using_custom_authorizer = false;\n    }\n    /**\n     * Create a new builder with mTLS file paths\n     * @param cert_path - Path to certificate, in PEM format\n     * @param key_path - Path to private key, in PEM format\n     */\n    static new_mtls_builder_from_path(cert_path, key_path) {\n        let builder = new AwsIotMqttConnectionConfigBuilder(io_1.TlsContextOptions.create_client_with_mtls_from_path(cert_path, key_path));\n        builder.params.port = 8883;\n        if (io.is_alpn_available()) {\n            builder.tls_ctx_options.alpn_list.unshift('x-amzn-mqtt-ca');\n        }\n        return builder;\n    }\n    /**\n     * Create a new builder with mTLS cert pair in memory\n     * @param cert - Certificate, in PEM format\n     * @param private_key - Private key, in PEM format\n     */\n    static new_mtls_builder(cert, private_key) {\n        let builder = new AwsIotMqttConnectionConfigBuilder(io_1.TlsContextOptions.create_client_with_mtls(cert, private_key));\n        builder.params.port = 8883;\n        if (io.is_alpn_available()) {\n            builder.tls_ctx_options.alpn_list.unshift('x-amzn-mqtt-ca');\n        }\n        return builder;\n    }\n    /**\n     * Create a new builder with mTLS using a PKCS#11 library for private key operations.\n     *\n     * NOTE: This configuration only works on Unix devices.\n     * @param pkcs11_options - PKCS#11 options.\n     */\n    static new_mtls_pkcs11_builder(pkcs11_options) {\n        let builder = new AwsIotMqttConnectionConfigBuilder(io_1.TlsContextOptions.create_client_with_mtls_pkcs11(pkcs11_options));\n        builder.params.port = 8883;\n        if (io.is_alpn_available()) {\n            builder.tls_ctx_options.alpn_list.unshift('x-amzn-mqtt-ca');\n        }\n        return builder;\n    }\n    /**\n     * Create a new builder with mTLS using a PKCS#12 file for private key operations.\n     *\n     * Note: This configuration only works on MacOS devices.\n     *\n     * @param pkcs12_options - The PKCS#12 options to use in the builder.\n     */\n    static new_mtls_pkcs12_builder(pkcs12_options) {\n        let builder = new AwsIotMqttConnectionConfigBuilder(io_1.TlsContextOptions.create_client_with_mtls_pkcs12_from_path(pkcs12_options.pkcs12_file, pkcs12_options.pkcs12_password));\n        builder.params.port = 8883;\n        if (io.is_alpn_available()) {\n            builder.tls_ctx_options.alpn_list.unshift('x-amzn-mqtt-ca');\n        }\n        return builder;\n    }\n    /**\n     * Create a new builder with mTLS using a certificate in a Windows certificate store.\n     *\n     * NOTE: This configuration only works on Windows devices.\n     * @param certificate_path - Path to certificate in a Windows certificate store.\n     *      The path must use backslashes and end with the certificate's thumbprint.\n     *      Example: `CurrentUser\\MY\\A11F8A9B5DF5B98BA3508FBCA575D09570E0D2C6`\n     */\n    static new_mtls_windows_cert_store_path_builder(certificate_path) {\n        let builder = new AwsIotMqttConnectionConfigBuilder(io_1.TlsContextOptions.create_client_with_mtls_windows_cert_store_path(certificate_path));\n        builder.params.port = 8883;\n        if (io.is_alpn_available()) {\n            builder.tls_ctx_options.alpn_list.unshift('x-amzn-mqtt-ca');\n        }\n        return builder;\n    }\n    /**\n     * Creates a new builder with default Tls options. This requires setting the connection details manually.\n     */\n    static new_default_builder() {\n        let ctx_options = new io.TlsContextOptions();\n        let builder = new AwsIotMqttConnectionConfigBuilder(ctx_options);\n        return builder;\n    }\n    static new_websocket_builder(...args) {\n        return this.new_with_websockets(...args);\n    }\n    static configure_websocket_handshake(builder, options) {\n        if (options) {\n            if (builder == null || builder == undefined) {\n                throw new error_1.CrtError(\"AwsIotMqttConnectionConfigBuilder configure_websocket_handshake: builder not defined\");\n            }\n            builder.params.websocket_handshake_transform = (request, done) => __awaiter(this, void 0, void 0, function* () {\n                var _a, _b, _c;\n                const signing_config = (_b = (_a = options.create_signing_config) === null || _a === void 0 ? void 0 : _a.call(options)) !== null && _b !== void 0 ? _b : {\n                    algorithm: auth_1.AwsSigningAlgorithm.SigV4,\n                    signature_type: auth_1.AwsSignatureType.HttpRequestViaQueryParams,\n                    provider: options.credentials_provider,\n                    region: options.region,\n                    service: (_c = options.service) !== null && _c !== void 0 ? _c : \"iotdevicegateway\",\n                    signed_body_value: auth_1.AwsSignedBodyValue.EmptySha256,\n                    omit_session_token: true,\n                };\n                try {\n                    yield (0, auth_1.aws_sign_request)(request, signing_config);\n                    done();\n                }\n                catch (error) {\n                    if (error instanceof error_1.CrtError) {\n                        done(error.error_code);\n                    }\n                    else {\n                        done(3); /* TODO: AWS_ERROR_UNKNOWN */\n                    }\n                }\n            });\n        }\n        return builder;\n    }\n    /**\n     * Configures the connection to use MQTT over websockets. Forces the port to 443.\n     */\n    static new_with_websockets(options) {\n        let tls_ctx_options = options === null || options === void 0 ? void 0 : options.tls_ctx_options;\n        if (!tls_ctx_options) {\n            tls_ctx_options = new io_1.TlsContextOptions();\n            tls_ctx_options.alpn_list = [];\n        }\n        let builder = new AwsIotMqttConnectionConfigBuilder(tls_ctx_options);\n        builder.params.use_websocket = true;\n        builder.params.proxy_options = options === null || options === void 0 ? void 0 : options.proxy_options;\n        if (builder.tls_ctx_options) {\n            builder.params.port = 443;\n        }\n        this.configure_websocket_handshake(builder, options);\n        return builder;\n    }\n    /**\n     * For API compatibility with the browser version. Alias for {@link new_with_websockets}.\n     *\n     * @returns a new websocket connection builder object with default TLS configuration\n     */\n    static new_builder_for_websocket() {\n        return this.new_with_websockets();\n    }\n    /**\n     * Overrides the default system trust store.\n     * @param ca_dirpath - Only used on Unix-style systems where all trust anchors are\n     * stored in a directory (e.g. /etc/ssl/certs).\n     * @param ca_filepath - Single file containing all trust CAs, in PEM format\n     */\n    with_certificate_authority_from_path(ca_dirpath, ca_filepath) {\n        this.tls_ctx_options.override_default_trust_store_from_path(ca_dirpath, ca_filepath);\n        return this;\n    }\n    /**\n     * Overrides the default system trust store.\n     * @param ca - Buffer containing all trust CAs, in PEM format\n     */\n    with_certificate_authority(ca) {\n        this.tls_ctx_options.override_default_trust_store(ca);\n        return this;\n    }\n    /**\n     * Configures the IoT endpoint for this connection\n     * @param endpoint The IoT endpoint to connect to\n     */\n    with_endpoint(endpoint) {\n        this.params.host_name = endpoint;\n        return this;\n    }\n    /**\n     * The port to connect to on the IoT endpoint\n     * @param port The port to connect to on the IoT endpoint. Usually 8883 for MQTT, or 443 for websockets\n     */\n    with_port(port) {\n        this.params.port = port;\n        return this;\n    }\n    /**\n     * Configures the client_id to use to connect to the IoT Core service\n     * @param client_id The client id for this connection. Needs to be unique across all devices/clients.\n     */\n    with_client_id(client_id) {\n        this.params.client_id = client_id;\n        return this;\n    }\n    /**\n     * Determines whether or not the service should try to resume prior subscriptions, if it has any\n     * @param clean_session true if the session should drop prior subscriptions when this client connects, false to resume the session\n     */\n    with_clean_session(clean_session) {\n        this.params.clean_session = clean_session;\n        return this;\n    }\n    /**\n     * Configures MQTT keep-alive via PING messages. Note that this is not TCP keepalive.\n     * @param keep_alive How often in seconds to send an MQTT PING message to the service to keep the connection alive\n     */\n    with_keep_alive_seconds(keep_alive) {\n        this.params.keep_alive = keep_alive;\n        return this;\n    }\n    /**\n     * Configures the TCP socket timeout (in milliseconds)\n     * @param timeout_ms TCP socket timeout\n     * @deprecated\n     */\n    with_timeout_ms(timeout_ms) {\n        this.with_ping_timeout_ms(timeout_ms);\n        return this;\n    }\n    /**\n     * Configures the PINGREQ response timeout (in milliseconds)\n     * @param ping_timeout PINGREQ response timeout\n     */\n    with_ping_timeout_ms(ping_timeout) {\n        this.params.ping_timeout = ping_timeout;\n        return this;\n    }\n    /**\n     * Configures the protocol operation timeout (in milliseconds)\n     * @param protocol_operation_timeout protocol operation timeout\n     */\n    with_protocol_operation_timeout_ms(protocol_operation_timeout) {\n        this.params.protocol_operation_timeout = protocol_operation_timeout;\n        return this;\n    }\n    /**\n     * Configures the will message to be sent when this client disconnects\n     * @param will The will topic, qos, and message\n     */\n    with_will(will) {\n        this.params.will = will;\n        return this;\n    }\n    /**\n     * Configures the common settings for the socket to use when opening a connection to the server\n     * @param socket_options The socket settings\n     */\n    with_socket_options(socket_options) {\n        this.params.socket_options = socket_options;\n        return this;\n    }\n    /**\n     * Configures AWS credentials (usually from Cognito) for this connection\n     * @param aws_region The service region to connect to\n     * @param aws_access_id IAM Access ID\n     * @param aws_secret_key IAM Secret Key\n     * @param aws_sts_token STS token from Cognito (optional)\n     */\n    with_credentials(aws_region, aws_access_id, aws_secret_key, aws_sts_token) {\n        return AwsIotMqttConnectionConfigBuilder.configure_websocket_handshake(this, {\n            credentials_provider: auth_1.AwsCredentialsProvider.newStatic(aws_access_id, aws_secret_key, aws_sts_token),\n            region: aws_region,\n            service: \"iotdevicegateway\",\n        });\n    }\n    /**\n     * Configure the http proxy options to use to establish the connection\n     * @param proxy_options proxy options to use to establish the mqtt connection\n     */\n    with_http_proxy_options(proxy_options) {\n        this.params.proxy_options = proxy_options;\n        return this;\n    }\n    /**\n     * Sets the custom authorizer settings. This function will modify the username, port, and TLS options.\n     *\n     * @param username The username to use with the custom authorizer. If an empty string is passed, it will\n     *                 check to see if a username has already been set (via WithUsername function). If no\n     *                 username is set then no username will be passed with the MQTT connection.\n     * @param authorizer_name The name of the custom authorizer. If an empty string is passed, then\n     *                       'x-amz-customauthorizer-name' will not be added with the MQTT connection.\n     * @param authorizer_signature The signature of the custom authorizer. If an empty string is passed, then\n     *                            'x-amz-customauthorizer-signature' will not be added with the MQTT connection.\n     *                            The signature must be based on the private key associated with the custom authorizer.\n     *                            The signature must be base64 encoded.\n     *                            Required if the custom authorizer has signing enabled.  It is strongly suggested to URL-encode\n     *                            this value; the SDK will not do so for you.\n     * @param password The password to use with the custom authorizer. If null is passed, then no password will\n     *                 be set.\n     * @param token_key_name Key used to extract the custom authorizer token from MQTT username query-string properties.\n     *                       Required if the custom authorizer has signing enabled.  It is strongly suggested to URL-encode\n     *                       this value; the SDK will not do so for you.\n     * @param token_value An opaque token value.\n     *                    Required if the custom authorizer has signing enabled. This value must be signed by the private\n     *                    key associated with the custom authorizer and the result placed in the token_signature argument.\n     */\n    with_custom_authorizer(username, authorizer_name, authorizer_signature, password, token_key_name, token_value) {\n        this.is_using_custom_authorizer = true;\n        let username_string = iot_shared.populate_username_string_with_custom_authorizer(\"\", username, authorizer_name, authorizer_signature, this.params.username, token_key_name, token_value);\n        this.params.username = username_string;\n        this.params.password = password;\n        if (!this.params.use_websocket) {\n            this.tls_ctx_options.alpn_list = [\"mqtt\"];\n        }\n        this.params.port = 443;\n        return this;\n    }\n    /**\n     * Sets username for the connection\n     *\n     * @param username the username that will be passed with the MQTT connection\n     */\n    with_username(username) {\n        this.params.username = username;\n        return this;\n    }\n    /**\n     * Sets password for the connection\n     *\n     * @param password the password that will be passed with the MQTT connection\n     */\n    with_password(password) {\n        this.params.password = password;\n        return this;\n    }\n    /**\n     * Configure the max reconnection period (in second). The reonnection period will\n     * be set in range of [reconnect_min_sec,reconnect_max_sec].\n     * @param reconnect_max_sec max reconnection period\n     */\n    with_reconnect_max_sec(max_sec) {\n        this.params.reconnect_max_sec = max_sec;\n        return this;\n    }\n    /**\n     * Configure the min reconnection period (in second). The reonnection period will\n     * be set in range of [reconnect_min_sec,reconnect_max_sec].\n     * @param reconnect_min_sec min reconnection period\n     */\n    with_reconnect_min_sec(min_sec) {\n        this.params.reconnect_min_sec = min_sec;\n        return this;\n    }\n    /**\n     * Returns the configured MqttConnectionConfig.  On the first invocation of this function, the TLS context is cached\n     * and re-used on all subsequent calls to build().\n     * @returns The configured MqttConnectionConfig\n     */\n    build() {\n        var _a, _b, _c;\n        if (this.params.client_id === undefined || this.params.host_name === undefined) {\n            throw 'client_id and endpoint are required';\n        }\n        // Check to see if a custom authorizer is being used but not through the builder\n        if (this.is_using_custom_authorizer == false) {\n            if (iot_shared.is_string_and_not_empty(this.params.username)) {\n                if (((_a = this.params.username) === null || _a === void 0 ? void 0 : _a.indexOf(\"x-amz-customauthorizer-name=\")) != -1 || ((_b = this.params.username) === null || _b === void 0 ? void 0 : _b.indexOf(\"x-amz-customauthorizer-signature=\")) != -1) {\n                    this.is_using_custom_authorizer = true;\n                }\n            }\n        }\n        // Is the user trying to connect using a custom authorizer?\n        if (this.is_using_custom_authorizer == true) {\n            if (this.params.port != 443) {\n                console.log(\"Warning: Attempting to connect to authorizer with unsupported port. Port is not 443...\");\n            }\n        }\n        /*\n         * By caching and reusing the TLS context we get an enormous memory savings on a per-connection basis.\n         * The tradeoff is that you can't modify TLS options in between calls to build.\n         * Previously we were making a new one with every single connection which had a huge negative impact on large\n         * scale tests.\n         */\n        if (this.params.tls_ctx === undefined) {\n            this.params.tls_ctx = new io.ClientTlsContext(this.tls_ctx_options);\n        }\n        // Add the metrics string\n        if (iot_shared.is_string_and_not_empty(this.params.username) == false) {\n            this.params.username = \"?SDK=NodeJSv2&Version=\";\n        }\n        else {\n            if (((_c = this.params.username) === null || _c === void 0 ? void 0 : _c.indexOf(\"?\")) != -1) {\n                this.params.username += \"&SDK=NodeJSv2&Version=\";\n            }\n            else {\n                this.params.username += \"?SDK=NodeJSv2&Version=\";\n            }\n        }\n        this.params.username += platform.crt_version();\n        return this.params;\n    }\n}\nexports.AwsIotMqttConnectionConfigBuilder = AwsIotMqttConnectionConfigBuilder;\n//# sourceMappingURL=aws_iot.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXdzLWNydC9kaXN0L25hdGl2ZS9hd3NfaW90LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5Q0FBeUM7QUFDekMsZUFBZSxtQkFBTyxDQUFDLHdFQUFnQjtBQUN2Qyx3QkFBd0IsbUJBQU8sQ0FBQyw0REFBTTtBQUN0QyxhQUFhLG1CQUFPLENBQUMsNERBQU07QUFDM0IsOEJBQThCLG1CQUFPLENBQUMsZ0ZBQW9CO0FBQzFELGdCQUFnQixtQkFBTyxDQUFDLGtFQUFTO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQyxnRUFBUTtBQUMvQixnQ0FBZ0MsbUJBQU8sQ0FBQyw0RkFBMEI7QUFDbEU7QUFDQSxrQ0FBa0MsNEJBQTRCO0FBQzlELE1BQU0sMkJBQTJCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsMEJBQTBCO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QyIsInNvdXJjZXMiOlsid2VicGFjazovL3BheXdpbmQvLi9ub2RlX21vZHVsZXMvYXdzLWNydC9kaXN0L25hdGl2ZS9hd3NfaW90LmpzP2YyMzAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IEFtYXpvbi5jb20sIEluYy4gb3IgaXRzIGFmZmlsaWF0ZXMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMC5cbiAqL1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXdzSW90TXF0dENvbm5lY3Rpb25Db25maWdCdWlsZGVyID0gdm9pZCAwO1xuY29uc3QgbXF0dF8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9tcXR0XCIpO1xuY29uc3QgaW8gPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vaW9cIikpO1xuY29uc3QgaW9fMSA9IHJlcXVpcmUoXCIuL2lvXCIpO1xuY29uc3QgcGxhdGZvcm0gPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL2NvbW1vbi9wbGF0Zm9ybVwiKSk7XG5jb25zdCBlcnJvcl8xID0gcmVxdWlyZShcIi4vZXJyb3JcIik7XG5jb25zdCBhdXRoXzEgPSByZXF1aXJlKFwiLi9hdXRoXCIpO1xuY29uc3QgaW90X3NoYXJlZCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vY29tbW9uL2F3c19pb3Rfc2hhcmVkXCIpKTtcbi8qKlxuICogQnVpbGRlciBmdW5jdGlvbnMgdG8gY3JlYXRlIGEge0BsaW5rIE1xdHRDb25uZWN0aW9uQ29uZmlnfSB3aGljaCBjYW4gdGhlbiBiZSB1c2VkIHRvIGNyZWF0ZVxuICogYSB7QGxpbmsgTXF0dENsaWVudENvbm5lY3Rpb259LCBjb25maWd1cmVkIGZvciB1c2Ugd2l0aCBBV1MgSW9ULlxuICpcbiAqIEBjYXRlZ29yeSBJb1RcbiAqL1xuY2xhc3MgQXdzSW90TXF0dENvbm5lY3Rpb25Db25maWdCdWlsZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih0bHNfY3R4X29wdGlvbnMpIHtcbiAgICAgICAgdGhpcy50bHNfY3R4X29wdGlvbnMgPSB0bHNfY3R4X29wdGlvbnM7XG4gICAgICAgIHRoaXMucGFyYW1zID0ge1xuICAgICAgICAgICAgY2xpZW50X2lkOiAnJyxcbiAgICAgICAgICAgIGhvc3RfbmFtZTogJycsXG4gICAgICAgICAgICBzb2NrZXRfb3B0aW9uczogbmV3IGlvLlNvY2tldE9wdGlvbnMoKSxcbiAgICAgICAgICAgIHBvcnQ6IDg4ODMsXG4gICAgICAgICAgICB1c2Vfd2Vic29ja2V0OiBmYWxzZSxcbiAgICAgICAgICAgIGNsZWFuX3Nlc3Npb246IGZhbHNlLFxuICAgICAgICAgICAga2VlcF9hbGl2ZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgd2lsbDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgdXNlcm5hbWU6IFwiXCIsXG4gICAgICAgICAgICBwYXNzd29yZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgdGxzX2N0eDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcmVjb25uZWN0X21pbl9zZWM6IG1xdHRfMS5ERUZBVUxUX1JFQ09OTkVDVF9NSU5fU0VDLFxuICAgICAgICAgICAgcmVjb25uZWN0X21heF9zZWM6IG1xdHRfMS5ERUZBVUxUX1JFQ09OTkVDVF9NQVhfU0VDXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaXNfdXNpbmdfY3VzdG9tX2F1dGhvcml6ZXIgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGJ1aWxkZXIgd2l0aCBtVExTIGZpbGUgcGF0aHNcbiAgICAgKiBAcGFyYW0gY2VydF9wYXRoIC0gUGF0aCB0byBjZXJ0aWZpY2F0ZSwgaW4gUEVNIGZvcm1hdFxuICAgICAqIEBwYXJhbSBrZXlfcGF0aCAtIFBhdGggdG8gcHJpdmF0ZSBrZXksIGluIFBFTSBmb3JtYXRcbiAgICAgKi9cbiAgICBzdGF0aWMgbmV3X210bHNfYnVpbGRlcl9mcm9tX3BhdGgoY2VydF9wYXRoLCBrZXlfcGF0aCkge1xuICAgICAgICBsZXQgYnVpbGRlciA9IG5ldyBBd3NJb3RNcXR0Q29ubmVjdGlvbkNvbmZpZ0J1aWxkZXIoaW9fMS5UbHNDb250ZXh0T3B0aW9ucy5jcmVhdGVfY2xpZW50X3dpdGhfbXRsc19mcm9tX3BhdGgoY2VydF9wYXRoLCBrZXlfcGF0aCkpO1xuICAgICAgICBidWlsZGVyLnBhcmFtcy5wb3J0ID0gODg4MztcbiAgICAgICAgaWYgKGlvLmlzX2FscG5fYXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgIGJ1aWxkZXIudGxzX2N0eF9vcHRpb25zLmFscG5fbGlzdC51bnNoaWZ0KCd4LWFtem4tbXF0dC1jYScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWlsZGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgYnVpbGRlciB3aXRoIG1UTFMgY2VydCBwYWlyIGluIG1lbW9yeVxuICAgICAqIEBwYXJhbSBjZXJ0IC0gQ2VydGlmaWNhdGUsIGluIFBFTSBmb3JtYXRcbiAgICAgKiBAcGFyYW0gcHJpdmF0ZV9rZXkgLSBQcml2YXRlIGtleSwgaW4gUEVNIGZvcm1hdFxuICAgICAqL1xuICAgIHN0YXRpYyBuZXdfbXRsc19idWlsZGVyKGNlcnQsIHByaXZhdGVfa2V5KSB7XG4gICAgICAgIGxldCBidWlsZGVyID0gbmV3IEF3c0lvdE1xdHRDb25uZWN0aW9uQ29uZmlnQnVpbGRlcihpb18xLlRsc0NvbnRleHRPcHRpb25zLmNyZWF0ZV9jbGllbnRfd2l0aF9tdGxzKGNlcnQsIHByaXZhdGVfa2V5KSk7XG4gICAgICAgIGJ1aWxkZXIucGFyYW1zLnBvcnQgPSA4ODgzO1xuICAgICAgICBpZiAoaW8uaXNfYWxwbl9hdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgYnVpbGRlci50bHNfY3R4X29wdGlvbnMuYWxwbl9saXN0LnVuc2hpZnQoJ3gtYW16bi1tcXR0LWNhJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1aWxkZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBidWlsZGVyIHdpdGggbVRMUyB1c2luZyBhIFBLQ1MjMTEgbGlicmFyeSBmb3IgcHJpdmF0ZSBrZXkgb3BlcmF0aW9ucy5cbiAgICAgKlxuICAgICAqIE5PVEU6IFRoaXMgY29uZmlndXJhdGlvbiBvbmx5IHdvcmtzIG9uIFVuaXggZGV2aWNlcy5cbiAgICAgKiBAcGFyYW0gcGtjczExX29wdGlvbnMgLSBQS0NTIzExIG9wdGlvbnMuXG4gICAgICovXG4gICAgc3RhdGljIG5ld19tdGxzX3BrY3MxMV9idWlsZGVyKHBrY3MxMV9vcHRpb25zKSB7XG4gICAgICAgIGxldCBidWlsZGVyID0gbmV3IEF3c0lvdE1xdHRDb25uZWN0aW9uQ29uZmlnQnVpbGRlcihpb18xLlRsc0NvbnRleHRPcHRpb25zLmNyZWF0ZV9jbGllbnRfd2l0aF9tdGxzX3BrY3MxMShwa2NzMTFfb3B0aW9ucykpO1xuICAgICAgICBidWlsZGVyLnBhcmFtcy5wb3J0ID0gODg4MztcbiAgICAgICAgaWYgKGlvLmlzX2FscG5fYXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgIGJ1aWxkZXIudGxzX2N0eF9vcHRpb25zLmFscG5fbGlzdC51bnNoaWZ0KCd4LWFtem4tbXF0dC1jYScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWlsZGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgYnVpbGRlciB3aXRoIG1UTFMgdXNpbmcgYSBQS0NTIzEyIGZpbGUgZm9yIHByaXZhdGUga2V5IG9wZXJhdGlvbnMuXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGlzIGNvbmZpZ3VyYXRpb24gb25seSB3b3JrcyBvbiBNYWNPUyBkZXZpY2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBrY3MxMl9vcHRpb25zIC0gVGhlIFBLQ1MjMTIgb3B0aW9ucyB0byB1c2UgaW4gdGhlIGJ1aWxkZXIuXG4gICAgICovXG4gICAgc3RhdGljIG5ld19tdGxzX3BrY3MxMl9idWlsZGVyKHBrY3MxMl9vcHRpb25zKSB7XG4gICAgICAgIGxldCBidWlsZGVyID0gbmV3IEF3c0lvdE1xdHRDb25uZWN0aW9uQ29uZmlnQnVpbGRlcihpb18xLlRsc0NvbnRleHRPcHRpb25zLmNyZWF0ZV9jbGllbnRfd2l0aF9tdGxzX3BrY3MxMl9mcm9tX3BhdGgocGtjczEyX29wdGlvbnMucGtjczEyX2ZpbGUsIHBrY3MxMl9vcHRpb25zLnBrY3MxMl9wYXNzd29yZCkpO1xuICAgICAgICBidWlsZGVyLnBhcmFtcy5wb3J0ID0gODg4MztcbiAgICAgICAgaWYgKGlvLmlzX2FscG5fYXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgIGJ1aWxkZXIudGxzX2N0eF9vcHRpb25zLmFscG5fbGlzdC51bnNoaWZ0KCd4LWFtem4tbXF0dC1jYScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWlsZGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgYnVpbGRlciB3aXRoIG1UTFMgdXNpbmcgYSBjZXJ0aWZpY2F0ZSBpbiBhIFdpbmRvd3MgY2VydGlmaWNhdGUgc3RvcmUuXG4gICAgICpcbiAgICAgKiBOT1RFOiBUaGlzIGNvbmZpZ3VyYXRpb24gb25seSB3b3JrcyBvbiBXaW5kb3dzIGRldmljZXMuXG4gICAgICogQHBhcmFtIGNlcnRpZmljYXRlX3BhdGggLSBQYXRoIHRvIGNlcnRpZmljYXRlIGluIGEgV2luZG93cyBjZXJ0aWZpY2F0ZSBzdG9yZS5cbiAgICAgKiAgICAgIFRoZSBwYXRoIG11c3QgdXNlIGJhY2tzbGFzaGVzIGFuZCBlbmQgd2l0aCB0aGUgY2VydGlmaWNhdGUncyB0aHVtYnByaW50LlxuICAgICAqICAgICAgRXhhbXBsZTogYEN1cnJlbnRVc2VyXFxNWVxcQTExRjhBOUI1REY1Qjk4QkEzNTA4RkJDQTU3NUQwOTU3MEUwRDJDNmBcbiAgICAgKi9cbiAgICBzdGF0aWMgbmV3X210bHNfd2luZG93c19jZXJ0X3N0b3JlX3BhdGhfYnVpbGRlcihjZXJ0aWZpY2F0ZV9wYXRoKSB7XG4gICAgICAgIGxldCBidWlsZGVyID0gbmV3IEF3c0lvdE1xdHRDb25uZWN0aW9uQ29uZmlnQnVpbGRlcihpb18xLlRsc0NvbnRleHRPcHRpb25zLmNyZWF0ZV9jbGllbnRfd2l0aF9tdGxzX3dpbmRvd3NfY2VydF9zdG9yZV9wYXRoKGNlcnRpZmljYXRlX3BhdGgpKTtcbiAgICAgICAgYnVpbGRlci5wYXJhbXMucG9ydCA9IDg4ODM7XG4gICAgICAgIGlmIChpby5pc19hbHBuX2F2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICBidWlsZGVyLnRsc19jdHhfb3B0aW9ucy5hbHBuX2xpc3QudW5zaGlmdCgneC1hbXpuLW1xdHQtY2EnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVpbGRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBidWlsZGVyIHdpdGggZGVmYXVsdCBUbHMgb3B0aW9ucy4gVGhpcyByZXF1aXJlcyBzZXR0aW5nIHRoZSBjb25uZWN0aW9uIGRldGFpbHMgbWFudWFsbHkuXG4gICAgICovXG4gICAgc3RhdGljIG5ld19kZWZhdWx0X2J1aWxkZXIoKSB7XG4gICAgICAgIGxldCBjdHhfb3B0aW9ucyA9IG5ldyBpby5UbHNDb250ZXh0T3B0aW9ucygpO1xuICAgICAgICBsZXQgYnVpbGRlciA9IG5ldyBBd3NJb3RNcXR0Q29ubmVjdGlvbkNvbmZpZ0J1aWxkZXIoY3R4X29wdGlvbnMpO1xuICAgICAgICByZXR1cm4gYnVpbGRlcjtcbiAgICB9XG4gICAgc3RhdGljIG5ld193ZWJzb2NrZXRfYnVpbGRlciguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5ld193aXRoX3dlYnNvY2tldHMoLi4uYXJncyk7XG4gICAgfVxuICAgIHN0YXRpYyBjb25maWd1cmVfd2Vic29ja2V0X2hhbmRzaGFrZShidWlsZGVyLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoYnVpbGRlciA9PSBudWxsIHx8IGJ1aWxkZXIgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yXzEuQ3J0RXJyb3IoXCJBd3NJb3RNcXR0Q29ubmVjdGlvbkNvbmZpZ0J1aWxkZXIgY29uZmlndXJlX3dlYnNvY2tldF9oYW5kc2hha2U6IGJ1aWxkZXIgbm90IGRlZmluZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWlsZGVyLnBhcmFtcy53ZWJzb2NrZXRfaGFuZHNoYWtlX3RyYW5zZm9ybSA9IChyZXF1ZXN0LCBkb25lKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2lnbmluZ19jb25maWcgPSAoX2IgPSAoX2EgPSBvcHRpb25zLmNyZWF0ZV9zaWduaW5nX2NvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwob3B0aW9ucykpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHtcbiAgICAgICAgICAgICAgICAgICAgYWxnb3JpdGhtOiBhdXRoXzEuQXdzU2lnbmluZ0FsZ29yaXRobS5TaWdWNCxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlX3R5cGU6IGF1dGhfMS5Bd3NTaWduYXR1cmVUeXBlLkh0dHBSZXF1ZXN0VmlhUXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyOiBvcHRpb25zLmNyZWRlbnRpYWxzX3Byb3ZpZGVyLFxuICAgICAgICAgICAgICAgICAgICByZWdpb246IG9wdGlvbnMucmVnaW9uLFxuICAgICAgICAgICAgICAgICAgICBzZXJ2aWNlOiAoX2MgPSBvcHRpb25zLnNlcnZpY2UpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFwiaW90ZGV2aWNlZ2F0ZXdheVwiLFxuICAgICAgICAgICAgICAgICAgICBzaWduZWRfYm9keV92YWx1ZTogYXV0aF8xLkF3c1NpZ25lZEJvZHlWYWx1ZS5FbXB0eVNoYTI1NixcbiAgICAgICAgICAgICAgICAgICAgb21pdF9zZXNzaW9uX3Rva2VuOiB0cnVlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgKDAsIGF1dGhfMS5hd3Nfc2lnbl9yZXF1ZXN0KShyZXF1ZXN0LCBzaWduaW5nX2NvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIGVycm9yXzEuQ3J0RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoZXJyb3IuZXJyb3JfY29kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lKDMpOyAvKiBUT0RPOiBBV1NfRVJST1JfVU5LTk9XTiAqL1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1aWxkZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyZXMgdGhlIGNvbm5lY3Rpb24gdG8gdXNlIE1RVFQgb3ZlciB3ZWJzb2NrZXRzLiBGb3JjZXMgdGhlIHBvcnQgdG8gNDQzLlxuICAgICAqL1xuICAgIHN0YXRpYyBuZXdfd2l0aF93ZWJzb2NrZXRzKG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IHRsc19jdHhfb3B0aW9ucyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50bHNfY3R4X29wdGlvbnM7XG4gICAgICAgIGlmICghdGxzX2N0eF9vcHRpb25zKSB7XG4gICAgICAgICAgICB0bHNfY3R4X29wdGlvbnMgPSBuZXcgaW9fMS5UbHNDb250ZXh0T3B0aW9ucygpO1xuICAgICAgICAgICAgdGxzX2N0eF9vcHRpb25zLmFscG5fbGlzdCA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGxldCBidWlsZGVyID0gbmV3IEF3c0lvdE1xdHRDb25uZWN0aW9uQ29uZmlnQnVpbGRlcih0bHNfY3R4X29wdGlvbnMpO1xuICAgICAgICBidWlsZGVyLnBhcmFtcy51c2Vfd2Vic29ja2V0ID0gdHJ1ZTtcbiAgICAgICAgYnVpbGRlci5wYXJhbXMucHJveHlfb3B0aW9ucyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wcm94eV9vcHRpb25zO1xuICAgICAgICBpZiAoYnVpbGRlci50bHNfY3R4X29wdGlvbnMpIHtcbiAgICAgICAgICAgIGJ1aWxkZXIucGFyYW1zLnBvcnQgPSA0NDM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25maWd1cmVfd2Vic29ja2V0X2hhbmRzaGFrZShidWlsZGVyLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIGJ1aWxkZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvciBBUEkgY29tcGF0aWJpbGl0eSB3aXRoIHRoZSBicm93c2VyIHZlcnNpb24uIEFsaWFzIGZvciB7QGxpbmsgbmV3X3dpdGhfd2Vic29ja2V0c30uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBhIG5ldyB3ZWJzb2NrZXQgY29ubmVjdGlvbiBidWlsZGVyIG9iamVjdCB3aXRoIGRlZmF1bHQgVExTIGNvbmZpZ3VyYXRpb25cbiAgICAgKi9cbiAgICBzdGF0aWMgbmV3X2J1aWxkZXJfZm9yX3dlYnNvY2tldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV3X3dpdGhfd2Vic29ja2V0cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgdGhlIGRlZmF1bHQgc3lzdGVtIHRydXN0IHN0b3JlLlxuICAgICAqIEBwYXJhbSBjYV9kaXJwYXRoIC0gT25seSB1c2VkIG9uIFVuaXgtc3R5bGUgc3lzdGVtcyB3aGVyZSBhbGwgdHJ1c3QgYW5jaG9ycyBhcmVcbiAgICAgKiBzdG9yZWQgaW4gYSBkaXJlY3RvcnkgKGUuZy4gL2V0Yy9zc2wvY2VydHMpLlxuICAgICAqIEBwYXJhbSBjYV9maWxlcGF0aCAtIFNpbmdsZSBmaWxlIGNvbnRhaW5pbmcgYWxsIHRydXN0IENBcywgaW4gUEVNIGZvcm1hdFxuICAgICAqL1xuICAgIHdpdGhfY2VydGlmaWNhdGVfYXV0aG9yaXR5X2Zyb21fcGF0aChjYV9kaXJwYXRoLCBjYV9maWxlcGF0aCkge1xuICAgICAgICB0aGlzLnRsc19jdHhfb3B0aW9ucy5vdmVycmlkZV9kZWZhdWx0X3RydXN0X3N0b3JlX2Zyb21fcGF0aChjYV9kaXJwYXRoLCBjYV9maWxlcGF0aCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgdGhlIGRlZmF1bHQgc3lzdGVtIHRydXN0IHN0b3JlLlxuICAgICAqIEBwYXJhbSBjYSAtIEJ1ZmZlciBjb250YWluaW5nIGFsbCB0cnVzdCBDQXMsIGluIFBFTSBmb3JtYXRcbiAgICAgKi9cbiAgICB3aXRoX2NlcnRpZmljYXRlX2F1dGhvcml0eShjYSkge1xuICAgICAgICB0aGlzLnRsc19jdHhfb3B0aW9ucy5vdmVycmlkZV9kZWZhdWx0X3RydXN0X3N0b3JlKGNhKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyZXMgdGhlIElvVCBlbmRwb2ludCBmb3IgdGhpcyBjb25uZWN0aW9uXG4gICAgICogQHBhcmFtIGVuZHBvaW50IFRoZSBJb1QgZW5kcG9pbnQgdG8gY29ubmVjdCB0b1xuICAgICAqL1xuICAgIHdpdGhfZW5kcG9pbnQoZW5kcG9pbnQpIHtcbiAgICAgICAgdGhpcy5wYXJhbXMuaG9zdF9uYW1lID0gZW5kcG9pbnQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgcG9ydCB0byBjb25uZWN0IHRvIG9uIHRoZSBJb1QgZW5kcG9pbnRcbiAgICAgKiBAcGFyYW0gcG9ydCBUaGUgcG9ydCB0byBjb25uZWN0IHRvIG9uIHRoZSBJb1QgZW5kcG9pbnQuIFVzdWFsbHkgODg4MyBmb3IgTVFUVCwgb3IgNDQzIGZvciB3ZWJzb2NrZXRzXG4gICAgICovXG4gICAgd2l0aF9wb3J0KHBvcnQpIHtcbiAgICAgICAgdGhpcy5wYXJhbXMucG9ydCA9IHBvcnQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25maWd1cmVzIHRoZSBjbGllbnRfaWQgdG8gdXNlIHRvIGNvbm5lY3QgdG8gdGhlIElvVCBDb3JlIHNlcnZpY2VcbiAgICAgKiBAcGFyYW0gY2xpZW50X2lkIFRoZSBjbGllbnQgaWQgZm9yIHRoaXMgY29ubmVjdGlvbi4gTmVlZHMgdG8gYmUgdW5pcXVlIGFjcm9zcyBhbGwgZGV2aWNlcy9jbGllbnRzLlxuICAgICAqL1xuICAgIHdpdGhfY2xpZW50X2lkKGNsaWVudF9pZCkge1xuICAgICAgICB0aGlzLnBhcmFtcy5jbGllbnRfaWQgPSBjbGllbnRfaWQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IHRoZSBzZXJ2aWNlIHNob3VsZCB0cnkgdG8gcmVzdW1lIHByaW9yIHN1YnNjcmlwdGlvbnMsIGlmIGl0IGhhcyBhbnlcbiAgICAgKiBAcGFyYW0gY2xlYW5fc2Vzc2lvbiB0cnVlIGlmIHRoZSBzZXNzaW9uIHNob3VsZCBkcm9wIHByaW9yIHN1YnNjcmlwdGlvbnMgd2hlbiB0aGlzIGNsaWVudCBjb25uZWN0cywgZmFsc2UgdG8gcmVzdW1lIHRoZSBzZXNzaW9uXG4gICAgICovXG4gICAgd2l0aF9jbGVhbl9zZXNzaW9uKGNsZWFuX3Nlc3Npb24pIHtcbiAgICAgICAgdGhpcy5wYXJhbXMuY2xlYW5fc2Vzc2lvbiA9IGNsZWFuX3Nlc3Npb247XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25maWd1cmVzIE1RVFQga2VlcC1hbGl2ZSB2aWEgUElORyBtZXNzYWdlcy4gTm90ZSB0aGF0IHRoaXMgaXMgbm90IFRDUCBrZWVwYWxpdmUuXG4gICAgICogQHBhcmFtIGtlZXBfYWxpdmUgSG93IG9mdGVuIGluIHNlY29uZHMgdG8gc2VuZCBhbiBNUVRUIFBJTkcgbWVzc2FnZSB0byB0aGUgc2VydmljZSB0byBrZWVwIHRoZSBjb25uZWN0aW9uIGFsaXZlXG4gICAgICovXG4gICAgd2l0aF9rZWVwX2FsaXZlX3NlY29uZHMoa2VlcF9hbGl2ZSkge1xuICAgICAgICB0aGlzLnBhcmFtcy5rZWVwX2FsaXZlID0ga2VlcF9hbGl2ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyZXMgdGhlIFRDUCBzb2NrZXQgdGltZW91dCAoaW4gbWlsbGlzZWNvbmRzKVxuICAgICAqIEBwYXJhbSB0aW1lb3V0X21zIFRDUCBzb2NrZXQgdGltZW91dFxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgd2l0aF90aW1lb3V0X21zKHRpbWVvdXRfbXMpIHtcbiAgICAgICAgdGhpcy53aXRoX3BpbmdfdGltZW91dF9tcyh0aW1lb3V0X21zKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyZXMgdGhlIFBJTkdSRVEgcmVzcG9uc2UgdGltZW91dCAoaW4gbWlsbGlzZWNvbmRzKVxuICAgICAqIEBwYXJhbSBwaW5nX3RpbWVvdXQgUElOR1JFUSByZXNwb25zZSB0aW1lb3V0XG4gICAgICovXG4gICAgd2l0aF9waW5nX3RpbWVvdXRfbXMocGluZ190aW1lb3V0KSB7XG4gICAgICAgIHRoaXMucGFyYW1zLnBpbmdfdGltZW91dCA9IHBpbmdfdGltZW91dDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyZXMgdGhlIHByb3RvY29sIG9wZXJhdGlvbiB0aW1lb3V0IChpbiBtaWxsaXNlY29uZHMpXG4gICAgICogQHBhcmFtIHByb3RvY29sX29wZXJhdGlvbl90aW1lb3V0IHByb3RvY29sIG9wZXJhdGlvbiB0aW1lb3V0XG4gICAgICovXG4gICAgd2l0aF9wcm90b2NvbF9vcGVyYXRpb25fdGltZW91dF9tcyhwcm90b2NvbF9vcGVyYXRpb25fdGltZW91dCkge1xuICAgICAgICB0aGlzLnBhcmFtcy5wcm90b2NvbF9vcGVyYXRpb25fdGltZW91dCA9IHByb3RvY29sX29wZXJhdGlvbl90aW1lb3V0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uZmlndXJlcyB0aGUgd2lsbCBtZXNzYWdlIHRvIGJlIHNlbnQgd2hlbiB0aGlzIGNsaWVudCBkaXNjb25uZWN0c1xuICAgICAqIEBwYXJhbSB3aWxsIFRoZSB3aWxsIHRvcGljLCBxb3MsIGFuZCBtZXNzYWdlXG4gICAgICovXG4gICAgd2l0aF93aWxsKHdpbGwpIHtcbiAgICAgICAgdGhpcy5wYXJhbXMud2lsbCA9IHdpbGw7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25maWd1cmVzIHRoZSBjb21tb24gc2V0dGluZ3MgZm9yIHRoZSBzb2NrZXQgdG8gdXNlIHdoZW4gb3BlbmluZyBhIGNvbm5lY3Rpb24gdG8gdGhlIHNlcnZlclxuICAgICAqIEBwYXJhbSBzb2NrZXRfb3B0aW9ucyBUaGUgc29ja2V0IHNldHRpbmdzXG4gICAgICovXG4gICAgd2l0aF9zb2NrZXRfb3B0aW9ucyhzb2NrZXRfb3B0aW9ucykge1xuICAgICAgICB0aGlzLnBhcmFtcy5zb2NrZXRfb3B0aW9ucyA9IHNvY2tldF9vcHRpb25zO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uZmlndXJlcyBBV1MgY3JlZGVudGlhbHMgKHVzdWFsbHkgZnJvbSBDb2duaXRvKSBmb3IgdGhpcyBjb25uZWN0aW9uXG4gICAgICogQHBhcmFtIGF3c19yZWdpb24gVGhlIHNlcnZpY2UgcmVnaW9uIHRvIGNvbm5lY3QgdG9cbiAgICAgKiBAcGFyYW0gYXdzX2FjY2Vzc19pZCBJQU0gQWNjZXNzIElEXG4gICAgICogQHBhcmFtIGF3c19zZWNyZXRfa2V5IElBTSBTZWNyZXQgS2V5XG4gICAgICogQHBhcmFtIGF3c19zdHNfdG9rZW4gU1RTIHRva2VuIGZyb20gQ29nbml0byAob3B0aW9uYWwpXG4gICAgICovXG4gICAgd2l0aF9jcmVkZW50aWFscyhhd3NfcmVnaW9uLCBhd3NfYWNjZXNzX2lkLCBhd3Nfc2VjcmV0X2tleSwgYXdzX3N0c190b2tlbikge1xuICAgICAgICByZXR1cm4gQXdzSW90TXF0dENvbm5lY3Rpb25Db25maWdCdWlsZGVyLmNvbmZpZ3VyZV93ZWJzb2NrZXRfaGFuZHNoYWtlKHRoaXMsIHtcbiAgICAgICAgICAgIGNyZWRlbnRpYWxzX3Byb3ZpZGVyOiBhdXRoXzEuQXdzQ3JlZGVudGlhbHNQcm92aWRlci5uZXdTdGF0aWMoYXdzX2FjY2Vzc19pZCwgYXdzX3NlY3JldF9rZXksIGF3c19zdHNfdG9rZW4pLFxuICAgICAgICAgICAgcmVnaW9uOiBhd3NfcmVnaW9uLFxuICAgICAgICAgICAgc2VydmljZTogXCJpb3RkZXZpY2VnYXRld2F5XCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25maWd1cmUgdGhlIGh0dHAgcHJveHkgb3B0aW9ucyB0byB1c2UgdG8gZXN0YWJsaXNoIHRoZSBjb25uZWN0aW9uXG4gICAgICogQHBhcmFtIHByb3h5X29wdGlvbnMgcHJveHkgb3B0aW9ucyB0byB1c2UgdG8gZXN0YWJsaXNoIHRoZSBtcXR0IGNvbm5lY3Rpb25cbiAgICAgKi9cbiAgICB3aXRoX2h0dHBfcHJveHlfb3B0aW9ucyhwcm94eV9vcHRpb25zKSB7XG4gICAgICAgIHRoaXMucGFyYW1zLnByb3h5X29wdGlvbnMgPSBwcm94eV9vcHRpb25zO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY3VzdG9tIGF1dGhvcml6ZXIgc2V0dGluZ3MuIFRoaXMgZnVuY3Rpb24gd2lsbCBtb2RpZnkgdGhlIHVzZXJuYW1lLCBwb3J0LCBhbmQgVExTIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXNlcm5hbWUgVGhlIHVzZXJuYW1lIHRvIHVzZSB3aXRoIHRoZSBjdXN0b20gYXV0aG9yaXplci4gSWYgYW4gZW1wdHkgc3RyaW5nIGlzIHBhc3NlZCwgaXQgd2lsbFxuICAgICAqICAgICAgICAgICAgICAgICBjaGVjayB0byBzZWUgaWYgYSB1c2VybmFtZSBoYXMgYWxyZWFkeSBiZWVuIHNldCAodmlhIFdpdGhVc2VybmFtZSBmdW5jdGlvbikuIElmIG5vXG4gICAgICogICAgICAgICAgICAgICAgIHVzZXJuYW1lIGlzIHNldCB0aGVuIG5vIHVzZXJuYW1lIHdpbGwgYmUgcGFzc2VkIHdpdGggdGhlIE1RVFQgY29ubmVjdGlvbi5cbiAgICAgKiBAcGFyYW0gYXV0aG9yaXplcl9uYW1lIFRoZSBuYW1lIG9mIHRoZSBjdXN0b20gYXV0aG9yaXplci4gSWYgYW4gZW1wdHkgc3RyaW5nIGlzIHBhc3NlZCwgdGhlblxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAneC1hbXotY3VzdG9tYXV0aG9yaXplci1uYW1lJyB3aWxsIG5vdCBiZSBhZGRlZCB3aXRoIHRoZSBNUVRUIGNvbm5lY3Rpb24uXG4gICAgICogQHBhcmFtIGF1dGhvcml6ZXJfc2lnbmF0dXJlIFRoZSBzaWduYXR1cmUgb2YgdGhlIGN1c3RvbSBhdXRob3JpemVyLiBJZiBhbiBlbXB0eSBzdHJpbmcgaXMgcGFzc2VkLCB0aGVuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3gtYW16LWN1c3RvbWF1dGhvcml6ZXItc2lnbmF0dXJlJyB3aWxsIG5vdCBiZSBhZGRlZCB3aXRoIHRoZSBNUVRUIGNvbm5lY3Rpb24uXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIHNpZ25hdHVyZSBtdXN0IGJlIGJhc2VkIG9uIHRoZSBwcml2YXRlIGtleSBhc3NvY2lhdGVkIHdpdGggdGhlIGN1c3RvbSBhdXRob3JpemVyLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBzaWduYXR1cmUgbXVzdCBiZSBiYXNlNjQgZW5jb2RlZC5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZXF1aXJlZCBpZiB0aGUgY3VzdG9tIGF1dGhvcml6ZXIgaGFzIHNpZ25pbmcgZW5hYmxlZC4gIEl0IGlzIHN0cm9uZ2x5IHN1Z2dlc3RlZCB0byBVUkwtZW5jb2RlXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyB2YWx1ZTsgdGhlIFNESyB3aWxsIG5vdCBkbyBzbyBmb3IgeW91LlxuICAgICAqIEBwYXJhbSBwYXNzd29yZCBUaGUgcGFzc3dvcmQgdG8gdXNlIHdpdGggdGhlIGN1c3RvbSBhdXRob3JpemVyLiBJZiBudWxsIGlzIHBhc3NlZCwgdGhlbiBubyBwYXNzd29yZCB3aWxsXG4gICAgICogICAgICAgICAgICAgICAgIGJlIHNldC5cbiAgICAgKiBAcGFyYW0gdG9rZW5fa2V5X25hbWUgS2V5IHVzZWQgdG8gZXh0cmFjdCB0aGUgY3VzdG9tIGF1dGhvcml6ZXIgdG9rZW4gZnJvbSBNUVRUIHVzZXJuYW1lIHF1ZXJ5LXN0cmluZyBwcm9wZXJ0aWVzLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICBSZXF1aXJlZCBpZiB0aGUgY3VzdG9tIGF1dGhvcml6ZXIgaGFzIHNpZ25pbmcgZW5hYmxlZC4gIEl0IGlzIHN0cm9uZ2x5IHN1Z2dlc3RlZCB0byBVUkwtZW5jb2RlXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgIHRoaXMgdmFsdWU7IHRoZSBTREsgd2lsbCBub3QgZG8gc28gZm9yIHlvdS5cbiAgICAgKiBAcGFyYW0gdG9rZW5fdmFsdWUgQW4gb3BhcXVlIHRva2VuIHZhbHVlLlxuICAgICAqICAgICAgICAgICAgICAgICAgICBSZXF1aXJlZCBpZiB0aGUgY3VzdG9tIGF1dGhvcml6ZXIgaGFzIHNpZ25pbmcgZW5hYmxlZC4gVGhpcyB2YWx1ZSBtdXN0IGJlIHNpZ25lZCBieSB0aGUgcHJpdmF0ZVxuICAgICAqICAgICAgICAgICAgICAgICAgICBrZXkgYXNzb2NpYXRlZCB3aXRoIHRoZSBjdXN0b20gYXV0aG9yaXplciBhbmQgdGhlIHJlc3VsdCBwbGFjZWQgaW4gdGhlIHRva2VuX3NpZ25hdHVyZSBhcmd1bWVudC5cbiAgICAgKi9cbiAgICB3aXRoX2N1c3RvbV9hdXRob3JpemVyKHVzZXJuYW1lLCBhdXRob3JpemVyX25hbWUsIGF1dGhvcml6ZXJfc2lnbmF0dXJlLCBwYXNzd29yZCwgdG9rZW5fa2V5X25hbWUsIHRva2VuX3ZhbHVlKSB7XG4gICAgICAgIHRoaXMuaXNfdXNpbmdfY3VzdG9tX2F1dGhvcml6ZXIgPSB0cnVlO1xuICAgICAgICBsZXQgdXNlcm5hbWVfc3RyaW5nID0gaW90X3NoYXJlZC5wb3B1bGF0ZV91c2VybmFtZV9zdHJpbmdfd2l0aF9jdXN0b21fYXV0aG9yaXplcihcIlwiLCB1c2VybmFtZSwgYXV0aG9yaXplcl9uYW1lLCBhdXRob3JpemVyX3NpZ25hdHVyZSwgdGhpcy5wYXJhbXMudXNlcm5hbWUsIHRva2VuX2tleV9uYW1lLCB0b2tlbl92YWx1ZSk7XG4gICAgICAgIHRoaXMucGFyYW1zLnVzZXJuYW1lID0gdXNlcm5hbWVfc3RyaW5nO1xuICAgICAgICB0aGlzLnBhcmFtcy5wYXNzd29yZCA9IHBhc3N3b3JkO1xuICAgICAgICBpZiAoIXRoaXMucGFyYW1zLnVzZV93ZWJzb2NrZXQpIHtcbiAgICAgICAgICAgIHRoaXMudGxzX2N0eF9vcHRpb25zLmFscG5fbGlzdCA9IFtcIm1xdHRcIl07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXJhbXMucG9ydCA9IDQ0MztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdXNlcm5hbWUgZm9yIHRoZSBjb25uZWN0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXNlcm5hbWUgdGhlIHVzZXJuYW1lIHRoYXQgd2lsbCBiZSBwYXNzZWQgd2l0aCB0aGUgTVFUVCBjb25uZWN0aW9uXG4gICAgICovXG4gICAgd2l0aF91c2VybmFtZSh1c2VybmFtZSkge1xuICAgICAgICB0aGlzLnBhcmFtcy51c2VybmFtZSA9IHVzZXJuYW1lO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBwYXNzd29yZCBmb3IgdGhlIGNvbm5lY3Rpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXNzd29yZCB0aGUgcGFzc3dvcmQgdGhhdCB3aWxsIGJlIHBhc3NlZCB3aXRoIHRoZSBNUVRUIGNvbm5lY3Rpb25cbiAgICAgKi9cbiAgICB3aXRoX3Bhc3N3b3JkKHBhc3N3b3JkKSB7XG4gICAgICAgIHRoaXMucGFyYW1zLnBhc3N3b3JkID0gcGFzc3dvcmQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25maWd1cmUgdGhlIG1heCByZWNvbm5lY3Rpb24gcGVyaW9kIChpbiBzZWNvbmQpLiBUaGUgcmVvbm5lY3Rpb24gcGVyaW9kIHdpbGxcbiAgICAgKiBiZSBzZXQgaW4gcmFuZ2Ugb2YgW3JlY29ubmVjdF9taW5fc2VjLHJlY29ubmVjdF9tYXhfc2VjXS5cbiAgICAgKiBAcGFyYW0gcmVjb25uZWN0X21heF9zZWMgbWF4IHJlY29ubmVjdGlvbiBwZXJpb2RcbiAgICAgKi9cbiAgICB3aXRoX3JlY29ubmVjdF9tYXhfc2VjKG1heF9zZWMpIHtcbiAgICAgICAgdGhpcy5wYXJhbXMucmVjb25uZWN0X21heF9zZWMgPSBtYXhfc2VjO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uZmlndXJlIHRoZSBtaW4gcmVjb25uZWN0aW9uIHBlcmlvZCAoaW4gc2Vjb25kKS4gVGhlIHJlb25uZWN0aW9uIHBlcmlvZCB3aWxsXG4gICAgICogYmUgc2V0IGluIHJhbmdlIG9mIFtyZWNvbm5lY3RfbWluX3NlYyxyZWNvbm5lY3RfbWF4X3NlY10uXG4gICAgICogQHBhcmFtIHJlY29ubmVjdF9taW5fc2VjIG1pbiByZWNvbm5lY3Rpb24gcGVyaW9kXG4gICAgICovXG4gICAgd2l0aF9yZWNvbm5lY3RfbWluX3NlYyhtaW5fc2VjKSB7XG4gICAgICAgIHRoaXMucGFyYW1zLnJlY29ubmVjdF9taW5fc2VjID0gbWluX3NlYztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvbmZpZ3VyZWQgTXF0dENvbm5lY3Rpb25Db25maWcuICBPbiB0aGUgZmlyc3QgaW52b2NhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uLCB0aGUgVExTIGNvbnRleHQgaXMgY2FjaGVkXG4gICAgICogYW5kIHJlLXVzZWQgb24gYWxsIHN1YnNlcXVlbnQgY2FsbHMgdG8gYnVpbGQoKS5cbiAgICAgKiBAcmV0dXJucyBUaGUgY29uZmlndXJlZCBNcXR0Q29ubmVjdGlvbkNvbmZpZ1xuICAgICAqL1xuICAgIGJ1aWxkKCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgaWYgKHRoaXMucGFyYW1zLmNsaWVudF9pZCA9PT0gdW5kZWZpbmVkIHx8IHRoaXMucGFyYW1zLmhvc3RfbmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyAnY2xpZW50X2lkIGFuZCBlbmRwb2ludCBhcmUgcmVxdWlyZWQnO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiBhIGN1c3RvbSBhdXRob3JpemVyIGlzIGJlaW5nIHVzZWQgYnV0IG5vdCB0aHJvdWdoIHRoZSBidWlsZGVyXG4gICAgICAgIGlmICh0aGlzLmlzX3VzaW5nX2N1c3RvbV9hdXRob3JpemVyID09IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAoaW90X3NoYXJlZC5pc19zdHJpbmdfYW5kX25vdF9lbXB0eSh0aGlzLnBhcmFtcy51c2VybmFtZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoKChfYSA9IHRoaXMucGFyYW1zLnVzZXJuYW1lKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaW5kZXhPZihcIngtYW16LWN1c3RvbWF1dGhvcml6ZXItbmFtZT1cIikpICE9IC0xIHx8ICgoX2IgPSB0aGlzLnBhcmFtcy51c2VybmFtZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmluZGV4T2YoXCJ4LWFtei1jdXN0b21hdXRob3JpemVyLXNpZ25hdHVyZT1cIikpICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNfdXNpbmdfY3VzdG9tX2F1dGhvcml6ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJcyB0aGUgdXNlciB0cnlpbmcgdG8gY29ubmVjdCB1c2luZyBhIGN1c3RvbSBhdXRob3JpemVyP1xuICAgICAgICBpZiAodGhpcy5pc191c2luZ19jdXN0b21fYXV0aG9yaXplciA9PSB0cnVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJhbXMucG9ydCAhPSA0NDMpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIldhcm5pbmc6IEF0dGVtcHRpbmcgdG8gY29ubmVjdCB0byBhdXRob3JpemVyIHdpdGggdW5zdXBwb3J0ZWQgcG9ydC4gUG9ydCBpcyBub3QgNDQzLi4uXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qXG4gICAgICAgICAqIEJ5IGNhY2hpbmcgYW5kIHJldXNpbmcgdGhlIFRMUyBjb250ZXh0IHdlIGdldCBhbiBlbm9ybW91cyBtZW1vcnkgc2F2aW5ncyBvbiBhIHBlci1jb25uZWN0aW9uIGJhc2lzLlxuICAgICAgICAgKiBUaGUgdHJhZGVvZmYgaXMgdGhhdCB5b3UgY2FuJ3QgbW9kaWZ5IFRMUyBvcHRpb25zIGluIGJldHdlZW4gY2FsbHMgdG8gYnVpbGQuXG4gICAgICAgICAqIFByZXZpb3VzbHkgd2Ugd2VyZSBtYWtpbmcgYSBuZXcgb25lIHdpdGggZXZlcnkgc2luZ2xlIGNvbm5lY3Rpb24gd2hpY2ggaGFkIGEgaHVnZSBuZWdhdGl2ZSBpbXBhY3Qgb24gbGFyZ2VcbiAgICAgICAgICogc2NhbGUgdGVzdHMuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodGhpcy5wYXJhbXMudGxzX2N0eCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmFtcy50bHNfY3R4ID0gbmV3IGlvLkNsaWVudFRsc0NvbnRleHQodGhpcy50bHNfY3R4X29wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgbWV0cmljcyBzdHJpbmdcbiAgICAgICAgaWYgKGlvdF9zaGFyZWQuaXNfc3RyaW5nX2FuZF9ub3RfZW1wdHkodGhpcy5wYXJhbXMudXNlcm5hbWUpID09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmFtcy51c2VybmFtZSA9IFwiP1NESz1Ob2RlSlN2MiZWZXJzaW9uPVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCgoX2MgPSB0aGlzLnBhcmFtcy51c2VybmFtZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmluZGV4T2YoXCI/XCIpKSAhPSAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyYW1zLnVzZXJuYW1lICs9IFwiJlNESz1Ob2RlSlN2MiZWZXJzaW9uPVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJhbXMudXNlcm5hbWUgKz0gXCI/U0RLPU5vZGVKU3YyJlZlcnNpb249XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXJhbXMudXNlcm5hbWUgKz0gcGxhdGZvcm0uY3J0X3ZlcnNpb24oKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyYW1zO1xuICAgIH1cbn1cbmV4cG9ydHMuQXdzSW90TXF0dENvbm5lY3Rpb25Db25maWdCdWlsZGVyID0gQXdzSW90TXF0dENvbm5lY3Rpb25Db25maWdCdWlsZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXdzX2lvdC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/aws-crt/dist/native/aws_iot.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/aws-crt/dist/native/aws_iot_mqtt5.js":
/*!***********************************************************!*\
  !*** ./node_modules/aws-crt/dist/native/aws_iot_mqtt5.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n * SPDX-License-Identifier: Apache-2.0.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AwsIotMqtt5ClientConfigBuilder = void 0;\n/**\n * Module for the configuration of MQTT5 clients to connect to AWS IoT\n *\n * @packageDocumentation\n */\nconst mqtt5 = __importStar(__webpack_require__(/*! ./mqtt5 */ \"(ssr)/./node_modules/aws-crt/dist/native/mqtt5.js\"));\nconst io = __importStar(__webpack_require__(/*! ./io */ \"(ssr)/./node_modules/aws-crt/dist/native/io.js\"));\nconst auth = __importStar(__webpack_require__(/*! ./auth */ \"(ssr)/./node_modules/aws-crt/dist/native/auth.js\"));\nconst error_1 = __webpack_require__(/*! ./error */ \"(ssr)/./node_modules/aws-crt/dist/native/error.js\");\nconst iot_shared = __importStar(__webpack_require__(/*! ../common/aws_iot_shared */ \"(ssr)/./node_modules/aws-crt/dist/common/aws_iot_shared.js\"));\nconst mqtt_shared = __importStar(__webpack_require__(/*! ../common/mqtt_shared */ \"(ssr)/./node_modules/aws-crt/dist/common/mqtt_shared.js\"));\n/**\n * Builder pattern class to create an {@link Mqtt5ClientConfig} which can then be used to create\n * an {@link Mqtt5Client}, configured for use with AWS IoT.\n *\n * DEVELOPER PREVIEW DISCLAIMER\n *\n * MQTT5 support is currently in **developer preview**.  We encourage feedback at all times, but feedback during the\n * preview window is especially valuable in shaping the final product.  During the preview period we may make\n * backwards-incompatible changes to the public API, but in general, this is something we will try our best to avoid.\n *\n * [MQTT5 Client User Guide](https://www.github.com/awslabs/aws-crt-nodejs/blob/main/MQTT5-UserGuide.md)\n *\n * @category IoT\n */\nclass AwsIotMqtt5ClientConfigBuilder {\n    constructor(hostName, port, tlsContextOptions) {\n        this.tlsContextOptions = tlsContextOptions;\n        this.config = {\n            hostName: hostName,\n            port: port,\n            connectProperties: {\n                keepAliveIntervalSeconds: mqtt_shared.DEFAULT_KEEP_ALIVE\n            },\n            extendedValidationAndFlowControlOptions: mqtt5.ClientExtendedValidationAndFlowControl.AwsIotCoreDefaults\n        };\n    }\n    /* Builders for different connection methods to AWS IoT Core */\n    /**\n     * Create a new MQTT5 client builder that will create MQTT5 clients that connect to AWS IoT Core via mutual TLS\n     * using X509 certificate and key at the supplied file paths.\n     *\n     * @param hostName - AWS IoT endpoint to connect to\n     * @param certPath - Path to certificate, in PEM format\n     * @param keyPath - Path to private key, in PEM format\n     */\n    static newDirectMqttBuilderWithMtlsFromPath(hostName, certPath, keyPath) {\n        let builder = new AwsIotMqtt5ClientConfigBuilder(hostName, AwsIotMqtt5ClientConfigBuilder.DEFAULT_DIRECT_MQTT_PORT, io.TlsContextOptions.create_client_with_mtls_from_path(certPath, keyPath));\n        if (io.is_alpn_available()) {\n            builder.tlsContextOptions.alpn_list.unshift('x-amzn-mqtt-ca');\n        }\n        return builder;\n    }\n    /**\n     * Create a new MQTT5 client builder that will create MQTT5 clients that connect to AWS IoT Core via mutual TLS\n     * using in-memory X509 certificate and key.\n     *\n     * @param hostName - AWS IoT endpoint to connect to\n     * @param cert - Certificate, in PEM format\n     * @param privateKey - Private key, in PEM format\n     */\n    static newDirectMqttBuilderWithMtlsFromMemory(hostName, cert, privateKey) {\n        let builder = new AwsIotMqtt5ClientConfigBuilder(hostName, AwsIotMqtt5ClientConfigBuilder.DEFAULT_DIRECT_MQTT_PORT, io.TlsContextOptions.create_client_with_mtls(cert, privateKey));\n        if (io.is_alpn_available()) {\n            builder.tlsContextOptions.alpn_list.unshift('x-amzn-mqtt-ca');\n        }\n        return builder;\n    }\n    /**\n     * Create a new MQTT5 client builder that will create MQTT5 clients that connect to AWS IoT Core via mutual TLS\n     * using a PKCS11 library for certificate and private key operations.\n     *\n     * NOTE: This configuration only works on Unix devices.\n     *\n     * @param hostName - AWS IoT endpoint to connect to\n     * @param pkcs11Options - PKCS#11 options.\n     */\n    static newDirectMqttBuilderWithMtlsFromPkcs11(hostName, pkcs11Options) {\n        let builder = new AwsIotMqtt5ClientConfigBuilder(hostName, AwsIotMqtt5ClientConfigBuilder.DEFAULT_DIRECT_MQTT_PORT, io.TlsContextOptions.create_client_with_mtls_pkcs11(pkcs11Options));\n        if (io.is_alpn_available()) {\n            builder.tlsContextOptions.alpn_list.unshift('x-amzn-mqtt-ca');\n        }\n        return builder;\n    }\n    /**\n     * Create a new MQTT5 client builder that will create MQTT5 clients that connect to AWS IoT Core via mutual TLS\n     * using a PKCS12 file.\n     *\n     * Note: This configuration only works on MacOS devices.\n     *\n     * @param hostName - AWS IoT endpoint to connect to\n     * @param pkcs12_options - The PKCS#12 options to use in the builder.\n     */\n    static newDirectMqttBuilderWithMtlsFromPkcs12(hostName, pkcs12_options) {\n        let builder = new AwsIotMqtt5ClientConfigBuilder(hostName, AwsIotMqtt5ClientConfigBuilder.DEFAULT_DIRECT_MQTT_PORT, io.TlsContextOptions.create_client_with_mtls_pkcs12_from_path(pkcs12_options.pkcs12_file, pkcs12_options.pkcs12_password));\n        if (io.is_alpn_available()) {\n            builder.tlsContextOptions.alpn_list.unshift('x-amzn-mqtt-ca');\n        }\n        return builder;\n    }\n    /**\n     * Create a new MQTT5 client builder that will create MQTT5 clients that connect to AWS IoT Core via mutual TLS\n     * using a certificate entry in a Windows certificate store.\n     *\n     * NOTE: This configuration only works on Windows devices.\n     *\n     * @param hostName - AWS IoT endpoint to connect to\n     * @param certificatePath - Path to certificate in a Windows certificate store.\n     *      The path must use backslashes and end with the certificate's thumbprint.\n     *      Example: `CurrentUser\\MY\\A11F8A9B5DF5B98BA3508FBCA575D09570E0D2C6`\n     */\n    static newDirectMqttBuilderWithMtlsFromWindowsCertStorePath(hostName, certificatePath) {\n        let builder = new AwsIotMqtt5ClientConfigBuilder(hostName, AwsIotMqtt5ClientConfigBuilder.DEFAULT_DIRECT_MQTT_PORT, io.TlsContextOptions.create_client_with_mtls_windows_cert_store_path(certificatePath));\n        if (io.is_alpn_available()) {\n            builder.tlsContextOptions.alpn_list.unshift('x-amzn-mqtt-ca');\n        }\n        return builder;\n    }\n    /**\n     * Create a new MQTT5 client builder that will create MQTT5 clients that connect to AWS IoT Core via TLS,\n     * authenticating via a custom authenticator.\n     *\n     * @param hostName - AWS IoT endpoint to connect to\n     * @param customAuthConfig - AWS IoT custom auth configuration\n     */\n    static newDirectMqttBuilderWithCustomAuth(hostName, customAuthConfig) {\n        let builder = new AwsIotMqtt5ClientConfigBuilder(hostName, AwsIotMqtt5ClientConfigBuilder.DEFAULT_WEBSOCKET_MQTT_PORT, new io.TlsContextOptions());\n        builder.customAuthConfig = customAuthConfig;\n        builder.tlsContextOptions.alpn_list = [\"mqtt\"];\n        return builder;\n    }\n    /**\n     * Create a new MQTT5 client builder that will create MQTT5 clients that connect to AWS IoT Core via websockets,\n     * using AWS Sigv4 signing to establish authenticate.\n     *\n     * @param hostName - AWS IoT endpoint to connect to\n     * @param options - additional sigv4-oriented options to use\n     */\n    static newWebsocketMqttBuilderWithSigv4Auth(hostName, options) {\n        let tlsContextOptions = new io.TlsContextOptions();\n        tlsContextOptions.alpn_list = [];\n        let builder = new AwsIotMqtt5ClientConfigBuilder(hostName, AwsIotMqtt5ClientConfigBuilder.DEFAULT_WEBSOCKET_MQTT_PORT, tlsContextOptions);\n        let credentialsProvider = options === null || options === void 0 ? void 0 : options.credentialsProvider;\n        if (!credentialsProvider) {\n            credentialsProvider = auth.AwsCredentialsProvider.newDefault();\n        }\n        builder.config.websocketHandshakeTransform = (request, done) => __awaiter(this, void 0, void 0, function* () {\n            var _a;\n            try {\n                const signingConfig = {\n                    algorithm: auth.AwsSigningAlgorithm.SigV4,\n                    signature_type: auth.AwsSignatureType.HttpRequestViaQueryParams,\n                    provider: credentialsProvider,\n                    region: (_a = options === null || options === void 0 ? void 0 : options.region) !== null && _a !== void 0 ? _a : iot_shared.extractRegionFromEndpoint(hostName),\n                    service: \"iotdevicegateway\",\n                    signed_body_value: auth.AwsSignedBodyValue.EmptySha256,\n                    omit_session_token: true,\n                };\n                yield auth.aws_sign_request(request, signingConfig);\n                done();\n            }\n            catch (error) {\n                if (error instanceof error_1.CrtError) {\n                    done(error.error_code);\n                }\n                else {\n                    done(3); /* TODO: AWS_ERROR_UNKNOWN */\n                }\n            }\n        });\n        return builder;\n    }\n    /**\n     * Create a new MQTT5 client builder that will create MQTT5 clients that connect to AWS IoT Core via websockets,\n     * authenticating via a custom authenticator.\n     *\n     * @param hostName - AWS IoT endpoint to connect to\n     * @param customAuthConfig - AWS IoT custom auth configuration\n     */\n    static newWebsocketMqttBuilderWithCustomAuth(hostName, customAuthConfig) {\n        let builder = new AwsIotMqtt5ClientConfigBuilder(hostName, AwsIotMqtt5ClientConfigBuilder.DEFAULT_WEBSOCKET_MQTT_PORT, new io.TlsContextOptions());\n        builder.customAuthConfig = customAuthConfig;\n        builder.config.websocketHandshakeTransform = (request, done) => __awaiter(this, void 0, void 0, function* () {\n            done(0);\n        });\n        return builder;\n    }\n    /* Instance Methods for various config overrides */\n    /**\n     * Overrides the default system trust store.\n     *\n     * @param caDirpath - Only used on Unix-style systems where all trust anchors are\n     * stored in a directory (e.g. /etc/ssl/certs).\n     * @param caFilepath - Single file containing all trust CAs, in PEM format\n     */\n    withCertificateAuthorityFromPath(caDirpath, caFilepath) {\n        this.tlsContextOptions.override_default_trust_store_from_path(caDirpath, caFilepath);\n        return this;\n    }\n    /**\n     * Overrides the default system trust store.\n     *\n     * @param ca - Buffer containing all trust CAs, in PEM format\n     */\n    withCertificateAuthority(ca) {\n        this.tlsContextOptions.override_default_trust_store(ca);\n        return this;\n    }\n    /**\n     * Overrides the IoT endpoint port to connect to.\n     *\n     * @param port The IoT endpoint port to connect to. Usually 8883 for MQTT, or 443 for websockets\n     */\n    withPort(port) {\n        this.config.port = port;\n        return this;\n    }\n    /**\n     * Overrides all configurable options with respect to the CONNECT packet sent by the client, including the will.\n     * These connect properties will be used for every connection attempt made by the client.  Custom authentication\n     * configuration will override the username and password values in this configuration.\n     *\n     * @param connectPacket all configurable options with respect to the CONNECT packet sent by the client\n     */\n    withConnectProperties(connectPacket) {\n        this.config.connectProperties = connectPacket;\n        return this;\n    }\n    /**\n     * Overrides how the MQTT5 client should behave with respect to MQTT sessions.\n     *\n     * @param sessionBehavior how the MQTT5 client should behave with respect to MQTT sessions.\n     */\n    withSessionBehavior(sessionBehavior) {\n        this.config.sessionBehavior = sessionBehavior;\n        return this;\n    }\n    /**\n     * Overrides how the reconnect delay is modified in order to smooth out the distribution of reconnection attempt\n     * timepoints for a large set of reconnecting clients.\n     *\n     * @param retryJitterMode controls how the reconnect delay is modified in order to smooth out the distribution of\n     * econnection attempt timepoints for a large set of reconnecting clients.\n     */\n    withRetryJitterMode(retryJitterMode) {\n        this.config.retryJitterMode = retryJitterMode;\n        return this;\n    }\n    /**\n     * Overrides the minimum amount of time to wait to reconnect after a disconnect.  Exponential backoff is performed\n     * with controllable jitter after each connection failure.\n     *\n     * @param minReconnectDelayMs minimum amount of time to wait to reconnect after a disconnect.\n     */\n    withMinReconnectDelayMs(minReconnectDelayMs) {\n        this.config.minReconnectDelayMs = minReconnectDelayMs;\n        return this;\n    }\n    /**\n     * Overrides the maximum amount of time to wait to reconnect after a disconnect.  Exponential backoff is performed\n     * with controllable jitter after each connection failure.\n     *\n     * @param maxReconnectDelayMs maximum amount of time to wait to reconnect after a disconnect.\n     */\n    withMaxReconnectDelayMs(maxReconnectDelayMs) {\n        this.config.maxReconnectDelayMs = maxReconnectDelayMs;\n        return this;\n    }\n    /**\n     * Overrides the amount of time that must elapse with an established connection before the reconnect delay is\n     * reset to the minimum.  This helps alleviate bandwidth-waste in fast reconnect cycles due to permission\n     * failures on operations.\n     *\n     * @param minConnectedTimeToResetReconnectDelayMs the amount of time that must elapse with an established\n     * connection before the reconnect delay is reset to the minimum\n     */\n    withMinConnectedTimeToResetReconnectDelayMs(minConnectedTimeToResetReconnectDelayMs) {\n        this.config.minConnectedTimeToResetReconnectDelayMs = minConnectedTimeToResetReconnectDelayMs;\n        return this;\n    }\n    /**\n     * Overrides the time interval to wait after sending a CONNECT request for a CONNACK to arrive.  If one does not\n     * arrive, the connection will be shut down.\n     *\n     * @param connackTimeoutMs time interval to wait after sending a CONNECT request for a CONNACK to arrive\n     */\n    withConnackTimeoutMs(connackTimeoutMs) {\n        this.config.connackTimeoutMs = connackTimeoutMs;\n        return this;\n    }\n    /**\n     * Overrides how disconnects affect the queued and in-progress operations tracked by the client.  Also controls\n     * how new operations are handled while the client is not connected.  In particular, if the client is not connected,\n     * then any operation that would be failed on disconnect (according to these rules) will also be rejected.\n     *\n     * @param offlineQueueBehavior how disconnects affect the queued and in-progress operations tracked by the client\n     *\n     * @group Node-only\n     */\n    withOfflineQueueBehavior(offlineQueueBehavior) {\n        this.config.offlineQueueBehavior = offlineQueueBehavior;\n        return this;\n    }\n    /**\n     * Overrides the time interval to wait after sending a PINGREQ for a PINGRESP to arrive.  If one does not arrive,\n     * the client will close the current connection.\n     *\n     * @param pingTimeoutMs time interval to wait after sending a PINGREQ for a PINGRESP to arrive\n     *\n     * @group Node-only\n     */\n    withPingTimeoutMs(pingTimeoutMs) {\n        this.config.pingTimeoutMs = pingTimeoutMs;\n        return this;\n    }\n    /**\n     * Overrides the time interval to wait for an ack after sending a QoS 1+ PUBLISH, SUBSCRIBE, or UNSUBSCRIBE before\n     * failing the operation.  Defaults to no timeout.\n     *\n     * @param ackTimeoutSeconds the time interval to wait for an ack after sending a QoS 1+ PUBLISH, SUBSCRIBE,\n     * or UNSUBSCRIBE before failing the operation\n     *\n     * @group Node-only\n     */\n    withAckTimeoutSeconds(ackTimeoutSeconds) {\n        this.config.ackTimeoutSeconds = ackTimeoutSeconds;\n        return this;\n    }\n    /**\n     * Overrides the socket properties of the underlying MQTT connections made by the client.  Leave undefined to use\n     * defaults (no TCP keep alive, 10 second socket timeout).\n     *\n     * @param socketOptions socket properties of the underlying MQTT connections made by the client\n     *\n     * @group Node-only\n     */\n    withSocketOptions(socketOptions) {\n        this.config.socketOptions = socketOptions;\n        return this;\n    }\n    /**\n     * Overrides (tunneling) HTTP proxy usage when establishing MQTT connections.\n     *\n     * @param httpProxyOptions HTTP proxy options to use when establishing MQTT connections\n     *\n     * @group Node-only\n     */\n    withHttpProxyOptions(httpProxyOptions) {\n        this.config.httpProxyOptions = httpProxyOptions;\n        return this;\n    }\n    /**\n     * Overrides additional controls for client behavior with respect to operation validation and flow control; these\n     * checks go beyond the base MQTT5 spec to respect limits of specific MQTT brokers.\n     *\n     * @param extendedValidationAndFlowControlOptions additional controls for client behavior with respect to operation\n     * validation and flow control\n     *\n     * @group Node-only\n     */\n    withExtendedValidationAndFlowControlOptions(extendedValidationAndFlowControlOptions) {\n        this.config.extendedValidationAndFlowControlOptions = extendedValidationAndFlowControlOptions;\n        return this;\n    }\n    /**\n     * Constructs an MQTT5 Client configuration object for creating mqtt5 clients.\n     */\n    build() {\n        var _a, _b;\n        if (this.config.tlsCtx === undefined) {\n            this.config.tlsCtx = new io.ClientTlsContext(this.tlsContextOptions);\n        }\n        // this is always set by the constructor, but check it to make typescript happy\n        if (this.config.connectProperties) {\n            this.config.connectProperties.username = iot_shared.buildMqtt5FinalUsername(this.customAuthConfig);\n            if ((_a = this.customAuthConfig) === null || _a === void 0 ? void 0 : _a.password) {\n                this.config.connectProperties.password = (_b = this.customAuthConfig) === null || _b === void 0 ? void 0 : _b.password;\n            }\n        }\n        return this.config;\n    }\n}\nexports.AwsIotMqtt5ClientConfigBuilder = AwsIotMqtt5ClientConfigBuilder;\nAwsIotMqtt5ClientConfigBuilder.DEFAULT_WEBSOCKET_MQTT_PORT = 443;\nAwsIotMqtt5ClientConfigBuilder.DEFAULT_DIRECT_MQTT_PORT = 8883;\n//# sourceMappingURL=aws_iot_mqtt5.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXdzLWNydC9kaXN0L25hdGl2ZS9hd3NfaW90X21xdHQ1LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixtQkFBTyxDQUFDLGtFQUFTO0FBQzVDLHdCQUF3QixtQkFBTyxDQUFDLDREQUFNO0FBQ3RDLDBCQUEwQixtQkFBTyxDQUFDLGdFQUFRO0FBQzFDLGdCQUFnQixtQkFBTyxDQUFDLGtFQUFTO0FBQ2pDLGdDQUFnQyxtQkFBTyxDQUFDLDRGQUEwQjtBQUNsRSxpQ0FBaUMsbUJBQU8sQ0FBQyxzRkFBdUI7QUFDaEU7QUFDQSx1Q0FBdUMseUJBQXlCO0FBQ2hFLE9BQU8sa0JBQWtCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdIQUFnSDtBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BheXdpbmQvLi9ub2RlX21vZHVsZXMvYXdzLWNydC9kaXN0L25hdGl2ZS9hd3NfaW90X21xdHQ1LmpzPzhkMDMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IEFtYXpvbi5jb20sIEluYy4gb3IgaXRzIGFmZmlsaWF0ZXMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMC5cbiAqL1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXdzSW90TXF0dDVDbGllbnRDb25maWdCdWlsZGVyID0gdm9pZCAwO1xuLyoqXG4gKiBNb2R1bGUgZm9yIHRoZSBjb25maWd1cmF0aW9uIG9mIE1RVFQ1IGNsaWVudHMgdG8gY29ubmVjdCB0byBBV1MgSW9UXG4gKlxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKi9cbmNvbnN0IG1xdHQ1ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL21xdHQ1XCIpKTtcbmNvbnN0IGlvID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2lvXCIpKTtcbmNvbnN0IGF1dGggPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vYXV0aFwiKSk7XG5jb25zdCBlcnJvcl8xID0gcmVxdWlyZShcIi4vZXJyb3JcIik7XG5jb25zdCBpb3Rfc2hhcmVkID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi9jb21tb24vYXdzX2lvdF9zaGFyZWRcIikpO1xuY29uc3QgbXF0dF9zaGFyZWQgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL2NvbW1vbi9tcXR0X3NoYXJlZFwiKSk7XG4vKipcbiAqIEJ1aWxkZXIgcGF0dGVybiBjbGFzcyB0byBjcmVhdGUgYW4ge0BsaW5rIE1xdHQ1Q2xpZW50Q29uZmlnfSB3aGljaCBjYW4gdGhlbiBiZSB1c2VkIHRvIGNyZWF0ZVxuICogYW4ge0BsaW5rIE1xdHQ1Q2xpZW50fSwgY29uZmlndXJlZCBmb3IgdXNlIHdpdGggQVdTIElvVC5cbiAqXG4gKiBERVZFTE9QRVIgUFJFVklFVyBESVNDTEFJTUVSXG4gKlxuICogTVFUVDUgc3VwcG9ydCBpcyBjdXJyZW50bHkgaW4gKipkZXZlbG9wZXIgcHJldmlldyoqLiAgV2UgZW5jb3VyYWdlIGZlZWRiYWNrIGF0IGFsbCB0aW1lcywgYnV0IGZlZWRiYWNrIGR1cmluZyB0aGVcbiAqIHByZXZpZXcgd2luZG93IGlzIGVzcGVjaWFsbHkgdmFsdWFibGUgaW4gc2hhcGluZyB0aGUgZmluYWwgcHJvZHVjdC4gIER1cmluZyB0aGUgcHJldmlldyBwZXJpb2Qgd2UgbWF5IG1ha2VcbiAqIGJhY2t3YXJkcy1pbmNvbXBhdGlibGUgY2hhbmdlcyB0byB0aGUgcHVibGljIEFQSSwgYnV0IGluIGdlbmVyYWwsIHRoaXMgaXMgc29tZXRoaW5nIHdlIHdpbGwgdHJ5IG91ciBiZXN0IHRvIGF2b2lkLlxuICpcbiAqIFtNUVRUNSBDbGllbnQgVXNlciBHdWlkZV0oaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9hd3NsYWJzL2F3cy1jcnQtbm9kZWpzL2Jsb2IvbWFpbi9NUVRUNS1Vc2VyR3VpZGUubWQpXG4gKlxuICogQGNhdGVnb3J5IElvVFxuICovXG5jbGFzcyBBd3NJb3RNcXR0NUNsaWVudENvbmZpZ0J1aWxkZXIge1xuICAgIGNvbnN0cnVjdG9yKGhvc3ROYW1lLCBwb3J0LCB0bHNDb250ZXh0T3B0aW9ucykge1xuICAgICAgICB0aGlzLnRsc0NvbnRleHRPcHRpb25zID0gdGxzQ29udGV4dE9wdGlvbnM7XG4gICAgICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgICAgICAgaG9zdE5hbWU6IGhvc3ROYW1lLFxuICAgICAgICAgICAgcG9ydDogcG9ydCxcbiAgICAgICAgICAgIGNvbm5lY3RQcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgICAga2VlcEFsaXZlSW50ZXJ2YWxTZWNvbmRzOiBtcXR0X3NoYXJlZC5ERUZBVUxUX0tFRVBfQUxJVkVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBleHRlbmRlZFZhbGlkYXRpb25BbmRGbG93Q29udHJvbE9wdGlvbnM6IG1xdHQ1LkNsaWVudEV4dGVuZGVkVmFsaWRhdGlvbkFuZEZsb3dDb250cm9sLkF3c0lvdENvcmVEZWZhdWx0c1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKiBCdWlsZGVycyBmb3IgZGlmZmVyZW50IGNvbm5lY3Rpb24gbWV0aG9kcyB0byBBV1MgSW9UIENvcmUgKi9cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgTVFUVDUgY2xpZW50IGJ1aWxkZXIgdGhhdCB3aWxsIGNyZWF0ZSBNUVRUNSBjbGllbnRzIHRoYXQgY29ubmVjdCB0byBBV1MgSW9UIENvcmUgdmlhIG11dHVhbCBUTFNcbiAgICAgKiB1c2luZyBYNTA5IGNlcnRpZmljYXRlIGFuZCBrZXkgYXQgdGhlIHN1cHBsaWVkIGZpbGUgcGF0aHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaG9zdE5hbWUgLSBBV1MgSW9UIGVuZHBvaW50IHRvIGNvbm5lY3QgdG9cbiAgICAgKiBAcGFyYW0gY2VydFBhdGggLSBQYXRoIHRvIGNlcnRpZmljYXRlLCBpbiBQRU0gZm9ybWF0XG4gICAgICogQHBhcmFtIGtleVBhdGggLSBQYXRoIHRvIHByaXZhdGUga2V5LCBpbiBQRU0gZm9ybWF0XG4gICAgICovXG4gICAgc3RhdGljIG5ld0RpcmVjdE1xdHRCdWlsZGVyV2l0aE10bHNGcm9tUGF0aChob3N0TmFtZSwgY2VydFBhdGgsIGtleVBhdGgpIHtcbiAgICAgICAgbGV0IGJ1aWxkZXIgPSBuZXcgQXdzSW90TXF0dDVDbGllbnRDb25maWdCdWlsZGVyKGhvc3ROYW1lLCBBd3NJb3RNcXR0NUNsaWVudENvbmZpZ0J1aWxkZXIuREVGQVVMVF9ESVJFQ1RfTVFUVF9QT1JULCBpby5UbHNDb250ZXh0T3B0aW9ucy5jcmVhdGVfY2xpZW50X3dpdGhfbXRsc19mcm9tX3BhdGgoY2VydFBhdGgsIGtleVBhdGgpKTtcbiAgICAgICAgaWYgKGlvLmlzX2FscG5fYXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgIGJ1aWxkZXIudGxzQ29udGV4dE9wdGlvbnMuYWxwbl9saXN0LnVuc2hpZnQoJ3gtYW16bi1tcXR0LWNhJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1aWxkZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBNUVRUNSBjbGllbnQgYnVpbGRlciB0aGF0IHdpbGwgY3JlYXRlIE1RVFQ1IGNsaWVudHMgdGhhdCBjb25uZWN0IHRvIEFXUyBJb1QgQ29yZSB2aWEgbXV0dWFsIFRMU1xuICAgICAqIHVzaW5nIGluLW1lbW9yeSBYNTA5IGNlcnRpZmljYXRlIGFuZCBrZXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaG9zdE5hbWUgLSBBV1MgSW9UIGVuZHBvaW50IHRvIGNvbm5lY3QgdG9cbiAgICAgKiBAcGFyYW0gY2VydCAtIENlcnRpZmljYXRlLCBpbiBQRU0gZm9ybWF0XG4gICAgICogQHBhcmFtIHByaXZhdGVLZXkgLSBQcml2YXRlIGtleSwgaW4gUEVNIGZvcm1hdFxuICAgICAqL1xuICAgIHN0YXRpYyBuZXdEaXJlY3RNcXR0QnVpbGRlcldpdGhNdGxzRnJvbU1lbW9yeShob3N0TmFtZSwgY2VydCwgcHJpdmF0ZUtleSkge1xuICAgICAgICBsZXQgYnVpbGRlciA9IG5ldyBBd3NJb3RNcXR0NUNsaWVudENvbmZpZ0J1aWxkZXIoaG9zdE5hbWUsIEF3c0lvdE1xdHQ1Q2xpZW50Q29uZmlnQnVpbGRlci5ERUZBVUxUX0RJUkVDVF9NUVRUX1BPUlQsIGlvLlRsc0NvbnRleHRPcHRpb25zLmNyZWF0ZV9jbGllbnRfd2l0aF9tdGxzKGNlcnQsIHByaXZhdGVLZXkpKTtcbiAgICAgICAgaWYgKGlvLmlzX2FscG5fYXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgIGJ1aWxkZXIudGxzQ29udGV4dE9wdGlvbnMuYWxwbl9saXN0LnVuc2hpZnQoJ3gtYW16bi1tcXR0LWNhJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1aWxkZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBNUVRUNSBjbGllbnQgYnVpbGRlciB0aGF0IHdpbGwgY3JlYXRlIE1RVFQ1IGNsaWVudHMgdGhhdCBjb25uZWN0IHRvIEFXUyBJb1QgQ29yZSB2aWEgbXV0dWFsIFRMU1xuICAgICAqIHVzaW5nIGEgUEtDUzExIGxpYnJhcnkgZm9yIGNlcnRpZmljYXRlIGFuZCBwcml2YXRlIGtleSBvcGVyYXRpb25zLlxuICAgICAqXG4gICAgICogTk9URTogVGhpcyBjb25maWd1cmF0aW9uIG9ubHkgd29ya3Mgb24gVW5peCBkZXZpY2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGhvc3ROYW1lIC0gQVdTIElvVCBlbmRwb2ludCB0byBjb25uZWN0IHRvXG4gICAgICogQHBhcmFtIHBrY3MxMU9wdGlvbnMgLSBQS0NTIzExIG9wdGlvbnMuXG4gICAgICovXG4gICAgc3RhdGljIG5ld0RpcmVjdE1xdHRCdWlsZGVyV2l0aE10bHNGcm9tUGtjczExKGhvc3ROYW1lLCBwa2NzMTFPcHRpb25zKSB7XG4gICAgICAgIGxldCBidWlsZGVyID0gbmV3IEF3c0lvdE1xdHQ1Q2xpZW50Q29uZmlnQnVpbGRlcihob3N0TmFtZSwgQXdzSW90TXF0dDVDbGllbnRDb25maWdCdWlsZGVyLkRFRkFVTFRfRElSRUNUX01RVFRfUE9SVCwgaW8uVGxzQ29udGV4dE9wdGlvbnMuY3JlYXRlX2NsaWVudF93aXRoX210bHNfcGtjczExKHBrY3MxMU9wdGlvbnMpKTtcbiAgICAgICAgaWYgKGlvLmlzX2FscG5fYXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgIGJ1aWxkZXIudGxzQ29udGV4dE9wdGlvbnMuYWxwbl9saXN0LnVuc2hpZnQoJ3gtYW16bi1tcXR0LWNhJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1aWxkZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBNUVRUNSBjbGllbnQgYnVpbGRlciB0aGF0IHdpbGwgY3JlYXRlIE1RVFQ1IGNsaWVudHMgdGhhdCBjb25uZWN0IHRvIEFXUyBJb1QgQ29yZSB2aWEgbXV0dWFsIFRMU1xuICAgICAqIHVzaW5nIGEgUEtDUzEyIGZpbGUuXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGlzIGNvbmZpZ3VyYXRpb24gb25seSB3b3JrcyBvbiBNYWNPUyBkZXZpY2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGhvc3ROYW1lIC0gQVdTIElvVCBlbmRwb2ludCB0byBjb25uZWN0IHRvXG4gICAgICogQHBhcmFtIHBrY3MxMl9vcHRpb25zIC0gVGhlIFBLQ1MjMTIgb3B0aW9ucyB0byB1c2UgaW4gdGhlIGJ1aWxkZXIuXG4gICAgICovXG4gICAgc3RhdGljIG5ld0RpcmVjdE1xdHRCdWlsZGVyV2l0aE10bHNGcm9tUGtjczEyKGhvc3ROYW1lLCBwa2NzMTJfb3B0aW9ucykge1xuICAgICAgICBsZXQgYnVpbGRlciA9IG5ldyBBd3NJb3RNcXR0NUNsaWVudENvbmZpZ0J1aWxkZXIoaG9zdE5hbWUsIEF3c0lvdE1xdHQ1Q2xpZW50Q29uZmlnQnVpbGRlci5ERUZBVUxUX0RJUkVDVF9NUVRUX1BPUlQsIGlvLlRsc0NvbnRleHRPcHRpb25zLmNyZWF0ZV9jbGllbnRfd2l0aF9tdGxzX3BrY3MxMl9mcm9tX3BhdGgocGtjczEyX29wdGlvbnMucGtjczEyX2ZpbGUsIHBrY3MxMl9vcHRpb25zLnBrY3MxMl9wYXNzd29yZCkpO1xuICAgICAgICBpZiAoaW8uaXNfYWxwbl9hdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgYnVpbGRlci50bHNDb250ZXh0T3B0aW9ucy5hbHBuX2xpc3QudW5zaGlmdCgneC1hbXpuLW1xdHQtY2EnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVpbGRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IE1RVFQ1IGNsaWVudCBidWlsZGVyIHRoYXQgd2lsbCBjcmVhdGUgTVFUVDUgY2xpZW50cyB0aGF0IGNvbm5lY3QgdG8gQVdTIElvVCBDb3JlIHZpYSBtdXR1YWwgVExTXG4gICAgICogdXNpbmcgYSBjZXJ0aWZpY2F0ZSBlbnRyeSBpbiBhIFdpbmRvd3MgY2VydGlmaWNhdGUgc3RvcmUuXG4gICAgICpcbiAgICAgKiBOT1RFOiBUaGlzIGNvbmZpZ3VyYXRpb24gb25seSB3b3JrcyBvbiBXaW5kb3dzIGRldmljZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaG9zdE5hbWUgLSBBV1MgSW9UIGVuZHBvaW50IHRvIGNvbm5lY3QgdG9cbiAgICAgKiBAcGFyYW0gY2VydGlmaWNhdGVQYXRoIC0gUGF0aCB0byBjZXJ0aWZpY2F0ZSBpbiBhIFdpbmRvd3MgY2VydGlmaWNhdGUgc3RvcmUuXG4gICAgICogICAgICBUaGUgcGF0aCBtdXN0IHVzZSBiYWNrc2xhc2hlcyBhbmQgZW5kIHdpdGggdGhlIGNlcnRpZmljYXRlJ3MgdGh1bWJwcmludC5cbiAgICAgKiAgICAgIEV4YW1wbGU6IGBDdXJyZW50VXNlclxcTVlcXEExMUY4QTlCNURGNUI5OEJBMzUwOEZCQ0E1NzVEMDk1NzBFMEQyQzZgXG4gICAgICovXG4gICAgc3RhdGljIG5ld0RpcmVjdE1xdHRCdWlsZGVyV2l0aE10bHNGcm9tV2luZG93c0NlcnRTdG9yZVBhdGgoaG9zdE5hbWUsIGNlcnRpZmljYXRlUGF0aCkge1xuICAgICAgICBsZXQgYnVpbGRlciA9IG5ldyBBd3NJb3RNcXR0NUNsaWVudENvbmZpZ0J1aWxkZXIoaG9zdE5hbWUsIEF3c0lvdE1xdHQ1Q2xpZW50Q29uZmlnQnVpbGRlci5ERUZBVUxUX0RJUkVDVF9NUVRUX1BPUlQsIGlvLlRsc0NvbnRleHRPcHRpb25zLmNyZWF0ZV9jbGllbnRfd2l0aF9tdGxzX3dpbmRvd3NfY2VydF9zdG9yZV9wYXRoKGNlcnRpZmljYXRlUGF0aCkpO1xuICAgICAgICBpZiAoaW8uaXNfYWxwbl9hdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgYnVpbGRlci50bHNDb250ZXh0T3B0aW9ucy5hbHBuX2xpc3QudW5zaGlmdCgneC1hbXpuLW1xdHQtY2EnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVpbGRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IE1RVFQ1IGNsaWVudCBidWlsZGVyIHRoYXQgd2lsbCBjcmVhdGUgTVFUVDUgY2xpZW50cyB0aGF0IGNvbm5lY3QgdG8gQVdTIElvVCBDb3JlIHZpYSBUTFMsXG4gICAgICogYXV0aGVudGljYXRpbmcgdmlhIGEgY3VzdG9tIGF1dGhlbnRpY2F0b3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaG9zdE5hbWUgLSBBV1MgSW9UIGVuZHBvaW50IHRvIGNvbm5lY3QgdG9cbiAgICAgKiBAcGFyYW0gY3VzdG9tQXV0aENvbmZpZyAtIEFXUyBJb1QgY3VzdG9tIGF1dGggY29uZmlndXJhdGlvblxuICAgICAqL1xuICAgIHN0YXRpYyBuZXdEaXJlY3RNcXR0QnVpbGRlcldpdGhDdXN0b21BdXRoKGhvc3ROYW1lLCBjdXN0b21BdXRoQ29uZmlnKSB7XG4gICAgICAgIGxldCBidWlsZGVyID0gbmV3IEF3c0lvdE1xdHQ1Q2xpZW50Q29uZmlnQnVpbGRlcihob3N0TmFtZSwgQXdzSW90TXF0dDVDbGllbnRDb25maWdCdWlsZGVyLkRFRkFVTFRfV0VCU09DS0VUX01RVFRfUE9SVCwgbmV3IGlvLlRsc0NvbnRleHRPcHRpb25zKCkpO1xuICAgICAgICBidWlsZGVyLmN1c3RvbUF1dGhDb25maWcgPSBjdXN0b21BdXRoQ29uZmlnO1xuICAgICAgICBidWlsZGVyLnRsc0NvbnRleHRPcHRpb25zLmFscG5fbGlzdCA9IFtcIm1xdHRcIl07XG4gICAgICAgIHJldHVybiBidWlsZGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgTVFUVDUgY2xpZW50IGJ1aWxkZXIgdGhhdCB3aWxsIGNyZWF0ZSBNUVRUNSBjbGllbnRzIHRoYXQgY29ubmVjdCB0byBBV1MgSW9UIENvcmUgdmlhIHdlYnNvY2tldHMsXG4gICAgICogdXNpbmcgQVdTIFNpZ3Y0IHNpZ25pbmcgdG8gZXN0YWJsaXNoIGF1dGhlbnRpY2F0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBob3N0TmFtZSAtIEFXUyBJb1QgZW5kcG9pbnQgdG8gY29ubmVjdCB0b1xuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gYWRkaXRpb25hbCBzaWd2NC1vcmllbnRlZCBvcHRpb25zIHRvIHVzZVxuICAgICAqL1xuICAgIHN0YXRpYyBuZXdXZWJzb2NrZXRNcXR0QnVpbGRlcldpdGhTaWd2NEF1dGgoaG9zdE5hbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IHRsc0NvbnRleHRPcHRpb25zID0gbmV3IGlvLlRsc0NvbnRleHRPcHRpb25zKCk7XG4gICAgICAgIHRsc0NvbnRleHRPcHRpb25zLmFscG5fbGlzdCA9IFtdO1xuICAgICAgICBsZXQgYnVpbGRlciA9IG5ldyBBd3NJb3RNcXR0NUNsaWVudENvbmZpZ0J1aWxkZXIoaG9zdE5hbWUsIEF3c0lvdE1xdHQ1Q2xpZW50Q29uZmlnQnVpbGRlci5ERUZBVUxUX1dFQlNPQ0tFVF9NUVRUX1BPUlQsIHRsc0NvbnRleHRPcHRpb25zKTtcbiAgICAgICAgbGV0IGNyZWRlbnRpYWxzUHJvdmlkZXIgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY3JlZGVudGlhbHNQcm92aWRlcjtcbiAgICAgICAgaWYgKCFjcmVkZW50aWFsc1Byb3ZpZGVyKSB7XG4gICAgICAgICAgICBjcmVkZW50aWFsc1Byb3ZpZGVyID0gYXV0aC5Bd3NDcmVkZW50aWFsc1Byb3ZpZGVyLm5ld0RlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBidWlsZGVyLmNvbmZpZy53ZWJzb2NrZXRIYW5kc2hha2VUcmFuc2Zvcm0gPSAocmVxdWVzdCwgZG9uZSkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzaWduaW5nQ29uZmlnID0ge1xuICAgICAgICAgICAgICAgICAgICBhbGdvcml0aG06IGF1dGguQXdzU2lnbmluZ0FsZ29yaXRobS5TaWdWNCxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlX3R5cGU6IGF1dGguQXdzU2lnbmF0dXJlVHlwZS5IdHRwUmVxdWVzdFZpYVF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcjogY3JlZGVudGlhbHNQcm92aWRlcixcbiAgICAgICAgICAgICAgICAgICAgcmVnaW9uOiAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucmVnaW9uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBpb3Rfc2hhcmVkLmV4dHJhY3RSZWdpb25Gcm9tRW5kcG9pbnQoaG9zdE5hbWUpLFxuICAgICAgICAgICAgICAgICAgICBzZXJ2aWNlOiBcImlvdGRldmljZWdhdGV3YXlcIixcbiAgICAgICAgICAgICAgICAgICAgc2lnbmVkX2JvZHlfdmFsdWU6IGF1dGguQXdzU2lnbmVkQm9keVZhbHVlLkVtcHR5U2hhMjU2LFxuICAgICAgICAgICAgICAgICAgICBvbWl0X3Nlc3Npb25fdG9rZW46IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB5aWVsZCBhdXRoLmF3c19zaWduX3JlcXVlc3QocmVxdWVzdCwgc2lnbmluZ0NvbmZpZyk7XG4gICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgZXJyb3JfMS5DcnRFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBkb25lKGVycm9yLmVycm9yX2NvZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZG9uZSgzKTsgLyogVE9ETzogQVdTX0VSUk9SX1VOS05PV04gKi9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYnVpbGRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IE1RVFQ1IGNsaWVudCBidWlsZGVyIHRoYXQgd2lsbCBjcmVhdGUgTVFUVDUgY2xpZW50cyB0aGF0IGNvbm5lY3QgdG8gQVdTIElvVCBDb3JlIHZpYSB3ZWJzb2NrZXRzLFxuICAgICAqIGF1dGhlbnRpY2F0aW5nIHZpYSBhIGN1c3RvbSBhdXRoZW50aWNhdG9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIGhvc3ROYW1lIC0gQVdTIElvVCBlbmRwb2ludCB0byBjb25uZWN0IHRvXG4gICAgICogQHBhcmFtIGN1c3RvbUF1dGhDb25maWcgLSBBV1MgSW9UIGN1c3RvbSBhdXRoIGNvbmZpZ3VyYXRpb25cbiAgICAgKi9cbiAgICBzdGF0aWMgbmV3V2Vic29ja2V0TXF0dEJ1aWxkZXJXaXRoQ3VzdG9tQXV0aChob3N0TmFtZSwgY3VzdG9tQXV0aENvbmZpZykge1xuICAgICAgICBsZXQgYnVpbGRlciA9IG5ldyBBd3NJb3RNcXR0NUNsaWVudENvbmZpZ0J1aWxkZXIoaG9zdE5hbWUsIEF3c0lvdE1xdHQ1Q2xpZW50Q29uZmlnQnVpbGRlci5ERUZBVUxUX1dFQlNPQ0tFVF9NUVRUX1BPUlQsIG5ldyBpby5UbHNDb250ZXh0T3B0aW9ucygpKTtcbiAgICAgICAgYnVpbGRlci5jdXN0b21BdXRoQ29uZmlnID0gY3VzdG9tQXV0aENvbmZpZztcbiAgICAgICAgYnVpbGRlci5jb25maWcud2Vic29ja2V0SGFuZHNoYWtlVHJhbnNmb3JtID0gKHJlcXVlc3QsIGRvbmUpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGRvbmUoMCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYnVpbGRlcjtcbiAgICB9XG4gICAgLyogSW5zdGFuY2UgTWV0aG9kcyBmb3IgdmFyaW91cyBjb25maWcgb3ZlcnJpZGVzICovXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIHRoZSBkZWZhdWx0IHN5c3RlbSB0cnVzdCBzdG9yZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjYURpcnBhdGggLSBPbmx5IHVzZWQgb24gVW5peC1zdHlsZSBzeXN0ZW1zIHdoZXJlIGFsbCB0cnVzdCBhbmNob3JzIGFyZVxuICAgICAqIHN0b3JlZCBpbiBhIGRpcmVjdG9yeSAoZS5nLiAvZXRjL3NzbC9jZXJ0cykuXG4gICAgICogQHBhcmFtIGNhRmlsZXBhdGggLSBTaW5nbGUgZmlsZSBjb250YWluaW5nIGFsbCB0cnVzdCBDQXMsIGluIFBFTSBmb3JtYXRcbiAgICAgKi9cbiAgICB3aXRoQ2VydGlmaWNhdGVBdXRob3JpdHlGcm9tUGF0aChjYURpcnBhdGgsIGNhRmlsZXBhdGgpIHtcbiAgICAgICAgdGhpcy50bHNDb250ZXh0T3B0aW9ucy5vdmVycmlkZV9kZWZhdWx0X3RydXN0X3N0b3JlX2Zyb21fcGF0aChjYURpcnBhdGgsIGNhRmlsZXBhdGgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIHRoZSBkZWZhdWx0IHN5c3RlbSB0cnVzdCBzdG9yZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjYSAtIEJ1ZmZlciBjb250YWluaW5nIGFsbCB0cnVzdCBDQXMsIGluIFBFTSBmb3JtYXRcbiAgICAgKi9cbiAgICB3aXRoQ2VydGlmaWNhdGVBdXRob3JpdHkoY2EpIHtcbiAgICAgICAgdGhpcy50bHNDb250ZXh0T3B0aW9ucy5vdmVycmlkZV9kZWZhdWx0X3RydXN0X3N0b3JlKGNhKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyB0aGUgSW9UIGVuZHBvaW50IHBvcnQgdG8gY29ubmVjdCB0by5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwb3J0IFRoZSBJb1QgZW5kcG9pbnQgcG9ydCB0byBjb25uZWN0IHRvLiBVc3VhbGx5IDg4ODMgZm9yIE1RVFQsIG9yIDQ0MyBmb3Igd2Vic29ja2V0c1xuICAgICAqL1xuICAgIHdpdGhQb3J0KHBvcnQpIHtcbiAgICAgICAgdGhpcy5jb25maWcucG9ydCA9IHBvcnQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgYWxsIGNvbmZpZ3VyYWJsZSBvcHRpb25zIHdpdGggcmVzcGVjdCB0byB0aGUgQ09OTkVDVCBwYWNrZXQgc2VudCBieSB0aGUgY2xpZW50LCBpbmNsdWRpbmcgdGhlIHdpbGwuXG4gICAgICogVGhlc2UgY29ubmVjdCBwcm9wZXJ0aWVzIHdpbGwgYmUgdXNlZCBmb3IgZXZlcnkgY29ubmVjdGlvbiBhdHRlbXB0IG1hZGUgYnkgdGhlIGNsaWVudC4gIEN1c3RvbSBhdXRoZW50aWNhdGlvblxuICAgICAqIGNvbmZpZ3VyYXRpb24gd2lsbCBvdmVycmlkZSB0aGUgdXNlcm5hbWUgYW5kIHBhc3N3b3JkIHZhbHVlcyBpbiB0aGlzIGNvbmZpZ3VyYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29ubmVjdFBhY2tldCBhbGwgY29uZmlndXJhYmxlIG9wdGlvbnMgd2l0aCByZXNwZWN0IHRvIHRoZSBDT05ORUNUIHBhY2tldCBzZW50IGJ5IHRoZSBjbGllbnRcbiAgICAgKi9cbiAgICB3aXRoQ29ubmVjdFByb3BlcnRpZXMoY29ubmVjdFBhY2tldCkge1xuICAgICAgICB0aGlzLmNvbmZpZy5jb25uZWN0UHJvcGVydGllcyA9IGNvbm5lY3RQYWNrZXQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgaG93IHRoZSBNUVRUNSBjbGllbnQgc2hvdWxkIGJlaGF2ZSB3aXRoIHJlc3BlY3QgdG8gTVFUVCBzZXNzaW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzZXNzaW9uQmVoYXZpb3IgaG93IHRoZSBNUVRUNSBjbGllbnQgc2hvdWxkIGJlaGF2ZSB3aXRoIHJlc3BlY3QgdG8gTVFUVCBzZXNzaW9ucy5cbiAgICAgKi9cbiAgICB3aXRoU2Vzc2lvbkJlaGF2aW9yKHNlc3Npb25CZWhhdmlvcikge1xuICAgICAgICB0aGlzLmNvbmZpZy5zZXNzaW9uQmVoYXZpb3IgPSBzZXNzaW9uQmVoYXZpb3I7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgaG93IHRoZSByZWNvbm5lY3QgZGVsYXkgaXMgbW9kaWZpZWQgaW4gb3JkZXIgdG8gc21vb3RoIG91dCB0aGUgZGlzdHJpYnV0aW9uIG9mIHJlY29ubmVjdGlvbiBhdHRlbXB0XG4gICAgICogdGltZXBvaW50cyBmb3IgYSBsYXJnZSBzZXQgb2YgcmVjb25uZWN0aW5nIGNsaWVudHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmV0cnlKaXR0ZXJNb2RlIGNvbnRyb2xzIGhvdyB0aGUgcmVjb25uZWN0IGRlbGF5IGlzIG1vZGlmaWVkIGluIG9yZGVyIHRvIHNtb290aCBvdXQgdGhlIGRpc3RyaWJ1dGlvbiBvZlxuICAgICAqIGVjb25uZWN0aW9uIGF0dGVtcHQgdGltZXBvaW50cyBmb3IgYSBsYXJnZSBzZXQgb2YgcmVjb25uZWN0aW5nIGNsaWVudHMuXG4gICAgICovXG4gICAgd2l0aFJldHJ5Sml0dGVyTW9kZShyZXRyeUppdHRlck1vZGUpIHtcbiAgICAgICAgdGhpcy5jb25maWcucmV0cnlKaXR0ZXJNb2RlID0gcmV0cnlKaXR0ZXJNb2RlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIHRoZSBtaW5pbXVtIGFtb3VudCBvZiB0aW1lIHRvIHdhaXQgdG8gcmVjb25uZWN0IGFmdGVyIGEgZGlzY29ubmVjdC4gIEV4cG9uZW50aWFsIGJhY2tvZmYgaXMgcGVyZm9ybWVkXG4gICAgICogd2l0aCBjb250cm9sbGFibGUgaml0dGVyIGFmdGVyIGVhY2ggY29ubmVjdGlvbiBmYWlsdXJlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1pblJlY29ubmVjdERlbGF5TXMgbWluaW11bSBhbW91bnQgb2YgdGltZSB0byB3YWl0IHRvIHJlY29ubmVjdCBhZnRlciBhIGRpc2Nvbm5lY3QuXG4gICAgICovXG4gICAgd2l0aE1pblJlY29ubmVjdERlbGF5TXMobWluUmVjb25uZWN0RGVsYXlNcykge1xuICAgICAgICB0aGlzLmNvbmZpZy5taW5SZWNvbm5lY3REZWxheU1zID0gbWluUmVjb25uZWN0RGVsYXlNcztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyB0aGUgbWF4aW11bSBhbW91bnQgb2YgdGltZSB0byB3YWl0IHRvIHJlY29ubmVjdCBhZnRlciBhIGRpc2Nvbm5lY3QuICBFeHBvbmVudGlhbCBiYWNrb2ZmIGlzIHBlcmZvcm1lZFxuICAgICAqIHdpdGggY29udHJvbGxhYmxlIGppdHRlciBhZnRlciBlYWNoIGNvbm5lY3Rpb24gZmFpbHVyZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtYXhSZWNvbm5lY3REZWxheU1zIG1heGltdW0gYW1vdW50IG9mIHRpbWUgdG8gd2FpdCB0byByZWNvbm5lY3QgYWZ0ZXIgYSBkaXNjb25uZWN0LlxuICAgICAqL1xuICAgIHdpdGhNYXhSZWNvbm5lY3REZWxheU1zKG1heFJlY29ubmVjdERlbGF5TXMpIHtcbiAgICAgICAgdGhpcy5jb25maWcubWF4UmVjb25uZWN0RGVsYXlNcyA9IG1heFJlY29ubmVjdERlbGF5TXM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgdGhlIGFtb3VudCBvZiB0aW1lIHRoYXQgbXVzdCBlbGFwc2Ugd2l0aCBhbiBlc3RhYmxpc2hlZCBjb25uZWN0aW9uIGJlZm9yZSB0aGUgcmVjb25uZWN0IGRlbGF5IGlzXG4gICAgICogcmVzZXQgdG8gdGhlIG1pbmltdW0uICBUaGlzIGhlbHBzIGFsbGV2aWF0ZSBiYW5kd2lkdGgtd2FzdGUgaW4gZmFzdCByZWNvbm5lY3QgY3ljbGVzIGR1ZSB0byBwZXJtaXNzaW9uXG4gICAgICogZmFpbHVyZXMgb24gb3BlcmF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtaW5Db25uZWN0ZWRUaW1lVG9SZXNldFJlY29ubmVjdERlbGF5TXMgdGhlIGFtb3VudCBvZiB0aW1lIHRoYXQgbXVzdCBlbGFwc2Ugd2l0aCBhbiBlc3RhYmxpc2hlZFxuICAgICAqIGNvbm5lY3Rpb24gYmVmb3JlIHRoZSByZWNvbm5lY3QgZGVsYXkgaXMgcmVzZXQgdG8gdGhlIG1pbmltdW1cbiAgICAgKi9cbiAgICB3aXRoTWluQ29ubmVjdGVkVGltZVRvUmVzZXRSZWNvbm5lY3REZWxheU1zKG1pbkNvbm5lY3RlZFRpbWVUb1Jlc2V0UmVjb25uZWN0RGVsYXlNcykge1xuICAgICAgICB0aGlzLmNvbmZpZy5taW5Db25uZWN0ZWRUaW1lVG9SZXNldFJlY29ubmVjdERlbGF5TXMgPSBtaW5Db25uZWN0ZWRUaW1lVG9SZXNldFJlY29ubmVjdERlbGF5TXM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgdGhlIHRpbWUgaW50ZXJ2YWwgdG8gd2FpdCBhZnRlciBzZW5kaW5nIGEgQ09OTkVDVCByZXF1ZXN0IGZvciBhIENPTk5BQ0sgdG8gYXJyaXZlLiAgSWYgb25lIGRvZXMgbm90XG4gICAgICogYXJyaXZlLCB0aGUgY29ubmVjdGlvbiB3aWxsIGJlIHNodXQgZG93bi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb25uYWNrVGltZW91dE1zIHRpbWUgaW50ZXJ2YWwgdG8gd2FpdCBhZnRlciBzZW5kaW5nIGEgQ09OTkVDVCByZXF1ZXN0IGZvciBhIENPTk5BQ0sgdG8gYXJyaXZlXG4gICAgICovXG4gICAgd2l0aENvbm5hY2tUaW1lb3V0TXMoY29ubmFja1RpbWVvdXRNcykge1xuICAgICAgICB0aGlzLmNvbmZpZy5jb25uYWNrVGltZW91dE1zID0gY29ubmFja1RpbWVvdXRNcztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyBob3cgZGlzY29ubmVjdHMgYWZmZWN0IHRoZSBxdWV1ZWQgYW5kIGluLXByb2dyZXNzIG9wZXJhdGlvbnMgdHJhY2tlZCBieSB0aGUgY2xpZW50LiAgQWxzbyBjb250cm9sc1xuICAgICAqIGhvdyBuZXcgb3BlcmF0aW9ucyBhcmUgaGFuZGxlZCB3aGlsZSB0aGUgY2xpZW50IGlzIG5vdCBjb25uZWN0ZWQuICBJbiBwYXJ0aWN1bGFyLCBpZiB0aGUgY2xpZW50IGlzIG5vdCBjb25uZWN0ZWQsXG4gICAgICogdGhlbiBhbnkgb3BlcmF0aW9uIHRoYXQgd291bGQgYmUgZmFpbGVkIG9uIGRpc2Nvbm5lY3QgKGFjY29yZGluZyB0byB0aGVzZSBydWxlcykgd2lsbCBhbHNvIGJlIHJlamVjdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9mZmxpbmVRdWV1ZUJlaGF2aW9yIGhvdyBkaXNjb25uZWN0cyBhZmZlY3QgdGhlIHF1ZXVlZCBhbmQgaW4tcHJvZ3Jlc3Mgb3BlcmF0aW9ucyB0cmFja2VkIGJ5IHRoZSBjbGllbnRcbiAgICAgKlxuICAgICAqIEBncm91cCBOb2RlLW9ubHlcbiAgICAgKi9cbiAgICB3aXRoT2ZmbGluZVF1ZXVlQmVoYXZpb3Iob2ZmbGluZVF1ZXVlQmVoYXZpb3IpIHtcbiAgICAgICAgdGhpcy5jb25maWcub2ZmbGluZVF1ZXVlQmVoYXZpb3IgPSBvZmZsaW5lUXVldWVCZWhhdmlvcjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyB0aGUgdGltZSBpbnRlcnZhbCB0byB3YWl0IGFmdGVyIHNlbmRpbmcgYSBQSU5HUkVRIGZvciBhIFBJTkdSRVNQIHRvIGFycml2ZS4gIElmIG9uZSBkb2VzIG5vdCBhcnJpdmUsXG4gICAgICogdGhlIGNsaWVudCB3aWxsIGNsb3NlIHRoZSBjdXJyZW50IGNvbm5lY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGluZ1RpbWVvdXRNcyB0aW1lIGludGVydmFsIHRvIHdhaXQgYWZ0ZXIgc2VuZGluZyBhIFBJTkdSRVEgZm9yIGEgUElOR1JFU1AgdG8gYXJyaXZlXG4gICAgICpcbiAgICAgKiBAZ3JvdXAgTm9kZS1vbmx5XG4gICAgICovXG4gICAgd2l0aFBpbmdUaW1lb3V0TXMocGluZ1RpbWVvdXRNcykge1xuICAgICAgICB0aGlzLmNvbmZpZy5waW5nVGltZW91dE1zID0gcGluZ1RpbWVvdXRNcztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyB0aGUgdGltZSBpbnRlcnZhbCB0byB3YWl0IGZvciBhbiBhY2sgYWZ0ZXIgc2VuZGluZyBhIFFvUyAxKyBQVUJMSVNILCBTVUJTQ1JJQkUsIG9yIFVOU1VCU0NSSUJFIGJlZm9yZVxuICAgICAqIGZhaWxpbmcgdGhlIG9wZXJhdGlvbi4gIERlZmF1bHRzIHRvIG5vIHRpbWVvdXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWNrVGltZW91dFNlY29uZHMgdGhlIHRpbWUgaW50ZXJ2YWwgdG8gd2FpdCBmb3IgYW4gYWNrIGFmdGVyIHNlbmRpbmcgYSBRb1MgMSsgUFVCTElTSCwgU1VCU0NSSUJFLFxuICAgICAqIG9yIFVOU1VCU0NSSUJFIGJlZm9yZSBmYWlsaW5nIHRoZSBvcGVyYXRpb25cbiAgICAgKlxuICAgICAqIEBncm91cCBOb2RlLW9ubHlcbiAgICAgKi9cbiAgICB3aXRoQWNrVGltZW91dFNlY29uZHMoYWNrVGltZW91dFNlY29uZHMpIHtcbiAgICAgICAgdGhpcy5jb25maWcuYWNrVGltZW91dFNlY29uZHMgPSBhY2tUaW1lb3V0U2Vjb25kcztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyB0aGUgc29ja2V0IHByb3BlcnRpZXMgb2YgdGhlIHVuZGVybHlpbmcgTVFUVCBjb25uZWN0aW9ucyBtYWRlIGJ5IHRoZSBjbGllbnQuICBMZWF2ZSB1bmRlZmluZWQgdG8gdXNlXG4gICAgICogZGVmYXVsdHMgKG5vIFRDUCBrZWVwIGFsaXZlLCAxMCBzZWNvbmQgc29ja2V0IHRpbWVvdXQpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNvY2tldE9wdGlvbnMgc29ja2V0IHByb3BlcnRpZXMgb2YgdGhlIHVuZGVybHlpbmcgTVFUVCBjb25uZWN0aW9ucyBtYWRlIGJ5IHRoZSBjbGllbnRcbiAgICAgKlxuICAgICAqIEBncm91cCBOb2RlLW9ubHlcbiAgICAgKi9cbiAgICB3aXRoU29ja2V0T3B0aW9ucyhzb2NrZXRPcHRpb25zKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLnNvY2tldE9wdGlvbnMgPSBzb2NrZXRPcHRpb25zO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzICh0dW5uZWxpbmcpIEhUVFAgcHJveHkgdXNhZ2Ugd2hlbiBlc3RhYmxpc2hpbmcgTVFUVCBjb25uZWN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBodHRwUHJveHlPcHRpb25zIEhUVFAgcHJveHkgb3B0aW9ucyB0byB1c2Ugd2hlbiBlc3RhYmxpc2hpbmcgTVFUVCBjb25uZWN0aW9uc1xuICAgICAqXG4gICAgICogQGdyb3VwIE5vZGUtb25seVxuICAgICAqL1xuICAgIHdpdGhIdHRwUHJveHlPcHRpb25zKGh0dHBQcm94eU9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5jb25maWcuaHR0cFByb3h5T3B0aW9ucyA9IGh0dHBQcm94eU9wdGlvbnM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgYWRkaXRpb25hbCBjb250cm9scyBmb3IgY2xpZW50IGJlaGF2aW9yIHdpdGggcmVzcGVjdCB0byBvcGVyYXRpb24gdmFsaWRhdGlvbiBhbmQgZmxvdyBjb250cm9sOyB0aGVzZVxuICAgICAqIGNoZWNrcyBnbyBiZXlvbmQgdGhlIGJhc2UgTVFUVDUgc3BlYyB0byByZXNwZWN0IGxpbWl0cyBvZiBzcGVjaWZpYyBNUVRUIGJyb2tlcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXh0ZW5kZWRWYWxpZGF0aW9uQW5kRmxvd0NvbnRyb2xPcHRpb25zIGFkZGl0aW9uYWwgY29udHJvbHMgZm9yIGNsaWVudCBiZWhhdmlvciB3aXRoIHJlc3BlY3QgdG8gb3BlcmF0aW9uXG4gICAgICogdmFsaWRhdGlvbiBhbmQgZmxvdyBjb250cm9sXG4gICAgICpcbiAgICAgKiBAZ3JvdXAgTm9kZS1vbmx5XG4gICAgICovXG4gICAgd2l0aEV4dGVuZGVkVmFsaWRhdGlvbkFuZEZsb3dDb250cm9sT3B0aW9ucyhleHRlbmRlZFZhbGlkYXRpb25BbmRGbG93Q29udHJvbE9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5jb25maWcuZXh0ZW5kZWRWYWxpZGF0aW9uQW5kRmxvd0NvbnRyb2xPcHRpb25zID0gZXh0ZW5kZWRWYWxpZGF0aW9uQW5kRmxvd0NvbnRyb2xPcHRpb25zO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhbiBNUVRUNSBDbGllbnQgY29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNyZWF0aW5nIG1xdHQ1IGNsaWVudHMuXG4gICAgICovXG4gICAgYnVpbGQoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy50bHNDdHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5jb25maWcudGxzQ3R4ID0gbmV3IGlvLkNsaWVudFRsc0NvbnRleHQodGhpcy50bHNDb250ZXh0T3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhpcyBpcyBhbHdheXMgc2V0IGJ5IHRoZSBjb25zdHJ1Y3RvciwgYnV0IGNoZWNrIGl0IHRvIG1ha2UgdHlwZXNjcmlwdCBoYXBweVxuICAgICAgICBpZiAodGhpcy5jb25maWcuY29ubmVjdFByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLmNvbm5lY3RQcm9wZXJ0aWVzLnVzZXJuYW1lID0gaW90X3NoYXJlZC5idWlsZE1xdHQ1RmluYWxVc2VybmFtZSh0aGlzLmN1c3RvbUF1dGhDb25maWcpO1xuICAgICAgICAgICAgaWYgKChfYSA9IHRoaXMuY3VzdG9tQXV0aENvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBhc3N3b3JkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWcuY29ubmVjdFByb3BlcnRpZXMucGFzc3dvcmQgPSAoX2IgPSB0aGlzLmN1c3RvbUF1dGhDb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5wYXNzd29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb25maWc7XG4gICAgfVxufVxuZXhwb3J0cy5Bd3NJb3RNcXR0NUNsaWVudENvbmZpZ0J1aWxkZXIgPSBBd3NJb3RNcXR0NUNsaWVudENvbmZpZ0J1aWxkZXI7XG5Bd3NJb3RNcXR0NUNsaWVudENvbmZpZ0J1aWxkZXIuREVGQVVMVF9XRUJTT0NLRVRfTVFUVF9QT1JUID0gNDQzO1xuQXdzSW90TXF0dDVDbGllbnRDb25maWdCdWlsZGVyLkRFRkFVTFRfRElSRUNUX01RVFRfUE9SVCA9IDg4ODM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hd3NfaW90X21xdHQ1LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/aws-crt/dist/native/aws_iot_mqtt5.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/aws-crt/dist/native/binding.js":
/*!*****************************************************!*\
  !*** ./node_modules/aws-crt/dist/native/binding.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n * SPDX-License-Identifier: Apache-2.0.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.cRuntime = exports.CRuntimeType = void 0;\nconst path = __importStar(__webpack_require__(/*! path */ \"path\"));\nconst os_1 = __webpack_require__(/*! os */ \"os\");\nconst fs_1 = __webpack_require__(/*! fs */ \"fs\");\nconst process_1 = __webpack_require__(/*! process */ \"process\");\nconst child_process_1 = __importDefault(__webpack_require__(/*! child_process */ \"child_process\"));\nconst CRuntimeType = Object.freeze({\n    NON_LINUX: \"cruntime\",\n    MUSL: \"musl\",\n    GLIBC: \"glibc\"\n});\nexports.CRuntimeType = CRuntimeType;\nfunction getCRuntime() {\n    if ((0, os_1.platform)() !== \"linux\") {\n        return CRuntimeType.NON_LINUX;\n    }\n    try {\n        // sometimes, ldd's output goes to stderr, so capture that too\n        // Using spawnSync because execSync treats any output to stderr as an exception.\n        const spawnedProcess = child_process_1.default.spawnSync('ldd', ['--version'], { encoding: 'utf8' });\n        const output = spawnedProcess.stdout + spawnedProcess.stderr;\n        if (output.includes(CRuntimeType.MUSL)) {\n            return CRuntimeType.MUSL;\n        }\n        else {\n            return CRuntimeType.GLIBC;\n        }\n    }\n    catch (error) {\n        return CRuntimeType.GLIBC;\n    }\n}\nconst upgrade_string = \"Please upgrade to node >=10.16.0, or use the provided browser implementation.\";\nif ('napi' in process_1.versions) {\n    // @ts-ignore\n    const napi_version = parseInt(process_1.versions['napi']);\n    if (napi_version < 4) {\n        throw new Error(\"The AWS CRT native implementation requires that NAPI version 4 be present. \" + upgrade_string);\n    }\n}\nelse {\n    throw new Error(\"The current runtime is not reporting an NAPI version. \" + upgrade_string);\n}\nconst cRuntime = getCRuntime();\nexports.cRuntime = cRuntime;\nconst binary_name = 'aws-crt-nodejs';\nconst platformDir = `${os_1.platform}-${os_1.arch}-${cRuntime}`;\nlet source_root = path.resolve(__dirname, '..', '..');\nconst dist = path.join(source_root, 'dist');\nif ((0, fs_1.existsSync)(dist)) {\n    source_root = dist;\n}\nconst bin_path = path.resolve(source_root, 'bin');\nconst search_paths = [\n    path.join(bin_path, platformDir, binary_name),\n];\nlet binding;\nfor (const path of search_paths) {\n    if ((0, fs_1.existsSync)(path + '.node')) {\n        binding = __webpack_require__(\"(ssr)/./node_modules/aws-crt/dist/native sync recursive\")(path);\n        break;\n    }\n}\nif (binding == undefined) {\n    throw new Error(\"AWS CRT binary not present in any of the following locations:\\n\\t\" + search_paths.join('\\n\\t'));\n}\nexports[\"default\"] = binding;\n//# sourceMappingURL=binding.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXdzLWNydC9kaXN0L25hdGl2ZS9iaW5kaW5nLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCLEdBQUcsb0JBQW9CO0FBQ3ZDLDBCQUEwQixtQkFBTyxDQUFDLGtCQUFNO0FBQ3hDLGFBQWEsbUJBQU8sQ0FBQyxjQUFJO0FBQ3pCLGFBQWEsbUJBQU8sQ0FBQyxjQUFJO0FBQ3pCLGtCQUFrQixtQkFBTyxDQUFDLHdCQUFTO0FBQ25DLHdDQUF3QyxtQkFBTyxDQUFDLG9DQUFlO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RixrQkFBa0I7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsdUJBQXVCLGNBQWMsR0FBRyxVQUFVLEdBQUcsU0FBUztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsK0VBQVEsSUFBSSxDQUFDO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wYXl3aW5kLy4vbm9kZV9tb2R1bGVzL2F3cy1jcnQvZGlzdC9uYXRpdmUvYmluZGluZy5qcz9kYTc3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjAuXG4gKi9cbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jUnVudGltZSA9IGV4cG9ydHMuQ1J1bnRpbWVUeXBlID0gdm9pZCAwO1xuY29uc3QgcGF0aCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwicGF0aFwiKSk7XG5jb25zdCBvc18xID0gcmVxdWlyZShcIm9zXCIpO1xuY29uc3QgZnNfMSA9IHJlcXVpcmUoXCJmc1wiKTtcbmNvbnN0IHByb2Nlc3NfMSA9IHJlcXVpcmUoXCJwcm9jZXNzXCIpO1xuY29uc3QgY2hpbGRfcHJvY2Vzc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJjaGlsZF9wcm9jZXNzXCIpKTtcbmNvbnN0IENSdW50aW1lVHlwZSA9IE9iamVjdC5mcmVlemUoe1xuICAgIE5PTl9MSU5VWDogXCJjcnVudGltZVwiLFxuICAgIE1VU0w6IFwibXVzbFwiLFxuICAgIEdMSUJDOiBcImdsaWJjXCJcbn0pO1xuZXhwb3J0cy5DUnVudGltZVR5cGUgPSBDUnVudGltZVR5cGU7XG5mdW5jdGlvbiBnZXRDUnVudGltZSgpIHtcbiAgICBpZiAoKDAsIG9zXzEucGxhdGZvcm0pKCkgIT09IFwibGludXhcIikge1xuICAgICAgICByZXR1cm4gQ1J1bnRpbWVUeXBlLk5PTl9MSU5VWDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gc29tZXRpbWVzLCBsZGQncyBvdXRwdXQgZ29lcyB0byBzdGRlcnIsIHNvIGNhcHR1cmUgdGhhdCB0b29cbiAgICAgICAgLy8gVXNpbmcgc3Bhd25TeW5jIGJlY2F1c2UgZXhlY1N5bmMgdHJlYXRzIGFueSBvdXRwdXQgdG8gc3RkZXJyIGFzIGFuIGV4Y2VwdGlvbi5cbiAgICAgICAgY29uc3Qgc3Bhd25lZFByb2Nlc3MgPSBjaGlsZF9wcm9jZXNzXzEuZGVmYXVsdC5zcGF3blN5bmMoJ2xkZCcsIFsnLS12ZXJzaW9uJ10sIHsgZW5jb2Rpbmc6ICd1dGY4JyB9KTtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gc3Bhd25lZFByb2Nlc3Muc3Rkb3V0ICsgc3Bhd25lZFByb2Nlc3Muc3RkZXJyO1xuICAgICAgICBpZiAob3V0cHV0LmluY2x1ZGVzKENSdW50aW1lVHlwZS5NVVNMKSkge1xuICAgICAgICAgICAgcmV0dXJuIENSdW50aW1lVHlwZS5NVVNMO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIENSdW50aW1lVHlwZS5HTElCQztcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIENSdW50aW1lVHlwZS5HTElCQztcbiAgICB9XG59XG5jb25zdCB1cGdyYWRlX3N0cmluZyA9IFwiUGxlYXNlIHVwZ3JhZGUgdG8gbm9kZSA+PTEwLjE2LjAsIG9yIHVzZSB0aGUgcHJvdmlkZWQgYnJvd3NlciBpbXBsZW1lbnRhdGlvbi5cIjtcbmlmICgnbmFwaScgaW4gcHJvY2Vzc18xLnZlcnNpb25zKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IG5hcGlfdmVyc2lvbiA9IHBhcnNlSW50KHByb2Nlc3NfMS52ZXJzaW9uc1snbmFwaSddKTtcbiAgICBpZiAobmFwaV92ZXJzaW9uIDwgNCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgQVdTIENSVCBuYXRpdmUgaW1wbGVtZW50YXRpb24gcmVxdWlyZXMgdGhhdCBOQVBJIHZlcnNpb24gNCBiZSBwcmVzZW50LiBcIiArIHVwZ3JhZGVfc3RyaW5nKTtcbiAgICB9XG59XG5lbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgY3VycmVudCBydW50aW1lIGlzIG5vdCByZXBvcnRpbmcgYW4gTkFQSSB2ZXJzaW9uLiBcIiArIHVwZ3JhZGVfc3RyaW5nKTtcbn1cbmNvbnN0IGNSdW50aW1lID0gZ2V0Q1J1bnRpbWUoKTtcbmV4cG9ydHMuY1J1bnRpbWUgPSBjUnVudGltZTtcbmNvbnN0IGJpbmFyeV9uYW1lID0gJ2F3cy1jcnQtbm9kZWpzJztcbmNvbnN0IHBsYXRmb3JtRGlyID0gYCR7b3NfMS5wbGF0Zm9ybX0tJHtvc18xLmFyY2h9LSR7Y1J1bnRpbWV9YDtcbmxldCBzb3VyY2Vfcm9vdCA9IHBhdGgucmVzb2x2ZShfX2Rpcm5hbWUsICcuLicsICcuLicpO1xuY29uc3QgZGlzdCA9IHBhdGguam9pbihzb3VyY2Vfcm9vdCwgJ2Rpc3QnKTtcbmlmICgoMCwgZnNfMS5leGlzdHNTeW5jKShkaXN0KSkge1xuICAgIHNvdXJjZV9yb290ID0gZGlzdDtcbn1cbmNvbnN0IGJpbl9wYXRoID0gcGF0aC5yZXNvbHZlKHNvdXJjZV9yb290LCAnYmluJyk7XG5jb25zdCBzZWFyY2hfcGF0aHMgPSBbXG4gICAgcGF0aC5qb2luKGJpbl9wYXRoLCBwbGF0Zm9ybURpciwgYmluYXJ5X25hbWUpLFxuXTtcbmxldCBiaW5kaW5nO1xuZm9yIChjb25zdCBwYXRoIG9mIHNlYXJjaF9wYXRocykge1xuICAgIGlmICgoMCwgZnNfMS5leGlzdHNTeW5jKShwYXRoICsgJy5ub2RlJykpIHtcbiAgICAgICAgYmluZGluZyA9IHJlcXVpcmUocGF0aCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbn1cbmlmIChiaW5kaW5nID09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkFXUyBDUlQgYmluYXJ5IG5vdCBwcmVzZW50IGluIGFueSBvZiB0aGUgZm9sbG93aW5nIGxvY2F0aW9uczpcXG5cXHRcIiArIHNlYXJjaF9wYXRocy5qb2luKCdcXG5cXHQnKSk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBiaW5kaW5nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmluZGluZy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/aws-crt/dist/native/binding.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/aws-crt/dist/native/checksums.js":
/*!*******************************************************!*\
  !*** ./node_modules/aws-crt/dist/native/checksums.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n * SPDX-License-Identifier: Apache-2.0.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.crc32c = exports.crc32 = void 0;\n/**\n *\n * A module containing various checksum implementations intended for streaming payloads\n *\n * @packageDocumentation\n * @module checksums\n * @mergeTarget\n */\nconst binding_1 = __importDefault(__webpack_require__(/*! ./binding */ \"(ssr)/./node_modules/aws-crt/dist/native/binding.js\"));\n/**\n * Computes an crc32 checksum.\n *\n * @param data The data to checksum\n * @param previous previous crc32 checksum result. Used if you are buffering large input.\n *\n * @category Crypto\n */\nfunction crc32(data, previous) {\n    return binding_1.default.checksums_crc32(data, previous);\n}\nexports.crc32 = crc32;\n/**\n * Computes a crc32c checksum.\n *\n * @param data The data to checksum\n * @param previous previous crc32c checksum result. Used if you are buffering large input.\n *\n * @category Crypto\n */\nfunction crc32c(data, previous) {\n    return binding_1.default.checksums_crc32c(data, previous);\n}\nexports.crc32c = crc32c;\n//# sourceMappingURL=checksums.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXdzLWNydC9kaXN0L25hdGl2ZS9jaGVja3N1bXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWMsR0FBRyxhQUFhO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsbUJBQU8sQ0FBQyxzRUFBVztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wYXl3aW5kLy4vbm9kZV9tb2R1bGVzL2F3cy1jcnQvZGlzdC9uYXRpdmUvY2hlY2tzdW1zLmpzPzJjYmIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IEFtYXpvbi5jb20sIEluYy4gb3IgaXRzIGFmZmlsaWF0ZXMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMC5cbiAqL1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmMzMmMgPSBleHBvcnRzLmNyYzMyID0gdm9pZCAwO1xuLyoqXG4gKlxuICogQSBtb2R1bGUgY29udGFpbmluZyB2YXJpb3VzIGNoZWNrc3VtIGltcGxlbWVudGF0aW9ucyBpbnRlbmRlZCBmb3Igc3RyZWFtaW5nIHBheWxvYWRzXG4gKlxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKiBAbW9kdWxlIGNoZWNrc3Vtc1xuICogQG1lcmdlVGFyZ2V0XG4gKi9cbmNvbnN0IGJpbmRpbmdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9iaW5kaW5nXCIpKTtcbi8qKlxuICogQ29tcHV0ZXMgYW4gY3JjMzIgY2hlY2tzdW0uXG4gKlxuICogQHBhcmFtIGRhdGEgVGhlIGRhdGEgdG8gY2hlY2tzdW1cbiAqIEBwYXJhbSBwcmV2aW91cyBwcmV2aW91cyBjcmMzMiBjaGVja3N1bSByZXN1bHQuIFVzZWQgaWYgeW91IGFyZSBidWZmZXJpbmcgbGFyZ2UgaW5wdXQuXG4gKlxuICogQGNhdGVnb3J5IENyeXB0b1xuICovXG5mdW5jdGlvbiBjcmMzMihkYXRhLCBwcmV2aW91cykge1xuICAgIHJldHVybiBiaW5kaW5nXzEuZGVmYXVsdC5jaGVja3N1bXNfY3JjMzIoZGF0YSwgcHJldmlvdXMpO1xufVxuZXhwb3J0cy5jcmMzMiA9IGNyYzMyO1xuLyoqXG4gKiBDb21wdXRlcyBhIGNyYzMyYyBjaGVja3N1bS5cbiAqXG4gKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byBjaGVja3N1bVxuICogQHBhcmFtIHByZXZpb3VzIHByZXZpb3VzIGNyYzMyYyBjaGVja3N1bSByZXN1bHQuIFVzZWQgaWYgeW91IGFyZSBidWZmZXJpbmcgbGFyZ2UgaW5wdXQuXG4gKlxuICogQGNhdGVnb3J5IENyeXB0b1xuICovXG5mdW5jdGlvbiBjcmMzMmMoZGF0YSwgcHJldmlvdXMpIHtcbiAgICByZXR1cm4gYmluZGluZ18xLmRlZmF1bHQuY2hlY2tzdW1zX2NyYzMyYyhkYXRhLCBwcmV2aW91cyk7XG59XG5leHBvcnRzLmNyYzMyYyA9IGNyYzMyYztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoZWNrc3Vtcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/aws-crt/dist/native/checksums.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/aws-crt/dist/native/crt.js":
/*!*************************************************!*\
  !*** ./node_modules/aws-crt/dist/native/crt.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n * SPDX-License-Identifier: Apache-2.0.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.native_memory_dump = exports.native_memory = void 0;\n/**\n *\n * A module containing some miscellaneous crt native memory queries\n *\n * @packageDocumentation\n * @module crt\n * @mergeTarget\n */\n/**\n * Memory reporting is controlled by the AWS_CRT_MEMORY_TRACING environment\n * variable. Possible values are:\n * * 0 - No tracing\n * * 1 - Track active memory usage. Incurs a small performance penalty.\n * * 2 - Track active memory usage, and also track callstacks for every allocation.\n *   This incurs a performance penalty, depending on the cost of the platform's\n *   stack unwinding/backtrace API.\n * @category System\n */\nconst binding_1 = __importDefault(__webpack_require__(/*! ./binding */ \"(ssr)/./node_modules/aws-crt/dist/native/binding.js\"));\n/**\n * If the ```AWS_CRT_MEMORY_TRACING``` is environment variable is set to 1 or 2,\n * will return the native memory usage in bytes. Otherwise, returns 0.\n * @returns The total allocated native memory, in bytes.\n *\n * @category System\n */\nfunction native_memory() {\n    return binding_1.default.native_memory();\n}\nexports.native_memory = native_memory;\n/**\n * Dumps outstanding native memory allocations. If the ```AWS_CRT_MEMORY_TRACING```\n * environment variable is set to 1 or 2, will dump all active native memory to\n * the console log.\n *\n * @category System\n */\nfunction native_memory_dump() {\n    return binding_1.default.native_memory_dump();\n}\nexports.native_memory_dump = native_memory_dump;\n//# sourceMappingURL=crt.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXdzLWNydC9kaXN0L25hdGl2ZS9jcnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDBCQUEwQixHQUFHLHFCQUFxQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsbUJBQU8sQ0FBQyxzRUFBVztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQiIsInNvdXJjZXMiOlsid2VicGFjazovL3BheXdpbmQvLi9ub2RlX21vZHVsZXMvYXdzLWNydC9kaXN0L25hdGl2ZS9jcnQuanM/M2JlNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wLlxuICovXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm5hdGl2ZV9tZW1vcnlfZHVtcCA9IGV4cG9ydHMubmF0aXZlX21lbW9yeSA9IHZvaWQgMDtcbi8qKlxuICpcbiAqIEEgbW9kdWxlIGNvbnRhaW5pbmcgc29tZSBtaXNjZWxsYW5lb3VzIGNydCBuYXRpdmUgbWVtb3J5IHF1ZXJpZXNcbiAqXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqIEBtb2R1bGUgY3J0XG4gKiBAbWVyZ2VUYXJnZXRcbiAqL1xuLyoqXG4gKiBNZW1vcnkgcmVwb3J0aW5nIGlzIGNvbnRyb2xsZWQgYnkgdGhlIEFXU19DUlRfTUVNT1JZX1RSQUNJTkcgZW52aXJvbm1lbnRcbiAqIHZhcmlhYmxlLiBQb3NzaWJsZSB2YWx1ZXMgYXJlOlxuICogKiAwIC0gTm8gdHJhY2luZ1xuICogKiAxIC0gVHJhY2sgYWN0aXZlIG1lbW9yeSB1c2FnZS4gSW5jdXJzIGEgc21hbGwgcGVyZm9ybWFuY2UgcGVuYWx0eS5cbiAqICogMiAtIFRyYWNrIGFjdGl2ZSBtZW1vcnkgdXNhZ2UsIGFuZCBhbHNvIHRyYWNrIGNhbGxzdGFja3MgZm9yIGV2ZXJ5IGFsbG9jYXRpb24uXG4gKiAgIFRoaXMgaW5jdXJzIGEgcGVyZm9ybWFuY2UgcGVuYWx0eSwgZGVwZW5kaW5nIG9uIHRoZSBjb3N0IG9mIHRoZSBwbGF0Zm9ybSdzXG4gKiAgIHN0YWNrIHVud2luZGluZy9iYWNrdHJhY2UgQVBJLlxuICogQGNhdGVnb3J5IFN5c3RlbVxuICovXG5jb25zdCBiaW5kaW5nXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vYmluZGluZ1wiKSk7XG4vKipcbiAqIElmIHRoZSBgYGBBV1NfQ1JUX01FTU9SWV9UUkFDSU5HYGBgIGlzIGVudmlyb25tZW50IHZhcmlhYmxlIGlzIHNldCB0byAxIG9yIDIsXG4gKiB3aWxsIHJldHVybiB0aGUgbmF0aXZlIG1lbW9yeSB1c2FnZSBpbiBieXRlcy4gT3RoZXJ3aXNlLCByZXR1cm5zIDAuXG4gKiBAcmV0dXJucyBUaGUgdG90YWwgYWxsb2NhdGVkIG5hdGl2ZSBtZW1vcnksIGluIGJ5dGVzLlxuICpcbiAqIEBjYXRlZ29yeSBTeXN0ZW1cbiAqL1xuZnVuY3Rpb24gbmF0aXZlX21lbW9yeSgpIHtcbiAgICByZXR1cm4gYmluZGluZ18xLmRlZmF1bHQubmF0aXZlX21lbW9yeSgpO1xufVxuZXhwb3J0cy5uYXRpdmVfbWVtb3J5ID0gbmF0aXZlX21lbW9yeTtcbi8qKlxuICogRHVtcHMgb3V0c3RhbmRpbmcgbmF0aXZlIG1lbW9yeSBhbGxvY2F0aW9ucy4gSWYgdGhlIGBgYEFXU19DUlRfTUVNT1JZX1RSQUNJTkdgYGBcbiAqIGVudmlyb25tZW50IHZhcmlhYmxlIGlzIHNldCB0byAxIG9yIDIsIHdpbGwgZHVtcCBhbGwgYWN0aXZlIG5hdGl2ZSBtZW1vcnkgdG9cbiAqIHRoZSBjb25zb2xlIGxvZy5cbiAqXG4gKiBAY2F0ZWdvcnkgU3lzdGVtXG4gKi9cbmZ1bmN0aW9uIG5hdGl2ZV9tZW1vcnlfZHVtcCgpIHtcbiAgICByZXR1cm4gYmluZGluZ18xLmRlZmF1bHQubmF0aXZlX21lbW9yeV9kdW1wKCk7XG59XG5leHBvcnRzLm5hdGl2ZV9tZW1vcnlfZHVtcCA9IG5hdGl2ZV9tZW1vcnlfZHVtcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNydC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/aws-crt/dist/native/crt.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/aws-crt/dist/native/crypto.js":
/*!****************************************************!*\
  !*** ./node_modules/aws-crt/dist/native/crypto.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n * SPDX-License-Identifier: Apache-2.0.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.hmac_sha256 = exports.Sha256Hmac = exports.hash_sha1 = exports.Sha1Hash = exports.hash_sha256 = exports.Sha256Hash = exports.hash_md5 = exports.Md5Hash = void 0;\n/**\n * A module containing support for a variety of cryptographic operations.\n *\n * @packageDocumentation\n * @module crypto\n * @mergeTarget\n */\nconst binding_1 = __importDefault(__webpack_require__(/*! ./binding */ \"(ssr)/./node_modules/aws-crt/dist/native/binding.js\"));\nconst native_resource_1 = __webpack_require__(/*! ./native_resource */ \"(ssr)/./node_modules/aws-crt/dist/native/native_resource.js\");\n/**\n * Object that allows for continuous hashing of data.\n *\n * @internal\n */\nclass Hash extends native_resource_1.NativeResource {\n    /**\n     * Hash additional data.\n     * @param data Additional data to hash\n     */\n    update(data) {\n        binding_1.default.hash_update(this.native_handle(), data);\n    }\n    /**\n     * Completes the hash computation and returns the final hash digest.\n     *\n     * @param truncate_to The maximum number of bytes to receive. Leave as undefined or 0 to receive the entire digest.\n     */\n    finalize(truncate_to) {\n        return binding_1.default.hash_digest(this.native_handle(), truncate_to);\n    }\n    constructor(hash_handle) {\n        super(hash_handle);\n    }\n}\n/**\n * Object that allows for continuous MD5 hashing of data.\n *\n * @category Crypto\n */\nclass Md5Hash extends Hash {\n    constructor() {\n        super(binding_1.default.hash_md5_new());\n    }\n}\nexports.Md5Hash = Md5Hash;\n/**\n * Computes an MD5 hash. Use this if you don't need to stream the data you're hashing and can load the entire input\n * into memory.\n *\n * @param data The data to hash\n * @param truncate_to The maximum number of bytes to receive. Leave as undefined or 0 to receive the entire digest.\n *\n * @category Crypto\n */\nfunction hash_md5(data, truncate_to) {\n    return binding_1.default.hash_md5_compute(data, truncate_to);\n}\nexports.hash_md5 = hash_md5;\n/**\n * Object that allows for continuous SHA256 hashing of data.\n *\n * @category Crypto\n */\nclass Sha256Hash extends Hash {\n    constructor() {\n        super(binding_1.default.hash_sha256_new());\n    }\n}\nexports.Sha256Hash = Sha256Hash;\n/**\n * Computes an SHA256 hash. Use this if you don't need to stream the data you're hashing and can load the entire input\n * into memory.\n *\n * @param data The data to hash\n * @param truncate_to The maximum number of bytes to receive. Leave as undefined or 0 to receive the entire digest.\n *\n * @category Crypto\n */\nfunction hash_sha256(data, truncate_to) {\n    return binding_1.default.hash_sha256_compute(data, truncate_to);\n}\nexports.hash_sha256 = hash_sha256;\n/**\n * Object that allows for continuous SHA1 hashing of data.\n *\n * @category Crypto\n */\nclass Sha1Hash extends Hash {\n    constructor() {\n        super(binding_1.default.hash_sha1_new());\n    }\n}\nexports.Sha1Hash = Sha1Hash;\n/**\n * Computes an SHA1 hash. Use this if you don't need to stream the data you're hashing and can load the entire input\n * into memory.\n *\n * @param data The data to hash\n * @param truncate_to The maximum number of bytes to receive. Leave as undefined or 0 to receive the entire digest.\n *\n * @category Crypto\n */\nfunction hash_sha1(data, truncate_to) {\n    return binding_1.default.hash_sha1_compute(data, truncate_to);\n}\nexports.hash_sha1 = hash_sha1;\n/**\n * Object that allows for continuous hashing of data with an hmac secret.\n *\n * @category Crypto\n */\nclass Hmac extends native_resource_1.NativeResource {\n    /**\n     * Hash additional data.\n     *\n     * @param data additional data to hash\n     */\n    update(data) {\n        binding_1.default.hmac_update(this.native_handle(), data);\n    }\n    /**\n     * Completes the hash computation and returns the final hmac digest.\n     *\n     * @param truncate_to The maximum number of bytes to receive. Leave as undefined or 0 to receive the entire digest.\n     */\n    finalize(truncate_to) {\n        return binding_1.default.hmac_digest(this.native_handle(), truncate_to);\n    }\n    constructor(hash_handle) {\n        super(hash_handle);\n    }\n}\n/**\n * Object that allows for continuous SHA256 HMAC hashing of data.\n *\n * @category Crypto\n */\nclass Sha256Hmac extends Hmac {\n    constructor(secret) {\n        super(binding_1.default.hmac_sha256_new(secret));\n    }\n}\nexports.Sha256Hmac = Sha256Hmac;\n/**\n * Computes an SHA256 HMAC. Use this if you don't need to stream the data you're hashing and can load the entire input\n * into memory.\n *\n * @param secret The key to use for the HMAC process\n * @param data The data to hash\n * @param truncate_to The maximum number of bytes to receive. Leave as undefined or 0 to receive the entire digest.\n *\n * @category Crypto\n */\nfunction hmac_sha256(secret, data, truncate_to) {\n    return binding_1.default.hmac_sha256_compute(secret, data, truncate_to);\n}\nexports.hmac_sha256 = hmac_sha256;\n//# sourceMappingURL=crypto.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXdzLWNydC9kaXN0L25hdGl2ZS9jcnlwdG8uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQixHQUFHLGtCQUFrQixHQUFHLGlCQUFpQixHQUFHLGdCQUFnQixHQUFHLG1CQUFtQixHQUFHLGtCQUFrQixHQUFHLGdCQUFnQixHQUFHLGVBQWU7QUFDL0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsbUJBQU8sQ0FBQyxzRUFBVztBQUNyRCwwQkFBMEIsbUJBQU8sQ0FBQyxzRkFBbUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wYXl3aW5kLy4vbm9kZV9tb2R1bGVzL2F3cy1jcnQvZGlzdC9uYXRpdmUvY3J5cHRvLmpzPzgxZGEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IEFtYXpvbi5jb20sIEluYy4gb3IgaXRzIGFmZmlsaWF0ZXMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMC5cbiAqL1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5obWFjX3NoYTI1NiA9IGV4cG9ydHMuU2hhMjU2SG1hYyA9IGV4cG9ydHMuaGFzaF9zaGExID0gZXhwb3J0cy5TaGExSGFzaCA9IGV4cG9ydHMuaGFzaF9zaGEyNTYgPSBleHBvcnRzLlNoYTI1Nkhhc2ggPSBleHBvcnRzLmhhc2hfbWQ1ID0gZXhwb3J0cy5NZDVIYXNoID0gdm9pZCAwO1xuLyoqXG4gKiBBIG1vZHVsZSBjb250YWluaW5nIHN1cHBvcnQgZm9yIGEgdmFyaWV0eSBvZiBjcnlwdG9ncmFwaGljIG9wZXJhdGlvbnMuXG4gKlxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKiBAbW9kdWxlIGNyeXB0b1xuICogQG1lcmdlVGFyZ2V0XG4gKi9cbmNvbnN0IGJpbmRpbmdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9iaW5kaW5nXCIpKTtcbmNvbnN0IG5hdGl2ZV9yZXNvdXJjZV8xID0gcmVxdWlyZShcIi4vbmF0aXZlX3Jlc291cmNlXCIpO1xuLyoqXG4gKiBPYmplY3QgdGhhdCBhbGxvd3MgZm9yIGNvbnRpbnVvdXMgaGFzaGluZyBvZiBkYXRhLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5jbGFzcyBIYXNoIGV4dGVuZHMgbmF0aXZlX3Jlc291cmNlXzEuTmF0aXZlUmVzb3VyY2Uge1xuICAgIC8qKlxuICAgICAqIEhhc2ggYWRkaXRpb25hbCBkYXRhLlxuICAgICAqIEBwYXJhbSBkYXRhIEFkZGl0aW9uYWwgZGF0YSB0byBoYXNoXG4gICAgICovXG4gICAgdXBkYXRlKGRhdGEpIHtcbiAgICAgICAgYmluZGluZ18xLmRlZmF1bHQuaGFzaF91cGRhdGUodGhpcy5uYXRpdmVfaGFuZGxlKCksIGRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wbGV0ZXMgdGhlIGhhc2ggY29tcHV0YXRpb24gYW5kIHJldHVybnMgdGhlIGZpbmFsIGhhc2ggZGlnZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHRydW5jYXRlX3RvIFRoZSBtYXhpbXVtIG51bWJlciBvZiBieXRlcyB0byByZWNlaXZlLiBMZWF2ZSBhcyB1bmRlZmluZWQgb3IgMCB0byByZWNlaXZlIHRoZSBlbnRpcmUgZGlnZXN0LlxuICAgICAqL1xuICAgIGZpbmFsaXplKHRydW5jYXRlX3RvKSB7XG4gICAgICAgIHJldHVybiBiaW5kaW5nXzEuZGVmYXVsdC5oYXNoX2RpZ2VzdCh0aGlzLm5hdGl2ZV9oYW5kbGUoKSwgdHJ1bmNhdGVfdG8pO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihoYXNoX2hhbmRsZSkge1xuICAgICAgICBzdXBlcihoYXNoX2hhbmRsZSk7XG4gICAgfVxufVxuLyoqXG4gKiBPYmplY3QgdGhhdCBhbGxvd3MgZm9yIGNvbnRpbnVvdXMgTUQ1IGhhc2hpbmcgb2YgZGF0YS5cbiAqXG4gKiBAY2F0ZWdvcnkgQ3J5cHRvXG4gKi9cbmNsYXNzIE1kNUhhc2ggZXh0ZW5kcyBIYXNoIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoYmluZGluZ18xLmRlZmF1bHQuaGFzaF9tZDVfbmV3KCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuTWQ1SGFzaCA9IE1kNUhhc2g7XG4vKipcbiAqIENvbXB1dGVzIGFuIE1ENSBoYXNoLiBVc2UgdGhpcyBpZiB5b3UgZG9uJ3QgbmVlZCB0byBzdHJlYW0gdGhlIGRhdGEgeW91J3JlIGhhc2hpbmcgYW5kIGNhbiBsb2FkIHRoZSBlbnRpcmUgaW5wdXRcbiAqIGludG8gbWVtb3J5LlxuICpcbiAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRvIGhhc2hcbiAqIEBwYXJhbSB0cnVuY2F0ZV90byBUaGUgbWF4aW11bSBudW1iZXIgb2YgYnl0ZXMgdG8gcmVjZWl2ZS4gTGVhdmUgYXMgdW5kZWZpbmVkIG9yIDAgdG8gcmVjZWl2ZSB0aGUgZW50aXJlIGRpZ2VzdC5cbiAqXG4gKiBAY2F0ZWdvcnkgQ3J5cHRvXG4gKi9cbmZ1bmN0aW9uIGhhc2hfbWQ1KGRhdGEsIHRydW5jYXRlX3RvKSB7XG4gICAgcmV0dXJuIGJpbmRpbmdfMS5kZWZhdWx0Lmhhc2hfbWQ1X2NvbXB1dGUoZGF0YSwgdHJ1bmNhdGVfdG8pO1xufVxuZXhwb3J0cy5oYXNoX21kNSA9IGhhc2hfbWQ1O1xuLyoqXG4gKiBPYmplY3QgdGhhdCBhbGxvd3MgZm9yIGNvbnRpbnVvdXMgU0hBMjU2IGhhc2hpbmcgb2YgZGF0YS5cbiAqXG4gKiBAY2F0ZWdvcnkgQ3J5cHRvXG4gKi9cbmNsYXNzIFNoYTI1Nkhhc2ggZXh0ZW5kcyBIYXNoIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoYmluZGluZ18xLmRlZmF1bHQuaGFzaF9zaGEyNTZfbmV3KCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuU2hhMjU2SGFzaCA9IFNoYTI1Nkhhc2g7XG4vKipcbiAqIENvbXB1dGVzIGFuIFNIQTI1NiBoYXNoLiBVc2UgdGhpcyBpZiB5b3UgZG9uJ3QgbmVlZCB0byBzdHJlYW0gdGhlIGRhdGEgeW91J3JlIGhhc2hpbmcgYW5kIGNhbiBsb2FkIHRoZSBlbnRpcmUgaW5wdXRcbiAqIGludG8gbWVtb3J5LlxuICpcbiAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRvIGhhc2hcbiAqIEBwYXJhbSB0cnVuY2F0ZV90byBUaGUgbWF4aW11bSBudW1iZXIgb2YgYnl0ZXMgdG8gcmVjZWl2ZS4gTGVhdmUgYXMgdW5kZWZpbmVkIG9yIDAgdG8gcmVjZWl2ZSB0aGUgZW50aXJlIGRpZ2VzdC5cbiAqXG4gKiBAY2F0ZWdvcnkgQ3J5cHRvXG4gKi9cbmZ1bmN0aW9uIGhhc2hfc2hhMjU2KGRhdGEsIHRydW5jYXRlX3RvKSB7XG4gICAgcmV0dXJuIGJpbmRpbmdfMS5kZWZhdWx0Lmhhc2hfc2hhMjU2X2NvbXB1dGUoZGF0YSwgdHJ1bmNhdGVfdG8pO1xufVxuZXhwb3J0cy5oYXNoX3NoYTI1NiA9IGhhc2hfc2hhMjU2O1xuLyoqXG4gKiBPYmplY3QgdGhhdCBhbGxvd3MgZm9yIGNvbnRpbnVvdXMgU0hBMSBoYXNoaW5nIG9mIGRhdGEuXG4gKlxuICogQGNhdGVnb3J5IENyeXB0b1xuICovXG5jbGFzcyBTaGExSGFzaCBleHRlbmRzIEhhc2gge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihiaW5kaW5nXzEuZGVmYXVsdC5oYXNoX3NoYTFfbmV3KCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuU2hhMUhhc2ggPSBTaGExSGFzaDtcbi8qKlxuICogQ29tcHV0ZXMgYW4gU0hBMSBoYXNoLiBVc2UgdGhpcyBpZiB5b3UgZG9uJ3QgbmVlZCB0byBzdHJlYW0gdGhlIGRhdGEgeW91J3JlIGhhc2hpbmcgYW5kIGNhbiBsb2FkIHRoZSBlbnRpcmUgaW5wdXRcbiAqIGludG8gbWVtb3J5LlxuICpcbiAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRvIGhhc2hcbiAqIEBwYXJhbSB0cnVuY2F0ZV90byBUaGUgbWF4aW11bSBudW1iZXIgb2YgYnl0ZXMgdG8gcmVjZWl2ZS4gTGVhdmUgYXMgdW5kZWZpbmVkIG9yIDAgdG8gcmVjZWl2ZSB0aGUgZW50aXJlIGRpZ2VzdC5cbiAqXG4gKiBAY2F0ZWdvcnkgQ3J5cHRvXG4gKi9cbmZ1bmN0aW9uIGhhc2hfc2hhMShkYXRhLCB0cnVuY2F0ZV90bykge1xuICAgIHJldHVybiBiaW5kaW5nXzEuZGVmYXVsdC5oYXNoX3NoYTFfY29tcHV0ZShkYXRhLCB0cnVuY2F0ZV90byk7XG59XG5leHBvcnRzLmhhc2hfc2hhMSA9IGhhc2hfc2hhMTtcbi8qKlxuICogT2JqZWN0IHRoYXQgYWxsb3dzIGZvciBjb250aW51b3VzIGhhc2hpbmcgb2YgZGF0YSB3aXRoIGFuIGhtYWMgc2VjcmV0LlxuICpcbiAqIEBjYXRlZ29yeSBDcnlwdG9cbiAqL1xuY2xhc3MgSG1hYyBleHRlbmRzIG5hdGl2ZV9yZXNvdXJjZV8xLk5hdGl2ZVJlc291cmNlIHtcbiAgICAvKipcbiAgICAgKiBIYXNoIGFkZGl0aW9uYWwgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhIGFkZGl0aW9uYWwgZGF0YSB0byBoYXNoXG4gICAgICovXG4gICAgdXBkYXRlKGRhdGEpIHtcbiAgICAgICAgYmluZGluZ18xLmRlZmF1bHQuaG1hY191cGRhdGUodGhpcy5uYXRpdmVfaGFuZGxlKCksIGRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wbGV0ZXMgdGhlIGhhc2ggY29tcHV0YXRpb24gYW5kIHJldHVybnMgdGhlIGZpbmFsIGhtYWMgZGlnZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHRydW5jYXRlX3RvIFRoZSBtYXhpbXVtIG51bWJlciBvZiBieXRlcyB0byByZWNlaXZlLiBMZWF2ZSBhcyB1bmRlZmluZWQgb3IgMCB0byByZWNlaXZlIHRoZSBlbnRpcmUgZGlnZXN0LlxuICAgICAqL1xuICAgIGZpbmFsaXplKHRydW5jYXRlX3RvKSB7XG4gICAgICAgIHJldHVybiBiaW5kaW5nXzEuZGVmYXVsdC5obWFjX2RpZ2VzdCh0aGlzLm5hdGl2ZV9oYW5kbGUoKSwgdHJ1bmNhdGVfdG8pO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihoYXNoX2hhbmRsZSkge1xuICAgICAgICBzdXBlcihoYXNoX2hhbmRsZSk7XG4gICAgfVxufVxuLyoqXG4gKiBPYmplY3QgdGhhdCBhbGxvd3MgZm9yIGNvbnRpbnVvdXMgU0hBMjU2IEhNQUMgaGFzaGluZyBvZiBkYXRhLlxuICpcbiAqIEBjYXRlZ29yeSBDcnlwdG9cbiAqL1xuY2xhc3MgU2hhMjU2SG1hYyBleHRlbmRzIEhtYWMge1xuICAgIGNvbnN0cnVjdG9yKHNlY3JldCkge1xuICAgICAgICBzdXBlcihiaW5kaW5nXzEuZGVmYXVsdC5obWFjX3NoYTI1Nl9uZXcoc2VjcmV0KSk7XG4gICAgfVxufVxuZXhwb3J0cy5TaGEyNTZIbWFjID0gU2hhMjU2SG1hYztcbi8qKlxuICogQ29tcHV0ZXMgYW4gU0hBMjU2IEhNQUMuIFVzZSB0aGlzIGlmIHlvdSBkb24ndCBuZWVkIHRvIHN0cmVhbSB0aGUgZGF0YSB5b3UncmUgaGFzaGluZyBhbmQgY2FuIGxvYWQgdGhlIGVudGlyZSBpbnB1dFxuICogaW50byBtZW1vcnkuXG4gKlxuICogQHBhcmFtIHNlY3JldCBUaGUga2V5IHRvIHVzZSBmb3IgdGhlIEhNQUMgcHJvY2Vzc1xuICogQHBhcmFtIGRhdGEgVGhlIGRhdGEgdG8gaGFzaFxuICogQHBhcmFtIHRydW5jYXRlX3RvIFRoZSBtYXhpbXVtIG51bWJlciBvZiBieXRlcyB0byByZWNlaXZlLiBMZWF2ZSBhcyB1bmRlZmluZWQgb3IgMCB0byByZWNlaXZlIHRoZSBlbnRpcmUgZGlnZXN0LlxuICpcbiAqIEBjYXRlZ29yeSBDcnlwdG9cbiAqL1xuZnVuY3Rpb24gaG1hY19zaGEyNTYoc2VjcmV0LCBkYXRhLCB0cnVuY2F0ZV90bykge1xuICAgIHJldHVybiBiaW5kaW5nXzEuZGVmYXVsdC5obWFjX3NoYTI1Nl9jb21wdXRlKHNlY3JldCwgZGF0YSwgdHJ1bmNhdGVfdG8pO1xufVxuZXhwb3J0cy5obWFjX3NoYTI1NiA9IGhtYWNfc2hhMjU2O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3J5cHRvLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/aws-crt/dist/native/crypto.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/aws-crt/dist/native/error.js":
/*!***************************************************!*\
  !*** ./node_modules/aws-crt/dist/native/error.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n * SPDX-License-Identifier: Apache-2.0.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CrtError = void 0;\n/**\n * Library-specific error extension type\n *\n * @packageDocumentation\n * @module error\n * @mergeTarget\n */\nconst binding_1 = __importDefault(__webpack_require__(/*! ./binding */ \"(ssr)/./node_modules/aws-crt/dist/native/binding.js\"));\n/**\n * Represents an error encountered in native code. Can also be used to convert a numeric error code into\n * a human-readable string.\n *\n * @category System\n */\nclass CrtError extends Error {\n    /** @var error - The original error. Most often an error_code, but possibly some other context */\n    constructor(error) {\n        super(extract_message(error));\n        this.error = error;\n        this.error_code = extract_code(error);\n        this.error_name = extract_name(error);\n    }\n}\nexports.CrtError = CrtError;\nfunction extract_message(error) {\n    if (typeof error === 'number') {\n        return binding_1.default.error_code_to_string(error);\n    }\n    else if (error instanceof CrtError) {\n        return error.message;\n    }\n    return error.toString();\n}\nfunction extract_code(error) {\n    if (typeof error === 'number') {\n        return error;\n    }\n    else if (error instanceof CrtError) {\n        return error.error_code;\n    }\n    return undefined;\n}\nfunction extract_name(error) {\n    if (typeof error === 'number') {\n        return binding_1.default.error_code_to_name(error);\n    }\n    else if (error instanceof CrtError) {\n        return error.error_name;\n    }\n    return undefined;\n}\n//# sourceMappingURL=error.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXdzLWNydC9kaXN0L25hdGl2ZS9lcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG1CQUFPLENBQUMsc0VBQVc7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGF5d2luZC8uL25vZGVfbW9kdWxlcy9hd3MtY3J0L2Rpc3QvbmF0aXZlL2Vycm9yLmpzPzA4ZDYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IEFtYXpvbi5jb20sIEluYy4gb3IgaXRzIGFmZmlsaWF0ZXMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMC5cbiAqL1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DcnRFcnJvciA9IHZvaWQgMDtcbi8qKlxuICogTGlicmFyeS1zcGVjaWZpYyBlcnJvciBleHRlbnNpb24gdHlwZVxuICpcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuICogQG1vZHVsZSBlcnJvclxuICogQG1lcmdlVGFyZ2V0XG4gKi9cbmNvbnN0IGJpbmRpbmdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9iaW5kaW5nXCIpKTtcbi8qKlxuICogUmVwcmVzZW50cyBhbiBlcnJvciBlbmNvdW50ZXJlZCBpbiBuYXRpdmUgY29kZS4gQ2FuIGFsc28gYmUgdXNlZCB0byBjb252ZXJ0IGEgbnVtZXJpYyBlcnJvciBjb2RlIGludG9cbiAqIGEgaHVtYW4tcmVhZGFibGUgc3RyaW5nLlxuICpcbiAqIEBjYXRlZ29yeSBTeXN0ZW1cbiAqL1xuY2xhc3MgQ3J0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgLyoqIEB2YXIgZXJyb3IgLSBUaGUgb3JpZ2luYWwgZXJyb3IuIE1vc3Qgb2Z0ZW4gYW4gZXJyb3JfY29kZSwgYnV0IHBvc3NpYmx5IHNvbWUgb3RoZXIgY29udGV4dCAqL1xuICAgIGNvbnN0cnVjdG9yKGVycm9yKSB7XG4gICAgICAgIHN1cGVyKGV4dHJhY3RfbWVzc2FnZShlcnJvcikpO1xuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgICAgIHRoaXMuZXJyb3JfY29kZSA9IGV4dHJhY3RfY29kZShlcnJvcik7XG4gICAgICAgIHRoaXMuZXJyb3JfbmFtZSA9IGV4dHJhY3RfbmFtZShlcnJvcik7XG4gICAgfVxufVxuZXhwb3J0cy5DcnRFcnJvciA9IENydEVycm9yO1xuZnVuY3Rpb24gZXh0cmFjdF9tZXNzYWdlKGVycm9yKSB7XG4gICAgaWYgKHR5cGVvZiBlcnJvciA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIGJpbmRpbmdfMS5kZWZhdWx0LmVycm9yX2NvZGVfdG9fc3RyaW5nKGVycm9yKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXJyb3IgaW5zdGFuY2VvZiBDcnRFcnJvcikge1xuICAgICAgICByZXR1cm4gZXJyb3IubWVzc2FnZTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9yLnRvU3RyaW5nKCk7XG59XG5mdW5jdGlvbiBleHRyYWN0X2NvZGUoZXJyb3IpIHtcbiAgICBpZiAodHlwZW9mIGVycm9yID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVycm9yIGluc3RhbmNlb2YgQ3J0RXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yLmVycm9yX2NvZGU7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBleHRyYWN0X25hbWUoZXJyb3IpIHtcbiAgICBpZiAodHlwZW9mIGVycm9yID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gYmluZGluZ18xLmRlZmF1bHQuZXJyb3JfY29kZV90b19uYW1lKGVycm9yKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXJyb3IgaW5zdGFuY2VvZiBDcnRFcnJvcikge1xuICAgICAgICByZXR1cm4gZXJyb3IuZXJyb3JfbmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9yLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/aws-crt/dist/native/error.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/aws-crt/dist/native/eventstream.js":
/*!*********************************************************!*\
  !*** ./node_modules/aws-crt/dist/native/eventstream.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n * SPDX-License-Identifier: Apache-2.0.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ClientStream = exports.ClientConnection = exports.MessageType = exports.MessageFlags = exports.Header = exports.HeaderType = void 0;\nconst native_resource_1 = __webpack_require__(/*! ./native_resource */ \"(ssr)/./node_modules/aws-crt/dist/native/native_resource.js\");\nconst event_1 = __webpack_require__(/*! ../common/event */ \"(ssr)/./node_modules/aws-crt/dist/common/event.js\");\nconst error_1 = __webpack_require__(/*! ./error */ \"(ssr)/./node_modules/aws-crt/dist/native/error.js\");\nconst io = __importStar(__webpack_require__(/*! ./io */ \"(ssr)/./node_modules/aws-crt/dist/native/io.js\"));\nconst eventstream_utils = __importStar(__webpack_require__(/*! ./eventstream_utils */ \"(ssr)/./node_modules/aws-crt/dist/native/eventstream_utils.js\"));\nconst promise = __importStar(__webpack_require__(/*! ../common/promise */ \"(ssr)/./node_modules/aws-crt/dist/common/promise.js\"));\nconst binding_1 = __importDefault(__webpack_require__(/*! ./binding */ \"(ssr)/./node_modules/aws-crt/dist/native/binding.js\"));\n/**\n * Node.js specific eventstream rpc native bindings\n *\n * @packageDocumentation\n * @module eventstream\n * @mergeTarget\n *\n */\n/**\n * Supported types for the value within an eventstream message header\n */\nvar HeaderType;\n(function (HeaderType) {\n    /** Value is True. No actual value is transmitted on the wire. */\n    HeaderType[HeaderType[\"BooleanTrue\"] = 0] = \"BooleanTrue\";\n    /** Value is True. No actual value is transmitted on the wire. */\n    HeaderType[HeaderType[\"BooleanFalse\"] = 1] = \"BooleanFalse\";\n    /** Value is signed 8-bit int. */\n    HeaderType[HeaderType[\"Byte\"] = 2] = \"Byte\";\n    /** Value is signed 16-bit int. */\n    HeaderType[HeaderType[\"Int16\"] = 3] = \"Int16\";\n    /** Value is signed 32-bit int. */\n    HeaderType[HeaderType[\"Int32\"] = 4] = \"Int32\";\n    /** Value is signed 64-bit int. */\n    HeaderType[HeaderType[\"Int64\"] = 5] = \"Int64\";\n    /** Value is raw bytes. */\n    HeaderType[HeaderType[\"ByteBuffer\"] = 6] = \"ByteBuffer\";\n    /** Value is a str.  Transmitted on the wire as utf-8. */\n    HeaderType[HeaderType[\"String\"] = 7] = \"String\";\n    /** Value is a posix timestamp (seconds since Unix epoch).  Transmitted on the wire as a 64-bit int. */\n    HeaderType[HeaderType[\"Timestamp\"] = 8] = \"Timestamp\";\n    /** Value is a UUID. Transmitted on the wire as 16 bytes. */\n    HeaderType[HeaderType[\"UUID\"] = 9] = \"UUID\";\n})(HeaderType = exports.HeaderType || (exports.HeaderType = {}));\nconst AWS_MAXIMUM_EVENT_STREAM_HEADER_NAME_LENGTH = 127;\n/**\n * Wrapper class for event stream message headers.  Similar to HTTP, a header is a name-value pair.  Unlike HTTP, the\n * value's wire format varies depending on a type annotation.  We provide static builder functions to help\n * ensure correct type agreement (type annotation matches actual value) at construction time.  Getting the header\n * value requires the use of a safe conversion function.\n */\nclass Header {\n    /** @internal */\n    constructor(name, type, value) {\n        this.name = name;\n        this.type = type;\n        this.value = value;\n    }\n    static validateHeaderName(name) {\n        if (name.length == 0 || name.length > AWS_MAXIMUM_EVENT_STREAM_HEADER_NAME_LENGTH) {\n            throw new error_1.CrtError(`Event stream header name (${name}) is not valid`);\n        }\n    }\n    /**\n     * Create a new boolean-valued message header\n     *\n     * @param name name of the header\n     * @param value value of the header\n     */\n    static newBoolean(name, value) {\n        Header.validateHeaderName(name);\n        if (value) {\n            return new Header(name, HeaderType.BooleanTrue);\n        }\n        else {\n            return new Header(name, HeaderType.BooleanFalse);\n        }\n    }\n    /**\n     * Create a new byte-valued message header\n     *\n     * @param name name of the header\n     * @param value value of the header\n     */\n    static newByte(name, value) {\n        Header.validateHeaderName(name);\n        if (value >= eventstream_utils.MIN_INT8 && value <= eventstream_utils.MAX_INT8 && Number.isSafeInteger(value)) {\n            return new Header(name, HeaderType.Byte, value);\n        }\n        throw new error_1.CrtError(`Illegal value for eventstream byte-valued header: ${value}`);\n    }\n    /**\n     * Create a new 16-bit-integer-valued message header\n     *\n     * @param name name of the header\n     * @param value value of the header\n     */\n    static newInt16(name, value) {\n        Header.validateHeaderName(name);\n        if (value >= eventstream_utils.MIN_INT16 && value <= eventstream_utils.MAX_INT16 && Number.isSafeInteger(value)) {\n            return new Header(name, HeaderType.Int16, value);\n        }\n        throw new error_1.CrtError(`Illegal value for eventstream int16-valued header: ${value}`);\n    }\n    /**\n     * Create a new 32-bit-integer-valued message header\n     *\n     * @param name name of the header\n     * @param value value of the header\n     */\n    static newInt32(name, value) {\n        Header.validateHeaderName(name);\n        if (value >= eventstream_utils.MIN_INT32 && value <= eventstream_utils.MAX_INT32 && Number.isSafeInteger(value)) {\n            return new Header(name, HeaderType.Int32, value);\n        }\n        throw new error_1.CrtError(`Illegal value for eventstream int32-valued header: ${value}`);\n    }\n    /**\n     * Create a new 64-bit-integer-valued message header.  number cannot represent a full 64-bit integer range but\n     * its usage is so common that this exists for convenience.  Internally, we always track 64 bit integers as\n     * bigints.\n     *\n     * @param name name of the header\n     * @param value value of the header\n     */\n    static newInt64FromNumber(name, value) {\n        Header.validateHeaderName(name);\n        if (Number.isSafeInteger(value)) {\n            return new Header(name, HeaderType.Int64, eventstream_utils.marshalInt64BigintAsBuffer(BigInt(value)));\n        }\n        throw new error_1.CrtError(`Illegal value for eventstream int64-valued header: ${value}`);\n    }\n    /**\n     * Create a new 64-bit-integer-valued message header from a big integer.\n     *\n     * @param name name of the header\n     * @param value value of the header\n     */\n    static newInt64FromBigint(name, value) {\n        Header.validateHeaderName(name);\n        if (value >= eventstream_utils.MIN_INT64 && value <= eventstream_utils.MAX_INT64) {\n            return new Header(name, HeaderType.Int64, eventstream_utils.marshalInt64BigintAsBuffer(value));\n        }\n        throw new error_1.CrtError(`Illegal value for eventstream int64-valued header: ${value}`);\n    }\n    /**\n     * Create a new byte-buffer-valued message header\n     *\n     * @param name name of the header\n     * @param value value of the header\n     */\n    static newByteBuffer(name, value) {\n        Header.validateHeaderName(name);\n        return new Header(name, HeaderType.ByteBuffer, value);\n    }\n    /**\n     * Create a new string-valued message header\n     *\n     * @param name name of the header\n     * @param value value of the header\n     */\n    static newString(name, value) {\n        Header.validateHeaderName(name);\n        return new Header(name, HeaderType.String, value);\n    }\n    /**\n     * Create a new timestamp-valued message header from an integral value in seconds since epoch.\n     *\n     * @param name name of the header\n     * @param value value of the header\n     */\n    static newTimeStampFromSecondsSinceEpoch(name, secondsSinceEpoch) {\n        Header.validateHeaderName(name);\n        if (Number.isSafeInteger(secondsSinceEpoch) && secondsSinceEpoch >= 0) {\n            return new Header(name, HeaderType.Timestamp, secondsSinceEpoch);\n        }\n        throw new error_1.CrtError(`Illegal value for eventstream timestamp-valued header: ${secondsSinceEpoch}`);\n    }\n    /**\n     * Create a new timestamp-valued message header from a date.\n     *\n     * @param name name of the header\n     * @param value value of the header\n     */\n    static newTimeStampFromDate(name, date) {\n        Header.validateHeaderName(name);\n        const secondsSinceEpoch = date.getTime();\n        if (Number.isSafeInteger(secondsSinceEpoch)) {\n            return new Header(name, HeaderType.Timestamp, secondsSinceEpoch);\n        }\n        throw new error_1.CrtError(`Illegal value for eventstream timestamp-valued header: ${date}`);\n    }\n    /**\n     * Create a new UUID-valued message header.\n     * WIP\n     *\n     * @param name name of the header\n     * @param value value of the header\n     */\n    static newUUID(name, value) {\n        Header.validateHeaderName(name);\n        if (value.byteLength == 16) {\n            return new Header(name, HeaderType.UUID, value);\n        }\n        throw new error_1.CrtError(`Illegal value for eventstream uuid-valued header: ${value}`);\n    }\n    toValue(type) {\n        if (type != this.type) {\n            throw new error_1.CrtError(`Header of type (${this.type}) cannot be converted to type (${type})`);\n        }\n        return this.value;\n    }\n    /**\n     * All conversion functions require the header's type to be appropriately matching.  There are no error-prone\n     * flexible conversion helpers.\n     */\n    /**\n     * Returns a boolean header's value.\n     */\n    asBoolean() {\n        switch (this.type) {\n            case HeaderType.BooleanFalse:\n                return false;\n            case HeaderType.BooleanTrue:\n                return true;\n            default:\n                throw new error_1.CrtError(`Header of type (${this.type}) cannot be converted to type (boolean)`);\n        }\n    }\n    /**\n     * Returns a byte header's value.\n     */\n    asByte() {\n        return this.toValue(HeaderType.Byte);\n    }\n    /**\n     * Returns a 16-bit integer header's value.\n     */\n    asInt16() {\n        return this.toValue(HeaderType.Int16);\n    }\n    /**\n     * Returns a 32-bit integer header's value.\n     */\n    asInt32() {\n        return this.toValue(HeaderType.Int32);\n    }\n    /**\n     * Returns a 64-bit integer header's value.\n     */\n    asInt64() {\n        return eventstream_utils.unmarshalInt64BigintFromBuffer(this.toValue(HeaderType.Int64));\n    }\n    /**\n     * Returns a byte buffer header's value.\n     */\n    asByteBuffer() {\n        return this.toValue(HeaderType.ByteBuffer);\n    }\n    /**\n     * Returns a string header's value.\n     */\n    asString() {\n        return this.toValue(HeaderType.String);\n    }\n    /**\n     * Returns a timestamp header's value (as seconds since epoch).\n     */\n    asTimestamp() {\n        return this.toValue(HeaderType.Timestamp);\n    }\n    /**\n     * Returns a UUID header's value.\n     */\n    asUUID() {\n        return this.toValue(HeaderType.UUID);\n    }\n}\nexports.Header = Header;\n/**\n * Flags for messages in the event-stream RPC protocol.\n *\n * Flags may be XORed together.\n * Not all flags can be used with all message types, consult documentation.\n */\nvar MessageFlags;\n(function (MessageFlags) {\n    /** Nothing */\n    MessageFlags[MessageFlags[\"None\"] = 0] = \"None\";\n    /**\n     * Connection accepted\n     *\n     * If this flag is absent from a {@link MessageType.ConnectAck ConnectAck} message, the connection has been\n     * rejected.\n     */\n    MessageFlags[MessageFlags[\"ConnectionAccepted\"] = 1] = \"ConnectionAccepted\";\n    /**\n     * Terminate stream\n     *\n     * This message may be used with any message type.\n     * The sender will close their connection after the message is written to the wire.\n     * The receiver will close their connection after delivering the message to the user.\n     */\n    MessageFlags[MessageFlags[\"TerminateStream\"] = 2] = \"TerminateStream\";\n})(MessageFlags = exports.MessageFlags || (exports.MessageFlags = {}));\n/**\n *\n * Types of messages in the event-stream RPC protocol.\n * The {@link MessageType.ApplicationMessage Application} and {@link MessageType.ApplicationError Error} message types\n * may only be sent on streams, and will never arrive as a protocol message (stream-id 0).\n *\n * For all other message types, they may only be sent as protocol messages\n * (stream-id 0), and will never arrive as a stream message.\n *\n * Different message types expect specific headers and flags, consult documentation.\n */\nvar MessageType;\n(function (MessageType) {\n    /** Application message */\n    MessageType[MessageType[\"ApplicationMessage\"] = 0] = \"ApplicationMessage\";\n    /** Application error */\n    MessageType[MessageType[\"ApplicationError\"] = 1] = \"ApplicationError\";\n    /** Ping */\n    MessageType[MessageType[\"Ping\"] = 2] = \"Ping\";\n    /** Ping response */\n    MessageType[MessageType[\"PingResponse\"] = 3] = \"PingResponse\";\n    /** Connect */\n    MessageType[MessageType[\"Connect\"] = 4] = \"Connect\";\n    /**\n     * Connect acknowledgement\n     *\n     * If the {@link MessageFlags.ConnectionAccepted ConnectionAccepted} flag is not present, the connection has been rejected.\n     */\n    MessageType[MessageType[\"ConnectAck\"] = 5] = \"ConnectAck\";\n    /**\n     * Protocol error\n     */\n    MessageType[MessageType[\"ProtocolError\"] = 6] = \"ProtocolError\";\n    /**\n     * Internal error\n     */\n    MessageType[MessageType[\"InternalError\"] = 7] = \"InternalError\";\n})(MessageType = exports.MessageType || (exports.MessageType = {}));\n/** @internal */\nfunction mapPodHeadersToJSHeaders(headers) {\n    return Array.from(headers, (header) => {\n        return new Header(header.name, header.type, header.value);\n    });\n}\n/** @internal */\nfunction mapPodMessageToJSMessage(message) {\n    let jsMessage = {\n        type: message.type,\n        flags: message.flags,\n        payload: message.payload\n    };\n    if (message.headers) {\n        jsMessage.headers = mapPodHeadersToJSHeaders(message.headers);\n    }\n    return jsMessage;\n}\n/**\n * @internal\n *\n * While not strictly necessary, the single-threaded nature of JS execution allows us to easily apply some\n * rigid constraints to the public API calls of our event stream objects.  This in turn reduces the complexity of the\n * binding cases we need to consider.\n *\n * This state value is the primary means by which we add and enforce these constraints to connection objects.\n *\n * Constraints enforced in the managed binding:\n *\n *  (1) close() may only be called once.  Once it has been called, nothing else may be called.\n *  (2) newStream() and sendMessage() may only be called after successful connection establishment and before the\n *      connection has been closed.\n *  (3) connect() may only be called once.  Combined with (1) and (2), this means that if connect() is called, it must\n *      be the first thing called.\n */\nvar ClientConnectionState;\n(function (ClientConnectionState) {\n    ClientConnectionState[ClientConnectionState[\"None\"] = 0] = \"None\";\n    ClientConnectionState[ClientConnectionState[\"Connecting\"] = 1] = \"Connecting\";\n    ClientConnectionState[ClientConnectionState[\"Connected\"] = 2] = \"Connected\";\n    ClientConnectionState[ClientConnectionState[\"Disconnected\"] = 3] = \"Disconnected\";\n    ClientConnectionState[ClientConnectionState[\"Closed\"] = 4] = \"Closed\";\n})(ClientConnectionState || (ClientConnectionState = {}));\n/**\n * Wrapper for a network connection that fulfills the client-side event stream RPC protocol contract.\n *\n * The user **must** call close() on a connection once finished with it.  Once close() has been called, no more events\n * will be emitted and all public API invocations will trigger an exception.\n */\nclass ClientConnection extends (0, native_resource_1.NativeResourceMixin)(event_1.BufferedEventEmitter) {\n    /**\n     * Configures and creates a new ClientConnection instance\n     *\n     * @param config configuration options for the event stream connection\n     */\n    constructor(config) {\n        if (config === undefined) {\n            throw new error_1.CrtError(\"Invalid configuration passed to eventstream ClientConnection constructor\");\n        }\n        super();\n        this.state = ClientConnectionState.None;\n        this._super(binding_1.default.event_stream_client_connection_new(this, config, (connection, errorCode) => { ClientConnection._s_on_disconnect(connection, errorCode); }, (connection, message) => { ClientConnection._s_on_protocol_message(connection, message); }, config.socketOptions ? config.socketOptions.native_handle() : null, config.tlsCtx ? config.tlsCtx.native_handle() : null));\n    }\n    /**\n     * Shuts down the connection (if active) and begins the process to release native resources associated with it by\n     * having the native binding release the only reference to the extern object representing the connection.  Once\n     * close() has been called, no more events will be emitted and all public API invocations will trigger an exception.\n     *\n     * Ultimately, the native resources will not be released until the connection has fully shut down and that\n     * shutdown event has reached the libuv event loop.\n     *\n     * This function **must** be called for every ClientConnection instance or native resources will leak.\n     */\n    close() {\n        if (this.state != ClientConnectionState.Closed) {\n            this.state = ClientConnectionState.Closed;\n            // invoke native binding close\n            binding_1.default.event_stream_client_connection_close(this.native_handle());\n        }\n    }\n    /**\n     * Attempts to open a network connection to the configured remote endpoint.  Returned promise will be fulfilled if\n     * the transport-level connection is successfully established, and rejected otherwise.\n     *\n     * connect() may only be called once.\n     */\n    connect(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let cleanupCancelListener = undefined;\n            let connectPromise = new Promise((resolve, reject) => {\n                if (!options) {\n                    reject(new error_1.CrtError(\"Invalid options passed to event stream ClientConnection.connect\"));\n                    return;\n                }\n                if (this.state != ClientConnectionState.None) {\n                    reject(new error_1.CrtError(`Event stream connection in a state (${this.state}) where connect() is not allowed.`));\n                    return;\n                }\n                this.state = ClientConnectionState.Connecting;\n                if (options.cancelController) {\n                    let cancel = () => {\n                        reject(new error_1.CrtError(`Event stream connection connect() cancelled by external request.`));\n                        setImmediate(() => { this.close(); });\n                    };\n                    cleanupCancelListener = options.cancelController.addListener(cancel);\n                    if (!cleanupCancelListener) {\n                        return;\n                    }\n                }\n                function curriedPromiseCallback(connection, errorCode) {\n                    return ClientConnection._s_on_connection_setup(resolve, reject, connection, errorCode);\n                }\n                try {\n                    binding_1.default.event_stream_client_connection_connect(this.native_handle(), curriedPromiseCallback);\n                }\n                catch (e) {\n                    this.state = ClientConnectionState.Disconnected;\n                    reject(e);\n                }\n            });\n            return promise.makeSelfCleaningPromise(connectPromise, cleanupCancelListener);\n        });\n    }\n    /**\n     * Attempts to send an event stream protocol message over an open connection.\n     *\n     * @param options configuration -- including the message itself -- for sending a protocol message\n     *\n     * Returns a promise that will be fulfilled when the message is successfully flushed to the wire, and rejected if\n     * an error occurs prior to that point.\n     */\n    sendProtocolMessage(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let cleanupCancelListener = undefined;\n            let sendProtocolMessagePromise = new Promise((resolve, reject) => {\n                try {\n                    if (!options) {\n                        reject(new error_1.CrtError(\"Invalid options passed to event stream ClientConnection.sendProtocolMessage\"));\n                        return;\n                    }\n                    if (!this.isConnected()) {\n                        reject(new error_1.CrtError(`Event stream connection in a state (${this.state}) where sending protocol messages is not allowed.`));\n                        return;\n                    }\n                    if (options.cancelController) {\n                        let cancel = () => {\n                            reject(new error_1.CrtError(`Event stream connection sendProtocolMessage() cancelled by external request.`));\n                            setImmediate(() => { this.close(); });\n                        };\n                        cleanupCancelListener = options.cancelController.addListener(cancel);\n                        if (!cleanupCancelListener) {\n                            return;\n                        }\n                    }\n                    // invoke native binding send message;\n                    function curriedPromiseCallback(errorCode) {\n                        return ClientConnection._s_on_connection_send_protocol_message_completion(resolve, reject, errorCode);\n                    }\n                    // invoke native binding send message;\n                    binding_1.default.event_stream_client_connection_send_protocol_message(this.native_handle(), options, curriedPromiseCallback);\n                }\n                catch (e) {\n                    reject(e);\n                }\n            });\n            return promise.makeSelfCleaningPromise(sendProtocolMessagePromise, cleanupCancelListener);\n        });\n    }\n    /**\n     * Returns true if the connection is currently open and ready-to-use, false otherwise.\n     *\n     * Internal note: Our notion of \"connected\" is intentionally not an invocation of\n     * aws_event_stream_rpc_client_connection_is_open() (whose status is an out-of-sync race condition vs. our\n     * well-defined client state)\n     */\n    isConnected() {\n        return this.state == ClientConnectionState.Connected;\n    }\n    /**\n     * Creates a new stream within the connection.\n     */\n    newStream() {\n        if (!this.isConnected()) {\n            throw new error_1.CrtError(`Event stream connection in a state (${this.state}) where creating new streams is forbidden.`);\n        }\n        return new ClientStream(this);\n    }\n    on(event, listener) {\n        super.on(event, listener);\n        return this;\n    }\n    static _s_on_connection_setup(resolve, reject, connection, errorCode) {\n        if (errorCode == 0 && connection.state == ClientConnectionState.Connecting) {\n            connection.state = ClientConnectionState.Connected;\n            resolve();\n        }\n        else {\n            if (connection.state != ClientConnectionState.Closed) {\n                connection.state = ClientConnectionState.Disconnected;\n            }\n            reject(io.error_code_to_string(errorCode));\n        }\n    }\n    static _s_on_disconnect(connection, errorCode) {\n        if (connection.state != ClientConnectionState.Closed) {\n            connection.state = ClientConnectionState.Disconnected;\n        }\n        process.nextTick(() => {\n            connection.emit('disconnection', { errorCode: errorCode });\n        });\n    }\n    static _s_on_protocol_message(connection, message) {\n        process.nextTick(() => {\n            connection.emit('protocolMessage', { message: mapPodMessageToJSMessage(message) });\n        });\n    }\n    static _s_on_connection_send_protocol_message_completion(resolve, reject, errorCode) {\n        if (errorCode == 0) {\n            resolve();\n        }\n        else {\n            reject(io.error_code_to_string(errorCode));\n        }\n    }\n}\nexports.ClientConnection = ClientConnection;\n/**\n * Event emitted when the connection is closed for any reason.\n *\n * Listener type: {@link DisconnectionListener}\n *\n * @event\n */\nClientConnection.DISCONNECTION = 'disconnection';\n/**\n * Event emitted when a protocol message is received from the remote endpoint\n *\n * Listener type: {@link MessageListener}\n *\n * @event\n */\nClientConnection.PROTOCOL_MESSAGE = 'protocolMessage';\n/**\n * @internal\n *\n * While not strictly necessary, the single-threaded nature of JS execution allows us to easily apply some\n * rigid constraints to the public API calls of our event stream objects.  This in turn reduces the complexity of the\n * binding cases we need to consider.\n *\n * This state value is the primary means by which we add and enforce these constraints to stream objects.\n *\n * Constraints enforced in the managed binding:\n *\n *  (1) close() may only be called once.  Once it has been called, nothing else may be called.\n *  (2) sendMessage() may only be called after successful stream activation and before the\n *      stream has been closed.\n *  (3) activate() may only be called once.  Combined with (1) and (2), this means that if activate() is called, it must\n *      be the first thing called.\n */\nvar ClientStreamState;\n(function (ClientStreamState) {\n    ClientStreamState[ClientStreamState[\"None\"] = 0] = \"None\";\n    ClientStreamState[ClientStreamState[\"Activating\"] = 1] = \"Activating\";\n    ClientStreamState[ClientStreamState[\"Activated\"] = 2] = \"Activated\";\n    ClientStreamState[ClientStreamState[\"Ended\"] = 3] = \"Ended\";\n    ClientStreamState[ClientStreamState[\"Closed\"] = 4] = \"Closed\";\n})(ClientStreamState || (ClientStreamState = {}));\n/**\n * Wrapper for an individual stream within an eventstream connection.\n *\n * The user **must** call close() on a stream once finished with it.  Once close() has been called, no more events\n * will be emitted and all public API invocations will trigger an exception.\n */\nclass ClientStream extends (0, native_resource_1.NativeResourceMixin)(event_1.BufferedEventEmitter) {\n    constructor(connection) {\n        super();\n        this._super(binding_1.default.event_stream_client_stream_new(this, connection.native_handle(), (stream) => { ClientStream._s_on_stream_ended(stream); }, (stream, message) => { ClientStream._s_on_stream_message(stream, message); }));\n        this.state = ClientStreamState.None;\n    }\n    /**\n     * Shuts down the stream (if active) and begins the process to release native resources associated with it by\n     * having the native binding release the only reference to the extern object representing the stream.  Once\n     * close() has been called, no more events will be emitted and all public API invocations will trigger an exception.\n     *\n     * Ultimately, the native resources will not be released until the native stream has fully shut down and that\n     * shutdown event has reached the libuv event loop.\n     *\n     * This function **must** be called for every ClientStream instance or native resources will leak.\n     */\n    close() {\n        if (this.state != ClientStreamState.Closed) {\n            this.state = ClientStreamState.Closed;\n            binding_1.default.event_stream_client_stream_close(this.native_handle());\n        }\n    }\n    /**\n     * Activates the stream, allowing it to start sending and receiving messages.  The promise completes when\n     * the activation message has been written to the wire.\n     *\n     * activate() may only be called once.\n     *\n     * @param options -- configuration data for stream activation, including operation name and initial message\n     */\n    activate(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let cleanupCancelListener = undefined;\n            let activatePromise = new Promise((resolve, reject) => {\n                try {\n                    if (this.state != ClientStreamState.None) {\n                        reject(new error_1.CrtError(`Event stream in a state (${this.state}) where activation is not allowed.`));\n                        return;\n                    }\n                    /*\n                     * Intentionally check this after the state check (so closed streams do not reach here).\n                     * Intentionally mutate state the same way a failed synchronous call to native activate does.\n                     */\n                    if (options === undefined) {\n                        this.state = ClientStreamState.Ended;\n                        reject(new error_1.CrtError(\"Invalid options passed to ClientStream.activate\"));\n                        return;\n                    }\n                    this.state = ClientStreamState.Activating;\n                    if (options.cancelController) {\n                        let cancel = () => {\n                            reject(new error_1.CrtError(`Event stream activate() cancelled by external request.`));\n                            setImmediate(() => { this.close(); });\n                        };\n                        cleanupCancelListener = options.cancelController.addListener(cancel);\n                        if (!cleanupCancelListener) {\n                            return;\n                        }\n                    }\n                    function curriedPromiseCallback(stream, errorCode) {\n                        return ClientStream._s_on_stream_activated(resolve, reject, stream, errorCode);\n                    }\n                    binding_1.default.event_stream_client_stream_activate(this.native_handle(), options, curriedPromiseCallback);\n                }\n                catch (e) {\n                    this.state = ClientStreamState.Ended;\n                    reject(e);\n                }\n            });\n            return promise.makeSelfCleaningPromise(activatePromise, cleanupCancelListener);\n        });\n    }\n    /**\n     * Attempts to send an event stream message.\n     *\n     * @param options configuration -- including the message itself -- for sending a message\n     *\n     * Returns a promise that will be fulfilled when the message is successfully flushed to the wire, and rejected if\n     * an error occurs prior to that point.\n     */\n    sendMessage(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let cleanupCancelListener = undefined;\n            let sendMessagePromise = new Promise((resolve, reject) => {\n                try {\n                    if (!options) {\n                        reject(new error_1.CrtError(\"Invalid options passed to ClientStream.sendMessage\"));\n                        return;\n                    }\n                    if (this.state != ClientStreamState.Activated) {\n                        reject(new error_1.CrtError(`Event stream in a state (${this.state}) where sending messages is not allowed.`));\n                        return;\n                    }\n                    if (options.cancelController) {\n                        let cancel = () => {\n                            reject(new error_1.CrtError(`Event stream sendMessage() cancelled by external request.`));\n                            setImmediate(() => { this.close(); });\n                        };\n                        cleanupCancelListener = options.cancelController.addListener(cancel);\n                        if (!cleanupCancelListener) {\n                            return;\n                        }\n                    }\n                    function curriedPromiseCallback(errorCode) {\n                        return ClientStream._s_on_stream_send_message_completion(resolve, reject, errorCode);\n                    }\n                    // invoke native binding send message;\n                    binding_1.default.event_stream_client_stream_send_message(this.native_handle(), options, curriedPromiseCallback);\n                }\n                catch (e) {\n                    reject(e);\n                }\n            });\n            return promise.makeSelfCleaningPromise(sendMessagePromise, cleanupCancelListener);\n        });\n    }\n    /**\n     * Returns true if the stream is currently active and ready-to-use, false otherwise.\n     */\n    isActive() {\n        return this.state == ClientStreamState.Activated;\n    }\n    on(event, listener) {\n        super.on(event, listener);\n        return this;\n    }\n    static _s_on_stream_activated(resolve, reject, stream, errorCode) {\n        if (errorCode == 0 && stream.state == ClientStreamState.Activating) {\n            stream.state = ClientStreamState.Activated;\n            resolve();\n        }\n        else {\n            if (stream.state != ClientStreamState.Closed) {\n                stream.state = ClientStreamState.Ended;\n            }\n            reject(io.error_code_to_string(errorCode));\n        }\n    }\n    static _s_on_stream_send_message_completion(resolve, reject, errorCode) {\n        if (errorCode == 0) {\n            resolve();\n        }\n        else {\n            reject(io.error_code_to_string(errorCode));\n        }\n    }\n    static _s_on_stream_ended(stream) {\n        process.nextTick(() => {\n            stream.emit(ClientStream.ENDED, {});\n        });\n    }\n    static _s_on_stream_message(stream, message) {\n        process.nextTick(() => {\n            stream.emit(ClientStream.MESSAGE, { message: mapPodMessageToJSMessage(message) });\n        });\n    }\n}\nexports.ClientStream = ClientStream;\n/**\n * Event emitted when the stream is shut down for any reason.\n *\n * Listener type: {@link StreamEndedListener}\n *\n * @event\n */\nClientStream.ENDED = 'ended';\n/**\n * Event emitted when a stream message is received from the remote endpoint\n *\n * Listener type: {@link MessageListener}\n *\n * @event\n */\nClientStream.MESSAGE = 'message';\n//# sourceMappingURL=eventstream.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXdzLWNydC9kaXN0L25hdGl2ZS9ldmVudHN0cmVhbS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0IsR0FBRyx3QkFBd0IsR0FBRyxtQkFBbUIsR0FBRyxvQkFBb0IsR0FBRyxjQUFjLEdBQUcsa0JBQWtCO0FBQ2xJLDBCQUEwQixtQkFBTyxDQUFDLHNGQUFtQjtBQUNyRCxnQkFBZ0IsbUJBQU8sQ0FBQywwRUFBaUI7QUFDekMsZ0JBQWdCLG1CQUFPLENBQUMsa0VBQVM7QUFDakMsd0JBQXdCLG1CQUFPLENBQUMsNERBQU07QUFDdEMsdUNBQXVDLG1CQUFPLENBQUMsMEZBQXFCO0FBQ3BFLDZCQUE2QixtQkFBTyxDQUFDLDhFQUFtQjtBQUN4RCxrQ0FBa0MsbUJBQU8sQ0FBQyxzRUFBVztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNDQUFzQyxrQkFBa0IsS0FBSztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxLQUFLO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGLE1BQU07QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGLE1BQU07QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGLE1BQU07QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RixNQUFNO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RixNQUFNO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RkFBNkYsa0JBQWtCO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGLEtBQUs7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0YsTUFBTTtBQUM5RjtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsVUFBVSxpQ0FBaUMsS0FBSztBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELFVBQVU7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHlDQUF5QztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQ0FBMEMsb0JBQW9CLEtBQUs7QUFDcEU7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBa0QsS0FBSywwQ0FBMEM7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDBEQUEwRDtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0NBQXdDLG1CQUFtQixLQUFLO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzREFBc0Q7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0hBQW9ILDJEQUEyRCw2QkFBNkIsK0RBQStEO0FBQzNRO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RixXQUFXO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxlQUFlO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGLFdBQVc7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxlQUFlO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLFdBQVc7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHNCQUFzQjtBQUNyRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsaURBQWlELDRDQUE0QztBQUM3RixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4Q0FBOEM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUhBQXFILDBDQUEwQyx5QkFBeUIscURBQXFEO0FBQzdPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsV0FBVztBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsZUFBZTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsV0FBVztBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGVBQWU7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELDRDQUE0QztBQUM1RixTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BheXdpbmQvLi9ub2RlX21vZHVsZXMvYXdzLWNydC9kaXN0L25hdGl2ZS9ldmVudHN0cmVhbS5qcz8wZjFlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjAuXG4gKi9cbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNsaWVudFN0cmVhbSA9IGV4cG9ydHMuQ2xpZW50Q29ubmVjdGlvbiA9IGV4cG9ydHMuTWVzc2FnZVR5cGUgPSBleHBvcnRzLk1lc3NhZ2VGbGFncyA9IGV4cG9ydHMuSGVhZGVyID0gZXhwb3J0cy5IZWFkZXJUeXBlID0gdm9pZCAwO1xuY29uc3QgbmF0aXZlX3Jlc291cmNlXzEgPSByZXF1aXJlKFwiLi9uYXRpdmVfcmVzb3VyY2VcIik7XG5jb25zdCBldmVudF8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9ldmVudFwiKTtcbmNvbnN0IGVycm9yXzEgPSByZXF1aXJlKFwiLi9lcnJvclwiKTtcbmNvbnN0IGlvID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2lvXCIpKTtcbmNvbnN0IGV2ZW50c3RyZWFtX3V0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2V2ZW50c3RyZWFtX3V0aWxzXCIpKTtcbmNvbnN0IHByb21pc2UgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL2NvbW1vbi9wcm9taXNlXCIpKTtcbmNvbnN0IGJpbmRpbmdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9iaW5kaW5nXCIpKTtcbi8qKlxuICogTm9kZS5qcyBzcGVjaWZpYyBldmVudHN0cmVhbSBycGMgbmF0aXZlIGJpbmRpbmdzXG4gKlxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKiBAbW9kdWxlIGV2ZW50c3RyZWFtXG4gKiBAbWVyZ2VUYXJnZXRcbiAqXG4gKi9cbi8qKlxuICogU3VwcG9ydGVkIHR5cGVzIGZvciB0aGUgdmFsdWUgd2l0aGluIGFuIGV2ZW50c3RyZWFtIG1lc3NhZ2UgaGVhZGVyXG4gKi9cbnZhciBIZWFkZXJUeXBlO1xuKGZ1bmN0aW9uIChIZWFkZXJUeXBlKSB7XG4gICAgLyoqIFZhbHVlIGlzIFRydWUuIE5vIGFjdHVhbCB2YWx1ZSBpcyB0cmFuc21pdHRlZCBvbiB0aGUgd2lyZS4gKi9cbiAgICBIZWFkZXJUeXBlW0hlYWRlclR5cGVbXCJCb29sZWFuVHJ1ZVwiXSA9IDBdID0gXCJCb29sZWFuVHJ1ZVwiO1xuICAgIC8qKiBWYWx1ZSBpcyBUcnVlLiBObyBhY3R1YWwgdmFsdWUgaXMgdHJhbnNtaXR0ZWQgb24gdGhlIHdpcmUuICovXG4gICAgSGVhZGVyVHlwZVtIZWFkZXJUeXBlW1wiQm9vbGVhbkZhbHNlXCJdID0gMV0gPSBcIkJvb2xlYW5GYWxzZVwiO1xuICAgIC8qKiBWYWx1ZSBpcyBzaWduZWQgOC1iaXQgaW50LiAqL1xuICAgIEhlYWRlclR5cGVbSGVhZGVyVHlwZVtcIkJ5dGVcIl0gPSAyXSA9IFwiQnl0ZVwiO1xuICAgIC8qKiBWYWx1ZSBpcyBzaWduZWQgMTYtYml0IGludC4gKi9cbiAgICBIZWFkZXJUeXBlW0hlYWRlclR5cGVbXCJJbnQxNlwiXSA9IDNdID0gXCJJbnQxNlwiO1xuICAgIC8qKiBWYWx1ZSBpcyBzaWduZWQgMzItYml0IGludC4gKi9cbiAgICBIZWFkZXJUeXBlW0hlYWRlclR5cGVbXCJJbnQzMlwiXSA9IDRdID0gXCJJbnQzMlwiO1xuICAgIC8qKiBWYWx1ZSBpcyBzaWduZWQgNjQtYml0IGludC4gKi9cbiAgICBIZWFkZXJUeXBlW0hlYWRlclR5cGVbXCJJbnQ2NFwiXSA9IDVdID0gXCJJbnQ2NFwiO1xuICAgIC8qKiBWYWx1ZSBpcyByYXcgYnl0ZXMuICovXG4gICAgSGVhZGVyVHlwZVtIZWFkZXJUeXBlW1wiQnl0ZUJ1ZmZlclwiXSA9IDZdID0gXCJCeXRlQnVmZmVyXCI7XG4gICAgLyoqIFZhbHVlIGlzIGEgc3RyLiAgVHJhbnNtaXR0ZWQgb24gdGhlIHdpcmUgYXMgdXRmLTguICovXG4gICAgSGVhZGVyVHlwZVtIZWFkZXJUeXBlW1wiU3RyaW5nXCJdID0gN10gPSBcIlN0cmluZ1wiO1xuICAgIC8qKiBWYWx1ZSBpcyBhIHBvc2l4IHRpbWVzdGFtcCAoc2Vjb25kcyBzaW5jZSBVbml4IGVwb2NoKS4gIFRyYW5zbWl0dGVkIG9uIHRoZSB3aXJlIGFzIGEgNjQtYml0IGludC4gKi9cbiAgICBIZWFkZXJUeXBlW0hlYWRlclR5cGVbXCJUaW1lc3RhbXBcIl0gPSA4XSA9IFwiVGltZXN0YW1wXCI7XG4gICAgLyoqIFZhbHVlIGlzIGEgVVVJRC4gVHJhbnNtaXR0ZWQgb24gdGhlIHdpcmUgYXMgMTYgYnl0ZXMuICovXG4gICAgSGVhZGVyVHlwZVtIZWFkZXJUeXBlW1wiVVVJRFwiXSA9IDldID0gXCJVVUlEXCI7XG59KShIZWFkZXJUeXBlID0gZXhwb3J0cy5IZWFkZXJUeXBlIHx8IChleHBvcnRzLkhlYWRlclR5cGUgPSB7fSkpO1xuY29uc3QgQVdTX01BWElNVU1fRVZFTlRfU1RSRUFNX0hFQURFUl9OQU1FX0xFTkdUSCA9IDEyNztcbi8qKlxuICogV3JhcHBlciBjbGFzcyBmb3IgZXZlbnQgc3RyZWFtIG1lc3NhZ2UgaGVhZGVycy4gIFNpbWlsYXIgdG8gSFRUUCwgYSBoZWFkZXIgaXMgYSBuYW1lLXZhbHVlIHBhaXIuICBVbmxpa2UgSFRUUCwgdGhlXG4gKiB2YWx1ZSdzIHdpcmUgZm9ybWF0IHZhcmllcyBkZXBlbmRpbmcgb24gYSB0eXBlIGFubm90YXRpb24uICBXZSBwcm92aWRlIHN0YXRpYyBidWlsZGVyIGZ1bmN0aW9ucyB0byBoZWxwXG4gKiBlbnN1cmUgY29ycmVjdCB0eXBlIGFncmVlbWVudCAodHlwZSBhbm5vdGF0aW9uIG1hdGNoZXMgYWN0dWFsIHZhbHVlKSBhdCBjb25zdHJ1Y3Rpb24gdGltZS4gIEdldHRpbmcgdGhlIGhlYWRlclxuICogdmFsdWUgcmVxdWlyZXMgdGhlIHVzZSBvZiBhIHNhZmUgY29udmVyc2lvbiBmdW5jdGlvbi5cbiAqL1xuY2xhc3MgSGVhZGVyIHtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgY29uc3RydWN0b3IobmFtZSwgdHlwZSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBzdGF0aWMgdmFsaWRhdGVIZWFkZXJOYW1lKG5hbWUpIHtcbiAgICAgICAgaWYgKG5hbWUubGVuZ3RoID09IDAgfHwgbmFtZS5sZW5ndGggPiBBV1NfTUFYSU1VTV9FVkVOVF9TVFJFQU1fSEVBREVSX05BTUVfTEVOR1RIKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JfMS5DcnRFcnJvcihgRXZlbnQgc3RyZWFtIGhlYWRlciBuYW1lICgke25hbWV9KSBpcyBub3QgdmFsaWRgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgYm9vbGVhbi12YWx1ZWQgbWVzc2FnZSBoZWFkZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIG5hbWUgb2YgdGhlIGhlYWRlclxuICAgICAqIEBwYXJhbSB2YWx1ZSB2YWx1ZSBvZiB0aGUgaGVhZGVyXG4gICAgICovXG4gICAgc3RhdGljIG5ld0Jvb2xlYW4obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgSGVhZGVyLnZhbGlkYXRlSGVhZGVyTmFtZShuYW1lKTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEhlYWRlcihuYW1lLCBIZWFkZXJUeXBlLkJvb2xlYW5UcnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSGVhZGVyKG5hbWUsIEhlYWRlclR5cGUuQm9vbGVhbkZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgYnl0ZS12YWx1ZWQgbWVzc2FnZSBoZWFkZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIG5hbWUgb2YgdGhlIGhlYWRlclxuICAgICAqIEBwYXJhbSB2YWx1ZSB2YWx1ZSBvZiB0aGUgaGVhZGVyXG4gICAgICovXG4gICAgc3RhdGljIG5ld0J5dGUobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgSGVhZGVyLnZhbGlkYXRlSGVhZGVyTmFtZShuYW1lKTtcbiAgICAgICAgaWYgKHZhbHVlID49IGV2ZW50c3RyZWFtX3V0aWxzLk1JTl9JTlQ4ICYmIHZhbHVlIDw9IGV2ZW50c3RyZWFtX3V0aWxzLk1BWF9JTlQ4ICYmIE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBIZWFkZXIobmFtZSwgSGVhZGVyVHlwZS5CeXRlLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IGVycm9yXzEuQ3J0RXJyb3IoYElsbGVnYWwgdmFsdWUgZm9yIGV2ZW50c3RyZWFtIGJ5dGUtdmFsdWVkIGhlYWRlcjogJHt2YWx1ZX1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IDE2LWJpdC1pbnRlZ2VyLXZhbHVlZCBtZXNzYWdlIGhlYWRlclxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgbmFtZSBvZiB0aGUgaGVhZGVyXG4gICAgICogQHBhcmFtIHZhbHVlIHZhbHVlIG9mIHRoZSBoZWFkZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgbmV3SW50MTYobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgSGVhZGVyLnZhbGlkYXRlSGVhZGVyTmFtZShuYW1lKTtcbiAgICAgICAgaWYgKHZhbHVlID49IGV2ZW50c3RyZWFtX3V0aWxzLk1JTl9JTlQxNiAmJiB2YWx1ZSA8PSBldmVudHN0cmVhbV91dGlscy5NQVhfSU5UMTYgJiYgTnVtYmVyLmlzU2FmZUludGVnZXIodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEhlYWRlcihuYW1lLCBIZWFkZXJUeXBlLkludDE2LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IGVycm9yXzEuQ3J0RXJyb3IoYElsbGVnYWwgdmFsdWUgZm9yIGV2ZW50c3RyZWFtIGludDE2LXZhbHVlZCBoZWFkZXI6ICR7dmFsdWV9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyAzMi1iaXQtaW50ZWdlci12YWx1ZWQgbWVzc2FnZSBoZWFkZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIG5hbWUgb2YgdGhlIGhlYWRlclxuICAgICAqIEBwYXJhbSB2YWx1ZSB2YWx1ZSBvZiB0aGUgaGVhZGVyXG4gICAgICovXG4gICAgc3RhdGljIG5ld0ludDMyKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIEhlYWRlci52YWxpZGF0ZUhlYWRlck5hbWUobmFtZSk7XG4gICAgICAgIGlmICh2YWx1ZSA+PSBldmVudHN0cmVhbV91dGlscy5NSU5fSU5UMzIgJiYgdmFsdWUgPD0gZXZlbnRzdHJlYW1fdXRpbHMuTUFYX0lOVDMyICYmIE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBIZWFkZXIobmFtZSwgSGVhZGVyVHlwZS5JbnQzMiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBlcnJvcl8xLkNydEVycm9yKGBJbGxlZ2FsIHZhbHVlIGZvciBldmVudHN0cmVhbSBpbnQzMi12YWx1ZWQgaGVhZGVyOiAke3ZhbHVlfWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgNjQtYml0LWludGVnZXItdmFsdWVkIG1lc3NhZ2UgaGVhZGVyLiAgbnVtYmVyIGNhbm5vdCByZXByZXNlbnQgYSBmdWxsIDY0LWJpdCBpbnRlZ2VyIHJhbmdlIGJ1dFxuICAgICAqIGl0cyB1c2FnZSBpcyBzbyBjb21tb24gdGhhdCB0aGlzIGV4aXN0cyBmb3IgY29udmVuaWVuY2UuICBJbnRlcm5hbGx5LCB3ZSBhbHdheXMgdHJhY2sgNjQgYml0IGludGVnZXJzIGFzXG4gICAgICogYmlnaW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIG5hbWUgb2YgdGhlIGhlYWRlclxuICAgICAqIEBwYXJhbSB2YWx1ZSB2YWx1ZSBvZiB0aGUgaGVhZGVyXG4gICAgICovXG4gICAgc3RhdGljIG5ld0ludDY0RnJvbU51bWJlcihuYW1lLCB2YWx1ZSkge1xuICAgICAgICBIZWFkZXIudmFsaWRhdGVIZWFkZXJOYW1lKG5hbWUpO1xuICAgICAgICBpZiAoTnVtYmVyLmlzU2FmZUludGVnZXIodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEhlYWRlcihuYW1lLCBIZWFkZXJUeXBlLkludDY0LCBldmVudHN0cmVhbV91dGlscy5tYXJzaGFsSW50NjRCaWdpbnRBc0J1ZmZlcihCaWdJbnQodmFsdWUpKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IGVycm9yXzEuQ3J0RXJyb3IoYElsbGVnYWwgdmFsdWUgZm9yIGV2ZW50c3RyZWFtIGludDY0LXZhbHVlZCBoZWFkZXI6ICR7dmFsdWV9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyA2NC1iaXQtaW50ZWdlci12YWx1ZWQgbWVzc2FnZSBoZWFkZXIgZnJvbSBhIGJpZyBpbnRlZ2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgbmFtZSBvZiB0aGUgaGVhZGVyXG4gICAgICogQHBhcmFtIHZhbHVlIHZhbHVlIG9mIHRoZSBoZWFkZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgbmV3SW50NjRGcm9tQmlnaW50KG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIEhlYWRlci52YWxpZGF0ZUhlYWRlck5hbWUobmFtZSk7XG4gICAgICAgIGlmICh2YWx1ZSA+PSBldmVudHN0cmVhbV91dGlscy5NSU5fSU5UNjQgJiYgdmFsdWUgPD0gZXZlbnRzdHJlYW1fdXRpbHMuTUFYX0lOVDY0KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEhlYWRlcihuYW1lLCBIZWFkZXJUeXBlLkludDY0LCBldmVudHN0cmVhbV91dGlscy5tYXJzaGFsSW50NjRCaWdpbnRBc0J1ZmZlcih2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBlcnJvcl8xLkNydEVycm9yKGBJbGxlZ2FsIHZhbHVlIGZvciBldmVudHN0cmVhbSBpbnQ2NC12YWx1ZWQgaGVhZGVyOiAke3ZhbHVlfWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgYnl0ZS1idWZmZXItdmFsdWVkIG1lc3NhZ2UgaGVhZGVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSBuYW1lIG9mIHRoZSBoZWFkZXJcbiAgICAgKiBAcGFyYW0gdmFsdWUgdmFsdWUgb2YgdGhlIGhlYWRlclxuICAgICAqL1xuICAgIHN0YXRpYyBuZXdCeXRlQnVmZmVyKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIEhlYWRlci52YWxpZGF0ZUhlYWRlck5hbWUobmFtZSk7XG4gICAgICAgIHJldHVybiBuZXcgSGVhZGVyKG5hbWUsIEhlYWRlclR5cGUuQnl0ZUJ1ZmZlciwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgc3RyaW5nLXZhbHVlZCBtZXNzYWdlIGhlYWRlclxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgbmFtZSBvZiB0aGUgaGVhZGVyXG4gICAgICogQHBhcmFtIHZhbHVlIHZhbHVlIG9mIHRoZSBoZWFkZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgbmV3U3RyaW5nKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIEhlYWRlci52YWxpZGF0ZUhlYWRlck5hbWUobmFtZSk7XG4gICAgICAgIHJldHVybiBuZXcgSGVhZGVyKG5hbWUsIEhlYWRlclR5cGUuU3RyaW5nLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyB0aW1lc3RhbXAtdmFsdWVkIG1lc3NhZ2UgaGVhZGVyIGZyb20gYW4gaW50ZWdyYWwgdmFsdWUgaW4gc2Vjb25kcyBzaW5jZSBlcG9jaC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIG5hbWUgb2YgdGhlIGhlYWRlclxuICAgICAqIEBwYXJhbSB2YWx1ZSB2YWx1ZSBvZiB0aGUgaGVhZGVyXG4gICAgICovXG4gICAgc3RhdGljIG5ld1RpbWVTdGFtcEZyb21TZWNvbmRzU2luY2VFcG9jaChuYW1lLCBzZWNvbmRzU2luY2VFcG9jaCkge1xuICAgICAgICBIZWFkZXIudmFsaWRhdGVIZWFkZXJOYW1lKG5hbWUpO1xuICAgICAgICBpZiAoTnVtYmVyLmlzU2FmZUludGVnZXIoc2Vjb25kc1NpbmNlRXBvY2gpICYmIHNlY29uZHNTaW5jZUVwb2NoID49IDApIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSGVhZGVyKG5hbWUsIEhlYWRlclR5cGUuVGltZXN0YW1wLCBzZWNvbmRzU2luY2VFcG9jaCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IGVycm9yXzEuQ3J0RXJyb3IoYElsbGVnYWwgdmFsdWUgZm9yIGV2ZW50c3RyZWFtIHRpbWVzdGFtcC12YWx1ZWQgaGVhZGVyOiAke3NlY29uZHNTaW5jZUVwb2NofWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgdGltZXN0YW1wLXZhbHVlZCBtZXNzYWdlIGhlYWRlciBmcm9tIGEgZGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIG5hbWUgb2YgdGhlIGhlYWRlclxuICAgICAqIEBwYXJhbSB2YWx1ZSB2YWx1ZSBvZiB0aGUgaGVhZGVyXG4gICAgICovXG4gICAgc3RhdGljIG5ld1RpbWVTdGFtcEZyb21EYXRlKG5hbWUsIGRhdGUpIHtcbiAgICAgICAgSGVhZGVyLnZhbGlkYXRlSGVhZGVyTmFtZShuYW1lKTtcbiAgICAgICAgY29uc3Qgc2Vjb25kc1NpbmNlRXBvY2ggPSBkYXRlLmdldFRpbWUoKTtcbiAgICAgICAgaWYgKE51bWJlci5pc1NhZmVJbnRlZ2VyKHNlY29uZHNTaW5jZUVwb2NoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBIZWFkZXIobmFtZSwgSGVhZGVyVHlwZS5UaW1lc3RhbXAsIHNlY29uZHNTaW5jZUVwb2NoKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgZXJyb3JfMS5DcnRFcnJvcihgSWxsZWdhbCB2YWx1ZSBmb3IgZXZlbnRzdHJlYW0gdGltZXN0YW1wLXZhbHVlZCBoZWFkZXI6ICR7ZGF0ZX1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IFVVSUQtdmFsdWVkIG1lc3NhZ2UgaGVhZGVyLlxuICAgICAqIFdJUFxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgbmFtZSBvZiB0aGUgaGVhZGVyXG4gICAgICogQHBhcmFtIHZhbHVlIHZhbHVlIG9mIHRoZSBoZWFkZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgbmV3VVVJRChuYW1lLCB2YWx1ZSkge1xuICAgICAgICBIZWFkZXIudmFsaWRhdGVIZWFkZXJOYW1lKG5hbWUpO1xuICAgICAgICBpZiAodmFsdWUuYnl0ZUxlbmd0aCA9PSAxNikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBIZWFkZXIobmFtZSwgSGVhZGVyVHlwZS5VVUlELCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IGVycm9yXzEuQ3J0RXJyb3IoYElsbGVnYWwgdmFsdWUgZm9yIGV2ZW50c3RyZWFtIHV1aWQtdmFsdWVkIGhlYWRlcjogJHt2YWx1ZX1gKTtcbiAgICB9XG4gICAgdG9WYWx1ZSh0eXBlKSB7XG4gICAgICAgIGlmICh0eXBlICE9IHRoaXMudHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yXzEuQ3J0RXJyb3IoYEhlYWRlciBvZiB0eXBlICgke3RoaXMudHlwZX0pIGNhbm5vdCBiZSBjb252ZXJ0ZWQgdG8gdHlwZSAoJHt0eXBlfSlgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWxsIGNvbnZlcnNpb24gZnVuY3Rpb25zIHJlcXVpcmUgdGhlIGhlYWRlcidzIHR5cGUgdG8gYmUgYXBwcm9wcmlhdGVseSBtYXRjaGluZy4gIFRoZXJlIGFyZSBubyBlcnJvci1wcm9uZVxuICAgICAqIGZsZXhpYmxlIGNvbnZlcnNpb24gaGVscGVycy5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgYm9vbGVhbiBoZWFkZXIncyB2YWx1ZS5cbiAgICAgKi9cbiAgICBhc0Jvb2xlYW4oKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIEhlYWRlclR5cGUuQm9vbGVhbkZhbHNlOlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGNhc2UgSGVhZGVyVHlwZS5Cb29sZWFuVHJ1ZTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yXzEuQ3J0RXJyb3IoYEhlYWRlciBvZiB0eXBlICgke3RoaXMudHlwZX0pIGNhbm5vdCBiZSBjb252ZXJ0ZWQgdG8gdHlwZSAoYm9vbGVhbilgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgYnl0ZSBoZWFkZXIncyB2YWx1ZS5cbiAgICAgKi9cbiAgICBhc0J5dGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvVmFsdWUoSGVhZGVyVHlwZS5CeXRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIDE2LWJpdCBpbnRlZ2VyIGhlYWRlcidzIHZhbHVlLlxuICAgICAqL1xuICAgIGFzSW50MTYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvVmFsdWUoSGVhZGVyVHlwZS5JbnQxNik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSAzMi1iaXQgaW50ZWdlciBoZWFkZXIncyB2YWx1ZS5cbiAgICAgKi9cbiAgICBhc0ludDMyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b1ZhbHVlKEhlYWRlclR5cGUuSW50MzIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgNjQtYml0IGludGVnZXIgaGVhZGVyJ3MgdmFsdWUuXG4gICAgICovXG4gICAgYXNJbnQ2NCgpIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50c3RyZWFtX3V0aWxzLnVubWFyc2hhbEludDY0QmlnaW50RnJvbUJ1ZmZlcih0aGlzLnRvVmFsdWUoSGVhZGVyVHlwZS5JbnQ2NCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgYnl0ZSBidWZmZXIgaGVhZGVyJ3MgdmFsdWUuXG4gICAgICovXG4gICAgYXNCeXRlQnVmZmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b1ZhbHVlKEhlYWRlclR5cGUuQnl0ZUJ1ZmZlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgaGVhZGVyJ3MgdmFsdWUuXG4gICAgICovXG4gICAgYXNTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvVmFsdWUoSGVhZGVyVHlwZS5TdHJpbmcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgdGltZXN0YW1wIGhlYWRlcidzIHZhbHVlIChhcyBzZWNvbmRzIHNpbmNlIGVwb2NoKS5cbiAgICAgKi9cbiAgICBhc1RpbWVzdGFtcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9WYWx1ZShIZWFkZXJUeXBlLlRpbWVzdGFtcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBVVUlEIGhlYWRlcidzIHZhbHVlLlxuICAgICAqL1xuICAgIGFzVVVJRCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9WYWx1ZShIZWFkZXJUeXBlLlVVSUQpO1xuICAgIH1cbn1cbmV4cG9ydHMuSGVhZGVyID0gSGVhZGVyO1xuLyoqXG4gKiBGbGFncyBmb3IgbWVzc2FnZXMgaW4gdGhlIGV2ZW50LXN0cmVhbSBSUEMgcHJvdG9jb2wuXG4gKlxuICogRmxhZ3MgbWF5IGJlIFhPUmVkIHRvZ2V0aGVyLlxuICogTm90IGFsbCBmbGFncyBjYW4gYmUgdXNlZCB3aXRoIGFsbCBtZXNzYWdlIHR5cGVzLCBjb25zdWx0IGRvY3VtZW50YXRpb24uXG4gKi9cbnZhciBNZXNzYWdlRmxhZ3M7XG4oZnVuY3Rpb24gKE1lc3NhZ2VGbGFncykge1xuICAgIC8qKiBOb3RoaW5nICovXG4gICAgTWVzc2FnZUZsYWdzW01lc3NhZ2VGbGFnc1tcIk5vbmVcIl0gPSAwXSA9IFwiTm9uZVwiO1xuICAgIC8qKlxuICAgICAqIENvbm5lY3Rpb24gYWNjZXB0ZWRcbiAgICAgKlxuICAgICAqIElmIHRoaXMgZmxhZyBpcyBhYnNlbnQgZnJvbSBhIHtAbGluayBNZXNzYWdlVHlwZS5Db25uZWN0QWNrIENvbm5lY3RBY2t9IG1lc3NhZ2UsIHRoZSBjb25uZWN0aW9uIGhhcyBiZWVuXG4gICAgICogcmVqZWN0ZWQuXG4gICAgICovXG4gICAgTWVzc2FnZUZsYWdzW01lc3NhZ2VGbGFnc1tcIkNvbm5lY3Rpb25BY2NlcHRlZFwiXSA9IDFdID0gXCJDb25uZWN0aW9uQWNjZXB0ZWRcIjtcbiAgICAvKipcbiAgICAgKiBUZXJtaW5hdGUgc3RyZWFtXG4gICAgICpcbiAgICAgKiBUaGlzIG1lc3NhZ2UgbWF5IGJlIHVzZWQgd2l0aCBhbnkgbWVzc2FnZSB0eXBlLlxuICAgICAqIFRoZSBzZW5kZXIgd2lsbCBjbG9zZSB0aGVpciBjb25uZWN0aW9uIGFmdGVyIHRoZSBtZXNzYWdlIGlzIHdyaXR0ZW4gdG8gdGhlIHdpcmUuXG4gICAgICogVGhlIHJlY2VpdmVyIHdpbGwgY2xvc2UgdGhlaXIgY29ubmVjdGlvbiBhZnRlciBkZWxpdmVyaW5nIHRoZSBtZXNzYWdlIHRvIHRoZSB1c2VyLlxuICAgICAqL1xuICAgIE1lc3NhZ2VGbGFnc1tNZXNzYWdlRmxhZ3NbXCJUZXJtaW5hdGVTdHJlYW1cIl0gPSAyXSA9IFwiVGVybWluYXRlU3RyZWFtXCI7XG59KShNZXNzYWdlRmxhZ3MgPSBleHBvcnRzLk1lc3NhZ2VGbGFncyB8fCAoZXhwb3J0cy5NZXNzYWdlRmxhZ3MgPSB7fSkpO1xuLyoqXG4gKlxuICogVHlwZXMgb2YgbWVzc2FnZXMgaW4gdGhlIGV2ZW50LXN0cmVhbSBSUEMgcHJvdG9jb2wuXG4gKiBUaGUge0BsaW5rIE1lc3NhZ2VUeXBlLkFwcGxpY2F0aW9uTWVzc2FnZSBBcHBsaWNhdGlvbn0gYW5kIHtAbGluayBNZXNzYWdlVHlwZS5BcHBsaWNhdGlvbkVycm9yIEVycm9yfSBtZXNzYWdlIHR5cGVzXG4gKiBtYXkgb25seSBiZSBzZW50IG9uIHN0cmVhbXMsIGFuZCB3aWxsIG5ldmVyIGFycml2ZSBhcyBhIHByb3RvY29sIG1lc3NhZ2UgKHN0cmVhbS1pZCAwKS5cbiAqXG4gKiBGb3IgYWxsIG90aGVyIG1lc3NhZ2UgdHlwZXMsIHRoZXkgbWF5IG9ubHkgYmUgc2VudCBhcyBwcm90b2NvbCBtZXNzYWdlc1xuICogKHN0cmVhbS1pZCAwKSwgYW5kIHdpbGwgbmV2ZXIgYXJyaXZlIGFzIGEgc3RyZWFtIG1lc3NhZ2UuXG4gKlxuICogRGlmZmVyZW50IG1lc3NhZ2UgdHlwZXMgZXhwZWN0IHNwZWNpZmljIGhlYWRlcnMgYW5kIGZsYWdzLCBjb25zdWx0IGRvY3VtZW50YXRpb24uXG4gKi9cbnZhciBNZXNzYWdlVHlwZTtcbihmdW5jdGlvbiAoTWVzc2FnZVR5cGUpIHtcbiAgICAvKiogQXBwbGljYXRpb24gbWVzc2FnZSAqL1xuICAgIE1lc3NhZ2VUeXBlW01lc3NhZ2VUeXBlW1wiQXBwbGljYXRpb25NZXNzYWdlXCJdID0gMF0gPSBcIkFwcGxpY2F0aW9uTWVzc2FnZVwiO1xuICAgIC8qKiBBcHBsaWNhdGlvbiBlcnJvciAqL1xuICAgIE1lc3NhZ2VUeXBlW01lc3NhZ2VUeXBlW1wiQXBwbGljYXRpb25FcnJvclwiXSA9IDFdID0gXCJBcHBsaWNhdGlvbkVycm9yXCI7XG4gICAgLyoqIFBpbmcgKi9cbiAgICBNZXNzYWdlVHlwZVtNZXNzYWdlVHlwZVtcIlBpbmdcIl0gPSAyXSA9IFwiUGluZ1wiO1xuICAgIC8qKiBQaW5nIHJlc3BvbnNlICovXG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJQaW5nUmVzcG9uc2VcIl0gPSAzXSA9IFwiUGluZ1Jlc3BvbnNlXCI7XG4gICAgLyoqIENvbm5lY3QgKi9cbiAgICBNZXNzYWdlVHlwZVtNZXNzYWdlVHlwZVtcIkNvbm5lY3RcIl0gPSA0XSA9IFwiQ29ubmVjdFwiO1xuICAgIC8qKlxuICAgICAqIENvbm5lY3QgYWNrbm93bGVkZ2VtZW50XG4gICAgICpcbiAgICAgKiBJZiB0aGUge0BsaW5rIE1lc3NhZ2VGbGFncy5Db25uZWN0aW9uQWNjZXB0ZWQgQ29ubmVjdGlvbkFjY2VwdGVkfSBmbGFnIGlzIG5vdCBwcmVzZW50LCB0aGUgY29ubmVjdGlvbiBoYXMgYmVlbiByZWplY3RlZC5cbiAgICAgKi9cbiAgICBNZXNzYWdlVHlwZVtNZXNzYWdlVHlwZVtcIkNvbm5lY3RBY2tcIl0gPSA1XSA9IFwiQ29ubmVjdEFja1wiO1xuICAgIC8qKlxuICAgICAqIFByb3RvY29sIGVycm9yXG4gICAgICovXG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJQcm90b2NvbEVycm9yXCJdID0gNl0gPSBcIlByb3RvY29sRXJyb3JcIjtcbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBlcnJvclxuICAgICAqL1xuICAgIE1lc3NhZ2VUeXBlW01lc3NhZ2VUeXBlW1wiSW50ZXJuYWxFcnJvclwiXSA9IDddID0gXCJJbnRlcm5hbEVycm9yXCI7XG59KShNZXNzYWdlVHlwZSA9IGV4cG9ydHMuTWVzc2FnZVR5cGUgfHwgKGV4cG9ydHMuTWVzc2FnZVR5cGUgPSB7fSkpO1xuLyoqIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gbWFwUG9kSGVhZGVyc1RvSlNIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShoZWFkZXJzLCAoaGVhZGVyKSA9PiB7XG4gICAgICAgIHJldHVybiBuZXcgSGVhZGVyKGhlYWRlci5uYW1lLCBoZWFkZXIudHlwZSwgaGVhZGVyLnZhbHVlKTtcbiAgICB9KTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIG1hcFBvZE1lc3NhZ2VUb0pTTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgbGV0IGpzTWVzc2FnZSA9IHtcbiAgICAgICAgdHlwZTogbWVzc2FnZS50eXBlLFxuICAgICAgICBmbGFnczogbWVzc2FnZS5mbGFncyxcbiAgICAgICAgcGF5bG9hZDogbWVzc2FnZS5wYXlsb2FkXG4gICAgfTtcbiAgICBpZiAobWVzc2FnZS5oZWFkZXJzKSB7XG4gICAgICAgIGpzTWVzc2FnZS5oZWFkZXJzID0gbWFwUG9kSGVhZGVyc1RvSlNIZWFkZXJzKG1lc3NhZ2UuaGVhZGVycyk7XG4gICAgfVxuICAgIHJldHVybiBqc01lc3NhZ2U7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICpcbiAqIFdoaWxlIG5vdCBzdHJpY3RseSBuZWNlc3NhcnksIHRoZSBzaW5nbGUtdGhyZWFkZWQgbmF0dXJlIG9mIEpTIGV4ZWN1dGlvbiBhbGxvd3MgdXMgdG8gZWFzaWx5IGFwcGx5IHNvbWVcbiAqIHJpZ2lkIGNvbnN0cmFpbnRzIHRvIHRoZSBwdWJsaWMgQVBJIGNhbGxzIG9mIG91ciBldmVudCBzdHJlYW0gb2JqZWN0cy4gIFRoaXMgaW4gdHVybiByZWR1Y2VzIHRoZSBjb21wbGV4aXR5IG9mIHRoZVxuICogYmluZGluZyBjYXNlcyB3ZSBuZWVkIHRvIGNvbnNpZGVyLlxuICpcbiAqIFRoaXMgc3RhdGUgdmFsdWUgaXMgdGhlIHByaW1hcnkgbWVhbnMgYnkgd2hpY2ggd2UgYWRkIGFuZCBlbmZvcmNlIHRoZXNlIGNvbnN0cmFpbnRzIHRvIGNvbm5lY3Rpb24gb2JqZWN0cy5cbiAqXG4gKiBDb25zdHJhaW50cyBlbmZvcmNlZCBpbiB0aGUgbWFuYWdlZCBiaW5kaW5nOlxuICpcbiAqICAoMSkgY2xvc2UoKSBtYXkgb25seSBiZSBjYWxsZWQgb25jZS4gIE9uY2UgaXQgaGFzIGJlZW4gY2FsbGVkLCBub3RoaW5nIGVsc2UgbWF5IGJlIGNhbGxlZC5cbiAqICAoMikgbmV3U3RyZWFtKCkgYW5kIHNlbmRNZXNzYWdlKCkgbWF5IG9ubHkgYmUgY2FsbGVkIGFmdGVyIHN1Y2Nlc3NmdWwgY29ubmVjdGlvbiBlc3RhYmxpc2htZW50IGFuZCBiZWZvcmUgdGhlXG4gKiAgICAgIGNvbm5lY3Rpb24gaGFzIGJlZW4gY2xvc2VkLlxuICogICgzKSBjb25uZWN0KCkgbWF5IG9ubHkgYmUgY2FsbGVkIG9uY2UuICBDb21iaW5lZCB3aXRoICgxKSBhbmQgKDIpLCB0aGlzIG1lYW5zIHRoYXQgaWYgY29ubmVjdCgpIGlzIGNhbGxlZCwgaXQgbXVzdFxuICogICAgICBiZSB0aGUgZmlyc3QgdGhpbmcgY2FsbGVkLlxuICovXG52YXIgQ2xpZW50Q29ubmVjdGlvblN0YXRlO1xuKGZ1bmN0aW9uIChDbGllbnRDb25uZWN0aW9uU3RhdGUpIHtcbiAgICBDbGllbnRDb25uZWN0aW9uU3RhdGVbQ2xpZW50Q29ubmVjdGlvblN0YXRlW1wiTm9uZVwiXSA9IDBdID0gXCJOb25lXCI7XG4gICAgQ2xpZW50Q29ubmVjdGlvblN0YXRlW0NsaWVudENvbm5lY3Rpb25TdGF0ZVtcIkNvbm5lY3RpbmdcIl0gPSAxXSA9IFwiQ29ubmVjdGluZ1wiO1xuICAgIENsaWVudENvbm5lY3Rpb25TdGF0ZVtDbGllbnRDb25uZWN0aW9uU3RhdGVbXCJDb25uZWN0ZWRcIl0gPSAyXSA9IFwiQ29ubmVjdGVkXCI7XG4gICAgQ2xpZW50Q29ubmVjdGlvblN0YXRlW0NsaWVudENvbm5lY3Rpb25TdGF0ZVtcIkRpc2Nvbm5lY3RlZFwiXSA9IDNdID0gXCJEaXNjb25uZWN0ZWRcIjtcbiAgICBDbGllbnRDb25uZWN0aW9uU3RhdGVbQ2xpZW50Q29ubmVjdGlvblN0YXRlW1wiQ2xvc2VkXCJdID0gNF0gPSBcIkNsb3NlZFwiO1xufSkoQ2xpZW50Q29ubmVjdGlvblN0YXRlIHx8IChDbGllbnRDb25uZWN0aW9uU3RhdGUgPSB7fSkpO1xuLyoqXG4gKiBXcmFwcGVyIGZvciBhIG5ldHdvcmsgY29ubmVjdGlvbiB0aGF0IGZ1bGZpbGxzIHRoZSBjbGllbnQtc2lkZSBldmVudCBzdHJlYW0gUlBDIHByb3RvY29sIGNvbnRyYWN0LlxuICpcbiAqIFRoZSB1c2VyICoqbXVzdCoqIGNhbGwgY2xvc2UoKSBvbiBhIGNvbm5lY3Rpb24gb25jZSBmaW5pc2hlZCB3aXRoIGl0LiAgT25jZSBjbG9zZSgpIGhhcyBiZWVuIGNhbGxlZCwgbm8gbW9yZSBldmVudHNcbiAqIHdpbGwgYmUgZW1pdHRlZCBhbmQgYWxsIHB1YmxpYyBBUEkgaW52b2NhdGlvbnMgd2lsbCB0cmlnZ2VyIGFuIGV4Y2VwdGlvbi5cbiAqL1xuY2xhc3MgQ2xpZW50Q29ubmVjdGlvbiBleHRlbmRzICgwLCBuYXRpdmVfcmVzb3VyY2VfMS5OYXRpdmVSZXNvdXJjZU1peGluKShldmVudF8xLkJ1ZmZlcmVkRXZlbnRFbWl0dGVyKSB7XG4gICAgLyoqXG4gICAgICogQ29uZmlndXJlcyBhbmQgY3JlYXRlcyBhIG5ldyBDbGllbnRDb25uZWN0aW9uIGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29uZmlnIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIGV2ZW50IHN0cmVhbSBjb25uZWN0aW9uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yXzEuQ3J0RXJyb3IoXCJJbnZhbGlkIGNvbmZpZ3VyYXRpb24gcGFzc2VkIHRvIGV2ZW50c3RyZWFtIENsaWVudENvbm5lY3Rpb24gY29uc3RydWN0b3JcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IENsaWVudENvbm5lY3Rpb25TdGF0ZS5Ob25lO1xuICAgICAgICB0aGlzLl9zdXBlcihiaW5kaW5nXzEuZGVmYXVsdC5ldmVudF9zdHJlYW1fY2xpZW50X2Nvbm5lY3Rpb25fbmV3KHRoaXMsIGNvbmZpZywgKGNvbm5lY3Rpb24sIGVycm9yQ29kZSkgPT4geyBDbGllbnRDb25uZWN0aW9uLl9zX29uX2Rpc2Nvbm5lY3QoY29ubmVjdGlvbiwgZXJyb3JDb2RlKTsgfSwgKGNvbm5lY3Rpb24sIG1lc3NhZ2UpID0+IHsgQ2xpZW50Q29ubmVjdGlvbi5fc19vbl9wcm90b2NvbF9tZXNzYWdlKGNvbm5lY3Rpb24sIG1lc3NhZ2UpOyB9LCBjb25maWcuc29ja2V0T3B0aW9ucyA/IGNvbmZpZy5zb2NrZXRPcHRpb25zLm5hdGl2ZV9oYW5kbGUoKSA6IG51bGwsIGNvbmZpZy50bHNDdHggPyBjb25maWcudGxzQ3R4Lm5hdGl2ZV9oYW5kbGUoKSA6IG51bGwpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2h1dHMgZG93biB0aGUgY29ubmVjdGlvbiAoaWYgYWN0aXZlKSBhbmQgYmVnaW5zIHRoZSBwcm9jZXNzIHRvIHJlbGVhc2UgbmF0aXZlIHJlc291cmNlcyBhc3NvY2lhdGVkIHdpdGggaXQgYnlcbiAgICAgKiBoYXZpbmcgdGhlIG5hdGl2ZSBiaW5kaW5nIHJlbGVhc2UgdGhlIG9ubHkgcmVmZXJlbmNlIHRvIHRoZSBleHRlcm4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgY29ubmVjdGlvbi4gIE9uY2VcbiAgICAgKiBjbG9zZSgpIGhhcyBiZWVuIGNhbGxlZCwgbm8gbW9yZSBldmVudHMgd2lsbCBiZSBlbWl0dGVkIGFuZCBhbGwgcHVibGljIEFQSSBpbnZvY2F0aW9ucyB3aWxsIHRyaWdnZXIgYW4gZXhjZXB0aW9uLlxuICAgICAqXG4gICAgICogVWx0aW1hdGVseSwgdGhlIG5hdGl2ZSByZXNvdXJjZXMgd2lsbCBub3QgYmUgcmVsZWFzZWQgdW50aWwgdGhlIGNvbm5lY3Rpb24gaGFzIGZ1bGx5IHNodXQgZG93biBhbmQgdGhhdFxuICAgICAqIHNodXRkb3duIGV2ZW50IGhhcyByZWFjaGVkIHRoZSBsaWJ1diBldmVudCBsb29wLlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiAqKm11c3QqKiBiZSBjYWxsZWQgZm9yIGV2ZXJ5IENsaWVudENvbm5lY3Rpb24gaW5zdGFuY2Ugb3IgbmF0aXZlIHJlc291cmNlcyB3aWxsIGxlYWsuXG4gICAgICovXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9IENsaWVudENvbm5lY3Rpb25TdGF0ZS5DbG9zZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBDbGllbnRDb25uZWN0aW9uU3RhdGUuQ2xvc2VkO1xuICAgICAgICAgICAgLy8gaW52b2tlIG5hdGl2ZSBiaW5kaW5nIGNsb3NlXG4gICAgICAgICAgICBiaW5kaW5nXzEuZGVmYXVsdC5ldmVudF9zdHJlYW1fY2xpZW50X2Nvbm5lY3Rpb25fY2xvc2UodGhpcy5uYXRpdmVfaGFuZGxlKCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGVtcHRzIHRvIG9wZW4gYSBuZXR3b3JrIGNvbm5lY3Rpb24gdG8gdGhlIGNvbmZpZ3VyZWQgcmVtb3RlIGVuZHBvaW50LiAgUmV0dXJuZWQgcHJvbWlzZSB3aWxsIGJlIGZ1bGZpbGxlZCBpZlxuICAgICAqIHRoZSB0cmFuc3BvcnQtbGV2ZWwgY29ubmVjdGlvbiBpcyBzdWNjZXNzZnVsbHkgZXN0YWJsaXNoZWQsIGFuZCByZWplY3RlZCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBjb25uZWN0KCkgbWF5IG9ubHkgYmUgY2FsbGVkIG9uY2UuXG4gICAgICovXG4gICAgY29ubmVjdChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBsZXQgY2xlYW51cENhbmNlbExpc3RlbmVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgbGV0IGNvbm5lY3RQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IGVycm9yXzEuQ3J0RXJyb3IoXCJJbnZhbGlkIG9wdGlvbnMgcGFzc2VkIHRvIGV2ZW50IHN0cmVhbSBDbGllbnRDb25uZWN0aW9uLmNvbm5lY3RcIikpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlICE9IENsaWVudENvbm5lY3Rpb25TdGF0ZS5Ob25lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgZXJyb3JfMS5DcnRFcnJvcihgRXZlbnQgc3RyZWFtIGNvbm5lY3Rpb24gaW4gYSBzdGF0ZSAoJHt0aGlzLnN0YXRlfSkgd2hlcmUgY29ubmVjdCgpIGlzIG5vdCBhbGxvd2VkLmApKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gQ2xpZW50Q29ubmVjdGlvblN0YXRlLkNvbm5lY3Rpbmc7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2FuY2VsQ29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2FuY2VsID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBlcnJvcl8xLkNydEVycm9yKGBFdmVudCBzdHJlYW0gY29ubmVjdGlvbiBjb25uZWN0KCkgY2FuY2VsbGVkIGJ5IGV4dGVybmFsIHJlcXVlc3QuYCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHsgdGhpcy5jbG9zZSgpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY2xlYW51cENhbmNlbExpc3RlbmVyID0gb3B0aW9ucy5jYW5jZWxDb250cm9sbGVyLmFkZExpc3RlbmVyKGNhbmNlbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2xlYW51cENhbmNlbExpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gY3VycmllZFByb21pc2VDYWxsYmFjayhjb25uZWN0aW9uLCBlcnJvckNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIENsaWVudENvbm5lY3Rpb24uX3Nfb25fY29ubmVjdGlvbl9zZXR1cChyZXNvbHZlLCByZWplY3QsIGNvbm5lY3Rpb24sIGVycm9yQ29kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGJpbmRpbmdfMS5kZWZhdWx0LmV2ZW50X3N0cmVhbV9jbGllbnRfY29ubmVjdGlvbl9jb25uZWN0KHRoaXMubmF0aXZlX2hhbmRsZSgpLCBjdXJyaWVkUHJvbWlzZUNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IENsaWVudENvbm5lY3Rpb25TdGF0ZS5EaXNjb25uZWN0ZWQ7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlLm1ha2VTZWxmQ2xlYW5pbmdQcm9taXNlKGNvbm5lY3RQcm9taXNlLCBjbGVhbnVwQ2FuY2VsTGlzdGVuZXIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0ZW1wdHMgdG8gc2VuZCBhbiBldmVudCBzdHJlYW0gcHJvdG9jb2wgbWVzc2FnZSBvdmVyIGFuIG9wZW4gY29ubmVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIGNvbmZpZ3VyYXRpb24gLS0gaW5jbHVkaW5nIHRoZSBtZXNzYWdlIGl0c2VsZiAtLSBmb3Igc2VuZGluZyBhIHByb3RvY29sIG1lc3NhZ2VcbiAgICAgKlxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgd2lsbCBiZSBmdWxmaWxsZWQgd2hlbiB0aGUgbWVzc2FnZSBpcyBzdWNjZXNzZnVsbHkgZmx1c2hlZCB0byB0aGUgd2lyZSwgYW5kIHJlamVjdGVkIGlmXG4gICAgICogYW4gZXJyb3Igb2NjdXJzIHByaW9yIHRvIHRoYXQgcG9pbnQuXG4gICAgICovXG4gICAgc2VuZFByb3RvY29sTWVzc2FnZShvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBsZXQgY2xlYW51cENhbmNlbExpc3RlbmVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgbGV0IHNlbmRQcm90b2NvbE1lc3NhZ2VQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBlcnJvcl8xLkNydEVycm9yKFwiSW52YWxpZCBvcHRpb25zIHBhc3NlZCB0byBldmVudCBzdHJlYW0gQ2xpZW50Q29ubmVjdGlvbi5zZW5kUHJvdG9jb2xNZXNzYWdlXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBlcnJvcl8xLkNydEVycm9yKGBFdmVudCBzdHJlYW0gY29ubmVjdGlvbiBpbiBhIHN0YXRlICgke3RoaXMuc3RhdGV9KSB3aGVyZSBzZW5kaW5nIHByb3RvY29sIG1lc3NhZ2VzIGlzIG5vdCBhbGxvd2VkLmApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5jYW5jZWxDb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY2FuY2VsID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgZXJyb3JfMS5DcnRFcnJvcihgRXZlbnQgc3RyZWFtIGNvbm5lY3Rpb24gc2VuZFByb3RvY29sTWVzc2FnZSgpIGNhbmNlbGxlZCBieSBleHRlcm5hbCByZXF1ZXN0LmApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4geyB0aGlzLmNsb3NlKCk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFudXBDYW5jZWxMaXN0ZW5lciA9IG9wdGlvbnMuY2FuY2VsQ29udHJvbGxlci5hZGRMaXN0ZW5lcihjYW5jZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjbGVhbnVwQ2FuY2VsTGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gaW52b2tlIG5hdGl2ZSBiaW5kaW5nIHNlbmQgbWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gY3VycmllZFByb21pc2VDYWxsYmFjayhlcnJvckNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBDbGllbnRDb25uZWN0aW9uLl9zX29uX2Nvbm5lY3Rpb25fc2VuZF9wcm90b2NvbF9tZXNzYWdlX2NvbXBsZXRpb24ocmVzb2x2ZSwgcmVqZWN0LCBlcnJvckNvZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGludm9rZSBuYXRpdmUgYmluZGluZyBzZW5kIG1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgIGJpbmRpbmdfMS5kZWZhdWx0LmV2ZW50X3N0cmVhbV9jbGllbnRfY29ubmVjdGlvbl9zZW5kX3Byb3RvY29sX21lc3NhZ2UodGhpcy5uYXRpdmVfaGFuZGxlKCksIG9wdGlvbnMsIGN1cnJpZWRQcm9taXNlQ2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZS5tYWtlU2VsZkNsZWFuaW5nUHJvbWlzZShzZW5kUHJvdG9jb2xNZXNzYWdlUHJvbWlzZSwgY2xlYW51cENhbmNlbExpc3RlbmVyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY29ubmVjdGlvbiBpcyBjdXJyZW50bHkgb3BlbiBhbmQgcmVhZHktdG8tdXNlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBJbnRlcm5hbCBub3RlOiBPdXIgbm90aW9uIG9mIFwiY29ubmVjdGVkXCIgaXMgaW50ZW50aW9uYWxseSBub3QgYW4gaW52b2NhdGlvbiBvZlxuICAgICAqIGF3c19ldmVudF9zdHJlYW1fcnBjX2NsaWVudF9jb25uZWN0aW9uX2lzX29wZW4oKSAod2hvc2Ugc3RhdHVzIGlzIGFuIG91dC1vZi1zeW5jIHJhY2UgY29uZGl0aW9uIHZzLiBvdXJcbiAgICAgKiB3ZWxsLWRlZmluZWQgY2xpZW50IHN0YXRlKVxuICAgICAqL1xuICAgIGlzQ29ubmVjdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZSA9PSBDbGllbnRDb25uZWN0aW9uU3RhdGUuQ29ubmVjdGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHN0cmVhbSB3aXRoaW4gdGhlIGNvbm5lY3Rpb24uXG4gICAgICovXG4gICAgbmV3U3RyZWFtKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yXzEuQ3J0RXJyb3IoYEV2ZW50IHN0cmVhbSBjb25uZWN0aW9uIGluIGEgc3RhdGUgKCR7dGhpcy5zdGF0ZX0pIHdoZXJlIGNyZWF0aW5nIG5ldyBzdHJlYW1zIGlzIGZvcmJpZGRlbi5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENsaWVudFN0cmVhbSh0aGlzKTtcbiAgICB9XG4gICAgb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHN1cGVyLm9uKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzdGF0aWMgX3Nfb25fY29ubmVjdGlvbl9zZXR1cChyZXNvbHZlLCByZWplY3QsIGNvbm5lY3Rpb24sIGVycm9yQ29kZSkge1xuICAgICAgICBpZiAoZXJyb3JDb2RlID09IDAgJiYgY29ubmVjdGlvbi5zdGF0ZSA9PSBDbGllbnRDb25uZWN0aW9uU3RhdGUuQ29ubmVjdGluZykge1xuICAgICAgICAgICAgY29ubmVjdGlvbi5zdGF0ZSA9IENsaWVudENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0ZWQ7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoY29ubmVjdGlvbi5zdGF0ZSAhPSBDbGllbnRDb25uZWN0aW9uU3RhdGUuQ2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbi5zdGF0ZSA9IENsaWVudENvbm5lY3Rpb25TdGF0ZS5EaXNjb25uZWN0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWplY3QoaW8uZXJyb3JfY29kZV90b19zdHJpbmcoZXJyb3JDb2RlKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIF9zX29uX2Rpc2Nvbm5lY3QoY29ubmVjdGlvbiwgZXJyb3JDb2RlKSB7XG4gICAgICAgIGlmIChjb25uZWN0aW9uLnN0YXRlICE9IENsaWVudENvbm5lY3Rpb25TdGF0ZS5DbG9zZWQpIHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24uc3RhdGUgPSBDbGllbnRDb25uZWN0aW9uU3RhdGUuRGlzY29ubmVjdGVkO1xuICAgICAgICB9XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgY29ubmVjdGlvbi5lbWl0KCdkaXNjb25uZWN0aW9uJywgeyBlcnJvckNvZGU6IGVycm9yQ29kZSB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBfc19vbl9wcm90b2NvbF9tZXNzYWdlKGNvbm5lY3Rpb24sIG1lc3NhZ2UpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICBjb25uZWN0aW9uLmVtaXQoJ3Byb3RvY29sTWVzc2FnZScsIHsgbWVzc2FnZTogbWFwUG9kTWVzc2FnZVRvSlNNZXNzYWdlKG1lc3NhZ2UpIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIF9zX29uX2Nvbm5lY3Rpb25fc2VuZF9wcm90b2NvbF9tZXNzYWdlX2NvbXBsZXRpb24ocmVzb2x2ZSwgcmVqZWN0LCBlcnJvckNvZGUpIHtcbiAgICAgICAgaWYgKGVycm9yQ29kZSA9PSAwKSB7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZWplY3QoaW8uZXJyb3JfY29kZV90b19zdHJpbmcoZXJyb3JDb2RlKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkNsaWVudENvbm5lY3Rpb24gPSBDbGllbnRDb25uZWN0aW9uO1xuLyoqXG4gKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIGNvbm5lY3Rpb24gaXMgY2xvc2VkIGZvciBhbnkgcmVhc29uLlxuICpcbiAqIExpc3RlbmVyIHR5cGU6IHtAbGluayBEaXNjb25uZWN0aW9uTGlzdGVuZXJ9XG4gKlxuICogQGV2ZW50XG4gKi9cbkNsaWVudENvbm5lY3Rpb24uRElTQ09OTkVDVElPTiA9ICdkaXNjb25uZWN0aW9uJztcbi8qKlxuICogRXZlbnQgZW1pdHRlZCB3aGVuIGEgcHJvdG9jb2wgbWVzc2FnZSBpcyByZWNlaXZlZCBmcm9tIHRoZSByZW1vdGUgZW5kcG9pbnRcbiAqXG4gKiBMaXN0ZW5lciB0eXBlOiB7QGxpbmsgTWVzc2FnZUxpc3RlbmVyfVxuICpcbiAqIEBldmVudFxuICovXG5DbGllbnRDb25uZWN0aW9uLlBST1RPQ09MX01FU1NBR0UgPSAncHJvdG9jb2xNZXNzYWdlJztcbi8qKlxuICogQGludGVybmFsXG4gKlxuICogV2hpbGUgbm90IHN0cmljdGx5IG5lY2Vzc2FyeSwgdGhlIHNpbmdsZS10aHJlYWRlZCBuYXR1cmUgb2YgSlMgZXhlY3V0aW9uIGFsbG93cyB1cyB0byBlYXNpbHkgYXBwbHkgc29tZVxuICogcmlnaWQgY29uc3RyYWludHMgdG8gdGhlIHB1YmxpYyBBUEkgY2FsbHMgb2Ygb3VyIGV2ZW50IHN0cmVhbSBvYmplY3RzLiAgVGhpcyBpbiB0dXJuIHJlZHVjZXMgdGhlIGNvbXBsZXhpdHkgb2YgdGhlXG4gKiBiaW5kaW5nIGNhc2VzIHdlIG5lZWQgdG8gY29uc2lkZXIuXG4gKlxuICogVGhpcyBzdGF0ZSB2YWx1ZSBpcyB0aGUgcHJpbWFyeSBtZWFucyBieSB3aGljaCB3ZSBhZGQgYW5kIGVuZm9yY2UgdGhlc2UgY29uc3RyYWludHMgdG8gc3RyZWFtIG9iamVjdHMuXG4gKlxuICogQ29uc3RyYWludHMgZW5mb3JjZWQgaW4gdGhlIG1hbmFnZWQgYmluZGluZzpcbiAqXG4gKiAgKDEpIGNsb3NlKCkgbWF5IG9ubHkgYmUgY2FsbGVkIG9uY2UuICBPbmNlIGl0IGhhcyBiZWVuIGNhbGxlZCwgbm90aGluZyBlbHNlIG1heSBiZSBjYWxsZWQuXG4gKiAgKDIpIHNlbmRNZXNzYWdlKCkgbWF5IG9ubHkgYmUgY2FsbGVkIGFmdGVyIHN1Y2Nlc3NmdWwgc3RyZWFtIGFjdGl2YXRpb24gYW5kIGJlZm9yZSB0aGVcbiAqICAgICAgc3RyZWFtIGhhcyBiZWVuIGNsb3NlZC5cbiAqICAoMykgYWN0aXZhdGUoKSBtYXkgb25seSBiZSBjYWxsZWQgb25jZS4gIENvbWJpbmVkIHdpdGggKDEpIGFuZCAoMiksIHRoaXMgbWVhbnMgdGhhdCBpZiBhY3RpdmF0ZSgpIGlzIGNhbGxlZCwgaXQgbXVzdFxuICogICAgICBiZSB0aGUgZmlyc3QgdGhpbmcgY2FsbGVkLlxuICovXG52YXIgQ2xpZW50U3RyZWFtU3RhdGU7XG4oZnVuY3Rpb24gKENsaWVudFN0cmVhbVN0YXRlKSB7XG4gICAgQ2xpZW50U3RyZWFtU3RhdGVbQ2xpZW50U3RyZWFtU3RhdGVbXCJOb25lXCJdID0gMF0gPSBcIk5vbmVcIjtcbiAgICBDbGllbnRTdHJlYW1TdGF0ZVtDbGllbnRTdHJlYW1TdGF0ZVtcIkFjdGl2YXRpbmdcIl0gPSAxXSA9IFwiQWN0aXZhdGluZ1wiO1xuICAgIENsaWVudFN0cmVhbVN0YXRlW0NsaWVudFN0cmVhbVN0YXRlW1wiQWN0aXZhdGVkXCJdID0gMl0gPSBcIkFjdGl2YXRlZFwiO1xuICAgIENsaWVudFN0cmVhbVN0YXRlW0NsaWVudFN0cmVhbVN0YXRlW1wiRW5kZWRcIl0gPSAzXSA9IFwiRW5kZWRcIjtcbiAgICBDbGllbnRTdHJlYW1TdGF0ZVtDbGllbnRTdHJlYW1TdGF0ZVtcIkNsb3NlZFwiXSA9IDRdID0gXCJDbG9zZWRcIjtcbn0pKENsaWVudFN0cmVhbVN0YXRlIHx8IChDbGllbnRTdHJlYW1TdGF0ZSA9IHt9KSk7XG4vKipcbiAqIFdyYXBwZXIgZm9yIGFuIGluZGl2aWR1YWwgc3RyZWFtIHdpdGhpbiBhbiBldmVudHN0cmVhbSBjb25uZWN0aW9uLlxuICpcbiAqIFRoZSB1c2VyICoqbXVzdCoqIGNhbGwgY2xvc2UoKSBvbiBhIHN0cmVhbSBvbmNlIGZpbmlzaGVkIHdpdGggaXQuICBPbmNlIGNsb3NlKCkgaGFzIGJlZW4gY2FsbGVkLCBubyBtb3JlIGV2ZW50c1xuICogd2lsbCBiZSBlbWl0dGVkIGFuZCBhbGwgcHVibGljIEFQSSBpbnZvY2F0aW9ucyB3aWxsIHRyaWdnZXIgYW4gZXhjZXB0aW9uLlxuICovXG5jbGFzcyBDbGllbnRTdHJlYW0gZXh0ZW5kcyAoMCwgbmF0aXZlX3Jlc291cmNlXzEuTmF0aXZlUmVzb3VyY2VNaXhpbikoZXZlbnRfMS5CdWZmZXJlZEV2ZW50RW1pdHRlcikge1xuICAgIGNvbnN0cnVjdG9yKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fc3VwZXIoYmluZGluZ18xLmRlZmF1bHQuZXZlbnRfc3RyZWFtX2NsaWVudF9zdHJlYW1fbmV3KHRoaXMsIGNvbm5lY3Rpb24ubmF0aXZlX2hhbmRsZSgpLCAoc3RyZWFtKSA9PiB7IENsaWVudFN0cmVhbS5fc19vbl9zdHJlYW1fZW5kZWQoc3RyZWFtKTsgfSwgKHN0cmVhbSwgbWVzc2FnZSkgPT4geyBDbGllbnRTdHJlYW0uX3Nfb25fc3RyZWFtX21lc3NhZ2Uoc3RyZWFtLCBtZXNzYWdlKTsgfSkpO1xuICAgICAgICB0aGlzLnN0YXRlID0gQ2xpZW50U3RyZWFtU3RhdGUuTm9uZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2h1dHMgZG93biB0aGUgc3RyZWFtIChpZiBhY3RpdmUpIGFuZCBiZWdpbnMgdGhlIHByb2Nlc3MgdG8gcmVsZWFzZSBuYXRpdmUgcmVzb3VyY2VzIGFzc29jaWF0ZWQgd2l0aCBpdCBieVxuICAgICAqIGhhdmluZyB0aGUgbmF0aXZlIGJpbmRpbmcgcmVsZWFzZSB0aGUgb25seSByZWZlcmVuY2UgdG8gdGhlIGV4dGVybiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBzdHJlYW0uICBPbmNlXG4gICAgICogY2xvc2UoKSBoYXMgYmVlbiBjYWxsZWQsIG5vIG1vcmUgZXZlbnRzIHdpbGwgYmUgZW1pdHRlZCBhbmQgYWxsIHB1YmxpYyBBUEkgaW52b2NhdGlvbnMgd2lsbCB0cmlnZ2VyIGFuIGV4Y2VwdGlvbi5cbiAgICAgKlxuICAgICAqIFVsdGltYXRlbHksIHRoZSBuYXRpdmUgcmVzb3VyY2VzIHdpbGwgbm90IGJlIHJlbGVhc2VkIHVudGlsIHRoZSBuYXRpdmUgc3RyZWFtIGhhcyBmdWxseSBzaHV0IGRvd24gYW5kIHRoYXRcbiAgICAgKiBzaHV0ZG93biBldmVudCBoYXMgcmVhY2hlZCB0aGUgbGlidXYgZXZlbnQgbG9vcC5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gKiptdXN0KiogYmUgY2FsbGVkIGZvciBldmVyeSBDbGllbnRTdHJlYW0gaW5zdGFuY2Ugb3IgbmF0aXZlIHJlc291cmNlcyB3aWxsIGxlYWsuXG4gICAgICovXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9IENsaWVudFN0cmVhbVN0YXRlLkNsb3NlZCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IENsaWVudFN0cmVhbVN0YXRlLkNsb3NlZDtcbiAgICAgICAgICAgIGJpbmRpbmdfMS5kZWZhdWx0LmV2ZW50X3N0cmVhbV9jbGllbnRfc3RyZWFtX2Nsb3NlKHRoaXMubmF0aXZlX2hhbmRsZSgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBY3RpdmF0ZXMgdGhlIHN0cmVhbSwgYWxsb3dpbmcgaXQgdG8gc3RhcnQgc2VuZGluZyBhbmQgcmVjZWl2aW5nIG1lc3NhZ2VzLiAgVGhlIHByb21pc2UgY29tcGxldGVzIHdoZW5cbiAgICAgKiB0aGUgYWN0aXZhdGlvbiBtZXNzYWdlIGhhcyBiZWVuIHdyaXR0ZW4gdG8gdGhlIHdpcmUuXG4gICAgICpcbiAgICAgKiBhY3RpdmF0ZSgpIG1heSBvbmx5IGJlIGNhbGxlZCBvbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLS0gY29uZmlndXJhdGlvbiBkYXRhIGZvciBzdHJlYW0gYWN0aXZhdGlvbiwgaW5jbHVkaW5nIG9wZXJhdGlvbiBuYW1lIGFuZCBpbml0aWFsIG1lc3NhZ2VcbiAgICAgKi9cbiAgICBhY3RpdmF0ZShvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBsZXQgY2xlYW51cENhbmNlbExpc3RlbmVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgbGV0IGFjdGl2YXRlUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPSBDbGllbnRTdHJlYW1TdGF0ZS5Ob25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IGVycm9yXzEuQ3J0RXJyb3IoYEV2ZW50IHN0cmVhbSBpbiBhIHN0YXRlICgke3RoaXMuc3RhdGV9KSB3aGVyZSBhY3RpdmF0aW9uIGlzIG5vdCBhbGxvd2VkLmApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgKiBJbnRlbnRpb25hbGx5IGNoZWNrIHRoaXMgYWZ0ZXIgdGhlIHN0YXRlIGNoZWNrIChzbyBjbG9zZWQgc3RyZWFtcyBkbyBub3QgcmVhY2ggaGVyZSkuXG4gICAgICAgICAgICAgICAgICAgICAqIEludGVudGlvbmFsbHkgbXV0YXRlIHN0YXRlIHRoZSBzYW1lIHdheSBhIGZhaWxlZCBzeW5jaHJvbm91cyBjYWxsIHRvIG5hdGl2ZSBhY3RpdmF0ZSBkb2VzLlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IENsaWVudFN0cmVhbVN0YXRlLkVuZGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBlcnJvcl8xLkNydEVycm9yKFwiSW52YWxpZCBvcHRpb25zIHBhc3NlZCB0byBDbGllbnRTdHJlYW0uYWN0aXZhdGVcIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBDbGllbnRTdHJlYW1TdGF0ZS5BY3RpdmF0aW5nO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5jYW5jZWxDb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY2FuY2VsID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgZXJyb3JfMS5DcnRFcnJvcihgRXZlbnQgc3RyZWFtIGFjdGl2YXRlKCkgY2FuY2VsbGVkIGJ5IGV4dGVybmFsIHJlcXVlc3QuYCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7IHRoaXMuY2xvc2UoKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYW51cENhbmNlbExpc3RlbmVyID0gb3B0aW9ucy5jYW5jZWxDb250cm9sbGVyLmFkZExpc3RlbmVyKGNhbmNlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNsZWFudXBDYW5jZWxMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBjdXJyaWVkUHJvbWlzZUNhbGxiYWNrKHN0cmVhbSwgZXJyb3JDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQ2xpZW50U3RyZWFtLl9zX29uX3N0cmVhbV9hY3RpdmF0ZWQocmVzb2x2ZSwgcmVqZWN0LCBzdHJlYW0sIGVycm9yQ29kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYmluZGluZ18xLmRlZmF1bHQuZXZlbnRfc3RyZWFtX2NsaWVudF9zdHJlYW1fYWN0aXZhdGUodGhpcy5uYXRpdmVfaGFuZGxlKCksIG9wdGlvbnMsIGN1cnJpZWRQcm9taXNlQ2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gQ2xpZW50U3RyZWFtU3RhdGUuRW5kZWQ7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlLm1ha2VTZWxmQ2xlYW5pbmdQcm9taXNlKGFjdGl2YXRlUHJvbWlzZSwgY2xlYW51cENhbmNlbExpc3RlbmVyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGVtcHRzIHRvIHNlbmQgYW4gZXZlbnQgc3RyZWFtIG1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBjb25maWd1cmF0aW9uIC0tIGluY2x1ZGluZyB0aGUgbWVzc2FnZSBpdHNlbGYgLS0gZm9yIHNlbmRpbmcgYSBtZXNzYWdlXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgZnVsZmlsbGVkIHdoZW4gdGhlIG1lc3NhZ2UgaXMgc3VjY2Vzc2Z1bGx5IGZsdXNoZWQgdG8gdGhlIHdpcmUsIGFuZCByZWplY3RlZCBpZlxuICAgICAqIGFuIGVycm9yIG9jY3VycyBwcmlvciB0byB0aGF0IHBvaW50LlxuICAgICAqL1xuICAgIHNlbmRNZXNzYWdlKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGxldCBjbGVhbnVwQ2FuY2VsTGlzdGVuZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBsZXQgc2VuZE1lc3NhZ2VQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBlcnJvcl8xLkNydEVycm9yKFwiSW52YWxpZCBvcHRpb25zIHBhc3NlZCB0byBDbGllbnRTdHJlYW0uc2VuZE1lc3NhZ2VcIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlICE9IENsaWVudFN0cmVhbVN0YXRlLkFjdGl2YXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBlcnJvcl8xLkNydEVycm9yKGBFdmVudCBzdHJlYW0gaW4gYSBzdGF0ZSAoJHt0aGlzLnN0YXRlfSkgd2hlcmUgc2VuZGluZyBtZXNzYWdlcyBpcyBub3QgYWxsb3dlZC5gKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2FuY2VsQ29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNhbmNlbCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IGVycm9yXzEuQ3J0RXJyb3IoYEV2ZW50IHN0cmVhbSBzZW5kTWVzc2FnZSgpIGNhbmNlbGxlZCBieSBleHRlcm5hbCByZXF1ZXN0LmApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4geyB0aGlzLmNsb3NlKCk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFudXBDYW5jZWxMaXN0ZW5lciA9IG9wdGlvbnMuY2FuY2VsQ29udHJvbGxlci5hZGRMaXN0ZW5lcihjYW5jZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjbGVhbnVwQ2FuY2VsTGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gY3VycmllZFByb21pc2VDYWxsYmFjayhlcnJvckNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBDbGllbnRTdHJlYW0uX3Nfb25fc3RyZWFtX3NlbmRfbWVzc2FnZV9jb21wbGV0aW9uKHJlc29sdmUsIHJlamVjdCwgZXJyb3JDb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBpbnZva2UgbmF0aXZlIGJpbmRpbmcgc2VuZCBtZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICBiaW5kaW5nXzEuZGVmYXVsdC5ldmVudF9zdHJlYW1fY2xpZW50X3N0cmVhbV9zZW5kX21lc3NhZ2UodGhpcy5uYXRpdmVfaGFuZGxlKCksIG9wdGlvbnMsIGN1cnJpZWRQcm9taXNlQ2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZS5tYWtlU2VsZkNsZWFuaW5nUHJvbWlzZShzZW5kTWVzc2FnZVByb21pc2UsIGNsZWFudXBDYW5jZWxMaXN0ZW5lcik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHN0cmVhbSBpcyBjdXJyZW50bHkgYWN0aXZlIGFuZCByZWFkeS10by11c2UsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBpc0FjdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUgPT0gQ2xpZW50U3RyZWFtU3RhdGUuQWN0aXZhdGVkO1xuICAgIH1cbiAgICBvbihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgc3VwZXIub24oZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHN0YXRpYyBfc19vbl9zdHJlYW1fYWN0aXZhdGVkKHJlc29sdmUsIHJlamVjdCwgc3RyZWFtLCBlcnJvckNvZGUpIHtcbiAgICAgICAgaWYgKGVycm9yQ29kZSA9PSAwICYmIHN0cmVhbS5zdGF0ZSA9PSBDbGllbnRTdHJlYW1TdGF0ZS5BY3RpdmF0aW5nKSB7XG4gICAgICAgICAgICBzdHJlYW0uc3RhdGUgPSBDbGllbnRTdHJlYW1TdGF0ZS5BY3RpdmF0ZWQ7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoc3RyZWFtLnN0YXRlICE9IENsaWVudFN0cmVhbVN0YXRlLkNsb3NlZCkge1xuICAgICAgICAgICAgICAgIHN0cmVhbS5zdGF0ZSA9IENsaWVudFN0cmVhbVN0YXRlLkVuZGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVqZWN0KGlvLmVycm9yX2NvZGVfdG9fc3RyaW5nKGVycm9yQ29kZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBfc19vbl9zdHJlYW1fc2VuZF9tZXNzYWdlX2NvbXBsZXRpb24ocmVzb2x2ZSwgcmVqZWN0LCBlcnJvckNvZGUpIHtcbiAgICAgICAgaWYgKGVycm9yQ29kZSA9PSAwKSB7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZWplY3QoaW8uZXJyb3JfY29kZV90b19zdHJpbmcoZXJyb3JDb2RlKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIF9zX29uX3N0cmVhbV9lbmRlZChzdHJlYW0pIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICBzdHJlYW0uZW1pdChDbGllbnRTdHJlYW0uRU5ERUQsIHt9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBfc19vbl9zdHJlYW1fbWVzc2FnZShzdHJlYW0sIG1lc3NhZ2UpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICBzdHJlYW0uZW1pdChDbGllbnRTdHJlYW0uTUVTU0FHRSwgeyBtZXNzYWdlOiBtYXBQb2RNZXNzYWdlVG9KU01lc3NhZ2UobWVzc2FnZSkgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2xpZW50U3RyZWFtID0gQ2xpZW50U3RyZWFtO1xuLyoqXG4gKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIHN0cmVhbSBpcyBzaHV0IGRvd24gZm9yIGFueSByZWFzb24uXG4gKlxuICogTGlzdGVuZXIgdHlwZToge0BsaW5rIFN0cmVhbUVuZGVkTGlzdGVuZXJ9XG4gKlxuICogQGV2ZW50XG4gKi9cbkNsaWVudFN0cmVhbS5FTkRFRCA9ICdlbmRlZCc7XG4vKipcbiAqIEV2ZW50IGVtaXR0ZWQgd2hlbiBhIHN0cmVhbSBtZXNzYWdlIGlzIHJlY2VpdmVkIGZyb20gdGhlIHJlbW90ZSBlbmRwb2ludFxuICpcbiAqIExpc3RlbmVyIHR5cGU6IHtAbGluayBNZXNzYWdlTGlzdGVuZXJ9XG4gKlxuICogQGV2ZW50XG4gKi9cbkNsaWVudFN0cmVhbS5NRVNTQUdFID0gJ21lc3NhZ2UnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXZlbnRzdHJlYW0uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/aws-crt/dist/native/eventstream.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/aws-crt/dist/native/eventstream_utils.js":
/*!***************************************************************!*\
  !*** ./node_modules/aws-crt/dist/native/eventstream_utils.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n * SPDX-License-Identifier: Apache-2.0.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.unmarshalInt64BigintFromBuffer = exports.marshalInt64BigintAsBuffer = exports.MIN_INT64 = exports.MAX_INT64 = exports.MIN_INT32 = exports.MAX_INT32 = exports.MIN_INT16 = exports.MAX_INT16 = exports.MIN_INT8 = exports.MAX_INT8 = void 0;\nconst error_1 = __webpack_require__(/*! ./error */ \"(ssr)/./node_modules/aws-crt/dist/native/error.js\");\n/*\n* Limits for header value validation\n*/\nexports.MAX_INT8 = 127;\nexports.MIN_INT8 = -128;\nexports.MAX_INT16 = 32767;\nexports.MIN_INT16 = -32768;\nexports.MAX_INT32 = 2147483647;\nexports.MIN_INT32 = -2147483648;\nexports.MAX_INT64 = BigInt(\"9223372036854775807\");\nexports.MIN_INT64 = BigInt(\"-9223372036854775808\");\nconst MAX_UINT8_AS_BIGINT = BigInt(\"256\");\n/** @internal */\nfunction marshalInt64BigintAsBuffer(value) {\n    if (value < exports.MIN_INT64 || value > exports.MAX_INT64) {\n        throw new error_1.CrtError(\"marshalInt64BigintAsBuffer expects a value that can fit in 8 bytes\");\n    }\n    let buffer = new Uint8Array(8);\n    /* encode the integer as a twos-complement byte sequence */\n    if (value < 0) {\n        value = -value - BigInt(1);\n        for (let i = 0; i < 8; ++i) {\n            buffer[i] = 255 - Number(value % MAX_UINT8_AS_BIGINT);\n            value /= MAX_UINT8_AS_BIGINT;\n        }\n    }\n    else {\n        for (let i = 0; i < 8; ++i) {\n            buffer[i] = Number(value % MAX_UINT8_AS_BIGINT);\n            value /= MAX_UINT8_AS_BIGINT;\n        }\n    }\n    return buffer;\n}\nexports.marshalInt64BigintAsBuffer = marshalInt64BigintAsBuffer;\n/** @internal */\nfunction unmarshalInt64BigintFromBuffer(buffer) {\n    let value = BigInt(0);\n    let byteView = new Uint8Array(buffer);\n    if (byteView.length != 8) {\n        throw new error_1.CrtError(\"unmarshalInt64BigintFromBuffer expects a byte buffer of length 8\");\n    }\n    let shift = BigInt(1);\n    let isNegative = (byteView[7] & 0x80) != 0;\n    /* encoding is two's-complement, so treat negative and non-negative differently */\n    if (isNegative) {\n        for (let i = 0; i < byteView.length; ++i) {\n            let byteValue = BigInt(255 - byteView[i]);\n            value += (byteValue * shift);\n            shift *= MAX_UINT8_AS_BIGINT;\n        }\n        value += BigInt(1);\n        value = -value;\n    }\n    else {\n        for (let i = 0; i < byteView.length; ++i) {\n            let byteValue = BigInt(byteView[i]);\n            value += (byteValue * shift);\n            shift *= MAX_UINT8_AS_BIGINT;\n        }\n    }\n    return value;\n}\nexports.unmarshalInt64BigintFromBuffer = unmarshalInt64BigintFromBuffer;\n//# sourceMappingURL=eventstream_utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXdzLWNydC9kaXN0L25hdGl2ZS9ldmVudHN0cmVhbV91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNDQUFzQyxHQUFHLGtDQUFrQyxHQUFHLGlCQUFpQixHQUFHLGlCQUFpQixHQUFHLGlCQUFpQixHQUFHLGlCQUFpQixHQUFHLGlCQUFpQixHQUFHLGlCQUFpQixHQUFHLGdCQUFnQixHQUFHLGdCQUFnQjtBQUN6TyxnQkFBZ0IsbUJBQU8sQ0FBQyxrRUFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QyIsInNvdXJjZXMiOlsid2VicGFjazovL3BheXdpbmQvLi9ub2RlX21vZHVsZXMvYXdzLWNydC9kaXN0L25hdGl2ZS9ldmVudHN0cmVhbV91dGlscy5qcz8zMDU0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjAuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudW5tYXJzaGFsSW50NjRCaWdpbnRGcm9tQnVmZmVyID0gZXhwb3J0cy5tYXJzaGFsSW50NjRCaWdpbnRBc0J1ZmZlciA9IGV4cG9ydHMuTUlOX0lOVDY0ID0gZXhwb3J0cy5NQVhfSU5UNjQgPSBleHBvcnRzLk1JTl9JTlQzMiA9IGV4cG9ydHMuTUFYX0lOVDMyID0gZXhwb3J0cy5NSU5fSU5UMTYgPSBleHBvcnRzLk1BWF9JTlQxNiA9IGV4cG9ydHMuTUlOX0lOVDggPSBleHBvcnRzLk1BWF9JTlQ4ID0gdm9pZCAwO1xuY29uc3QgZXJyb3JfMSA9IHJlcXVpcmUoXCIuL2Vycm9yXCIpO1xuLypcbiogTGltaXRzIGZvciBoZWFkZXIgdmFsdWUgdmFsaWRhdGlvblxuKi9cbmV4cG9ydHMuTUFYX0lOVDggPSAxMjc7XG5leHBvcnRzLk1JTl9JTlQ4ID0gLTEyODtcbmV4cG9ydHMuTUFYX0lOVDE2ID0gMzI3Njc7XG5leHBvcnRzLk1JTl9JTlQxNiA9IC0zMjc2ODtcbmV4cG9ydHMuTUFYX0lOVDMyID0gMjE0NzQ4MzY0NztcbmV4cG9ydHMuTUlOX0lOVDMyID0gLTIxNDc0ODM2NDg7XG5leHBvcnRzLk1BWF9JTlQ2NCA9IEJpZ0ludChcIjkyMjMzNzIwMzY4NTQ3NzU4MDdcIik7XG5leHBvcnRzLk1JTl9JTlQ2NCA9IEJpZ0ludChcIi05MjIzMzcyMDM2ODU0Nzc1ODA4XCIpO1xuY29uc3QgTUFYX1VJTlQ4X0FTX0JJR0lOVCA9IEJpZ0ludChcIjI1NlwiKTtcbi8qKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIG1hcnNoYWxJbnQ2NEJpZ2ludEFzQnVmZmVyKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIDwgZXhwb3J0cy5NSU5fSU5UNjQgfHwgdmFsdWUgPiBleHBvcnRzLk1BWF9JTlQ2NCkge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JfMS5DcnRFcnJvcihcIm1hcnNoYWxJbnQ2NEJpZ2ludEFzQnVmZmVyIGV4cGVjdHMgYSB2YWx1ZSB0aGF0IGNhbiBmaXQgaW4gOCBieXRlc1wiKTtcbiAgICB9XG4gICAgbGV0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDgpO1xuICAgIC8qIGVuY29kZSB0aGUgaW50ZWdlciBhcyBhIHR3b3MtY29tcGxlbWVudCBieXRlIHNlcXVlbmNlICovXG4gICAgaWYgKHZhbHVlIDwgMCkge1xuICAgICAgICB2YWx1ZSA9IC12YWx1ZSAtIEJpZ0ludCgxKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4OyArK2kpIHtcbiAgICAgICAgICAgIGJ1ZmZlcltpXSA9IDI1NSAtIE51bWJlcih2YWx1ZSAlIE1BWF9VSU5UOF9BU19CSUdJTlQpO1xuICAgICAgICAgICAgdmFsdWUgLz0gTUFYX1VJTlQ4X0FTX0JJR0lOVDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4OyArK2kpIHtcbiAgICAgICAgICAgIGJ1ZmZlcltpXSA9IE51bWJlcih2YWx1ZSAlIE1BWF9VSU5UOF9BU19CSUdJTlQpO1xuICAgICAgICAgICAgdmFsdWUgLz0gTUFYX1VJTlQ4X0FTX0JJR0lOVDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyO1xufVxuZXhwb3J0cy5tYXJzaGFsSW50NjRCaWdpbnRBc0J1ZmZlciA9IG1hcnNoYWxJbnQ2NEJpZ2ludEFzQnVmZmVyO1xuLyoqIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gdW5tYXJzaGFsSW50NjRCaWdpbnRGcm9tQnVmZmVyKGJ1ZmZlcikge1xuICAgIGxldCB2YWx1ZSA9IEJpZ0ludCgwKTtcbiAgICBsZXQgYnl0ZVZpZXcgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgIGlmIChieXRlVmlldy5sZW5ndGggIT0gOCkge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JfMS5DcnRFcnJvcihcInVubWFyc2hhbEludDY0QmlnaW50RnJvbUJ1ZmZlciBleHBlY3RzIGEgYnl0ZSBidWZmZXIgb2YgbGVuZ3RoIDhcIik7XG4gICAgfVxuICAgIGxldCBzaGlmdCA9IEJpZ0ludCgxKTtcbiAgICBsZXQgaXNOZWdhdGl2ZSA9IChieXRlVmlld1s3XSAmIDB4ODApICE9IDA7XG4gICAgLyogZW5jb2RpbmcgaXMgdHdvJ3MtY29tcGxlbWVudCwgc28gdHJlYXQgbmVnYXRpdmUgYW5kIG5vbi1uZWdhdGl2ZSBkaWZmZXJlbnRseSAqL1xuICAgIGlmIChpc05lZ2F0aXZlKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZVZpZXcubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGxldCBieXRlVmFsdWUgPSBCaWdJbnQoMjU1IC0gYnl0ZVZpZXdbaV0pO1xuICAgICAgICAgICAgdmFsdWUgKz0gKGJ5dGVWYWx1ZSAqIHNoaWZ0KTtcbiAgICAgICAgICAgIHNoaWZ0ICo9IE1BWF9VSU5UOF9BU19CSUdJTlQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgKz0gQmlnSW50KDEpO1xuICAgICAgICB2YWx1ZSA9IC12YWx1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZVZpZXcubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGxldCBieXRlVmFsdWUgPSBCaWdJbnQoYnl0ZVZpZXdbaV0pO1xuICAgICAgICAgICAgdmFsdWUgKz0gKGJ5dGVWYWx1ZSAqIHNoaWZ0KTtcbiAgICAgICAgICAgIHNoaWZ0ICo9IE1BWF9VSU5UOF9BU19CSUdJTlQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZXhwb3J0cy51bm1hcnNoYWxJbnQ2NEJpZ2ludEZyb21CdWZmZXIgPSB1bm1hcnNoYWxJbnQ2NEJpZ2ludEZyb21CdWZmZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ldmVudHN0cmVhbV91dGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/aws-crt/dist/native/eventstream_utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/aws-crt/dist/native/http.js":
/*!**************************************************!*\
  !*** ./node_modules/aws-crt/dist/native/http.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n * SPDX-License-Identifier: Apache-2.0.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.HttpClientConnectionManager = exports.HttpClientStream = exports.HttpStream = exports.HttpClientConnection = exports.HttpProxyOptions = exports.HttpProxyConnectionType = exports.HttpConnection = exports.HttpRequest = exports.HttpHeaders = exports.HttpProxyAuthenticationType = void 0;\n/**\n *\n * A module containing support for creating http connections and making requests on them.\n *\n * @packageDocumentation\n * @module http\n * @mergeTarget\n */\nconst binding_1 = __importDefault(__webpack_require__(/*! ./binding */ \"(ssr)/./node_modules/aws-crt/dist/native/binding.js\"));\nconst native_resource_1 = __webpack_require__(/*! ./native_resource */ \"(ssr)/./node_modules/aws-crt/dist/native/native_resource.js\");\nconst error_1 = __webpack_require__(/*! ./error */ \"(ssr)/./node_modules/aws-crt/dist/native/error.js\");\nconst http_1 = __webpack_require__(/*! ../common/http */ \"(ssr)/./node_modules/aws-crt/dist/common/http.js\");\n/** @internal */\nvar http_2 = __webpack_require__(/*! ../common/http */ \"(ssr)/./node_modules/aws-crt/dist/common/http.js\");\nObject.defineProperty(exports, \"HttpProxyAuthenticationType\", ({ enumerable: true, get: function () { return http_2.HttpProxyAuthenticationType; } }));\nconst event_1 = __webpack_require__(/*! ../common/event */ \"(ssr)/./node_modules/aws-crt/dist/common/event.js\");\n/**\n * @category HTTP\n */\nexports.HttpHeaders = binding_1.default.HttpHeaders;\n/** @internal */\nconst nativeHttpRequest = binding_1.default.HttpRequest;\n/**\n * @category HTTP\n */\nclass HttpRequest extends nativeHttpRequest {\n    constructor(method, path, headers, body) {\n        super(method, path, headers, body === null || body === void 0 ? void 0 : body.native_handle());\n    }\n}\nexports.HttpRequest = HttpRequest;\n/**\n * Base class for HTTP connections\n *\n * @category HTTP\n */\nclass HttpConnection extends (0, native_resource_1.NativeResourceMixin)(event_1.BufferedEventEmitter) {\n    constructor(native_handle) {\n        super();\n        this._super(native_handle);\n    }\n    /**\n     * Close the connection.\n     * Shutdown is asynchronous. This call has no effect if the connection is already\n     * closing.\n     */\n    close() {\n        binding_1.default.http_connection_close(this.native_handle());\n    }\n    // Overridden to allow uncorking on ready\n    on(event, listener) {\n        super.on(event, listener);\n        if (event == 'connect') {\n            process.nextTick(() => {\n                this.uncork();\n            });\n        }\n        return this;\n    }\n}\nexports.HttpConnection = HttpConnection;\n/**\n * Emitted when the connection is connected and ready to start streams\n *\n * @event\n */\nHttpConnection.CONNECT = 'connect';\n/**\n * Emitted when an error occurs on the connection\n *\n * @event\n */\nHttpConnection.ERROR = 'error';\n/**\n * Emitted when the connection has completed\n *\n * @event\n */\nHttpConnection.CLOSE = 'close';\n/**\n * Proxy connection types.\n *\n * The original behavior was to make a tunneling connection if TLS was used, and a forwarding connection if it was not.\n * There are legitimate use cases for plaintext tunneling connections, and so the implicit behavior has now\n * been replaced by this setting, with a default that maps to the old behavior.\n *\n * @category HTTP\n */\nvar HttpProxyConnectionType;\n(function (HttpProxyConnectionType) {\n    /**\n     * (Default for backwards compatibility).  If Tls options are supplied then the connection will be a tunneling\n     * one, otherwise it will be a forwarding one.\n     */\n    HttpProxyConnectionType[HttpProxyConnectionType[\"Legacy\"] = 0] = \"Legacy\";\n    /**\n     * Establish a forwarding-based connection with the proxy.  Tls is not allowed in this case.\n     */\n    HttpProxyConnectionType[HttpProxyConnectionType[\"Forwarding\"] = 1] = \"Forwarding\";\n    /**\n     * Establish a tunneling-based connection with the proxy.\n     */\n    HttpProxyConnectionType[HttpProxyConnectionType[\"Tunneling\"] = 2] = \"Tunneling\";\n})(HttpProxyConnectionType = exports.HttpProxyConnectionType || (exports.HttpProxyConnectionType = {}));\n;\n/**\n * Proxy options for HTTP clients.\n *\n * @category HTTP\n */\nclass HttpProxyOptions extends http_1.CommonHttpProxyOptions {\n    /**\n     *\n     * @param host_name Name of the proxy server to connect through\n     * @param port Port number of the proxy server to connect through\n     * @param auth_method Type of proxy authentication to use. Default is {@link HttpProxyAuthenticationType.None}\n     * @param auth_username Username to use when `auth_type` is {@link HttpProxyAuthenticationType.Basic}\n     * @param auth_password Password to use when `auth_type` is {@link HttpProxyAuthenticationType.Basic}\n     * @param tls_opts Optional TLS connection options for the connection to the proxy host.\n     *                 Must be distinct from the {@link TlsConnectionOptions} provided to\n     *                 the HTTP connection\n     * @param connection_type Optional Type of connection to make.  If not specified,\n     *                 {@link HttpProxyConnectionType.Legacy} will be used.\n     */\n    constructor(host_name, port, auth_method = http_1.HttpProxyAuthenticationType.None, auth_username, auth_password, tls_opts, connection_type) {\n        super(host_name, port, auth_method, auth_username, auth_password);\n        this.tls_opts = tls_opts;\n        this.connection_type = connection_type;\n    }\n    /** @internal */\n    create_native_handle() {\n        return binding_1.default.http_proxy_options_new(this.host_name, this.port, this.auth_method, this.auth_username, this.auth_password, this.tls_opts ? this.tls_opts.native_handle() : undefined, this.connection_type ? this.connection_type : HttpProxyConnectionType.Legacy);\n    }\n}\nexports.HttpProxyOptions = HttpProxyOptions;\n/**\n * Represents an HTTP connection from a client to a server\n *\n * @category HTTP\n */\nclass HttpClientConnection extends HttpConnection {\n    /** Asynchronously establish a new HttpClientConnection.\n     * @param bootstrap Client bootstrap to use when initiating socket connection.  Leave undefined to use the\n     *          default system-wide bootstrap (recommended).\n     * @param host_name Host to connect to\n     * @param port Port to connect to on host\n     * @param socket_options Socket options\n     * @param tls_opts Optional TLS connection options\n     * @param proxy_options Optional proxy options\n    */\n    constructor(bootstrap, host_name, port, socket_options, tls_opts, proxy_options, handle) {\n        if (socket_options == null || socket_options == undefined) {\n            throw new error_1.CrtError(\"HttpClientConnection constructor: socket_options not defined\");\n        }\n        super(handle\n            ? handle\n            : binding_1.default.http_connection_new(bootstrap != null ? bootstrap.native_handle() : null, (handle, error_code) => {\n                this._on_setup(handle, error_code);\n            }, (handle, error_code) => {\n                this._on_shutdown(handle, error_code);\n            }, host_name, port, socket_options.native_handle(), tls_opts ? tls_opts.native_handle() : undefined, proxy_options ? proxy_options.create_native_handle() : undefined));\n        this.bootstrap = bootstrap;\n        this.socket_options = socket_options;\n        this.tls_opts = tls_opts;\n    }\n    _on_setup(native_handle, error_code) {\n        if (error_code) {\n            this.emit('error', new error_1.CrtError(error_code));\n            return;\n        }\n        this.emit('connect');\n    }\n    _on_shutdown(native_handle, error_code) {\n        if (error_code) {\n            this.emit('error', new error_1.CrtError(error_code));\n            return;\n        }\n        this.emit('close');\n    }\n    /**\n     * Create {@link HttpClientStream} to carry out the request/response exchange.\n     *\n     * NOTE: The stream sends no data until :meth:`HttpClientStream.activate()`\n     * is called. Call {@link HttpStream.activate} when you're ready for\n     * callbacks and events to fire.\n     * @param request - The HttpRequest to attempt on this connection\n     * @returns A new stream that will deliver events for the request\n     */\n    request(request) {\n        let stream;\n        const on_response_impl = (status_code, headers) => {\n            stream._on_response(status_code, headers);\n        };\n        const on_body_impl = (data) => {\n            stream._on_body(data);\n        };\n        const on_complete_impl = (error_code) => {\n            stream._on_complete(error_code);\n        };\n        const native_handle = binding_1.default.http_stream_new(this.native_handle(), request, on_complete_impl, on_response_impl, on_body_impl);\n        return stream = new HttpClientStream(native_handle, this, request);\n    }\n}\nexports.HttpClientConnection = HttpClientConnection;\n/**\n * Represents a single http message exchange (request/response) in HTTP/1.1. In H2, it may\n * also represent a PUSH_PROMISE followed by the accompanying response.\n *\n * NOTE: Binding either the ready or response event will uncork any buffered events and start\n * event delivery\n *\n * @category HTTP\n */\nclass HttpStream extends (0, native_resource_1.NativeResourceMixin)(event_1.BufferedEventEmitter) {\n    constructor(native_handle, connection) {\n        super();\n        this.connection = connection;\n        this._super(native_handle);\n        this.cork();\n    }\n    /**\n     * Begin sending the request.\n     *\n     * The stream does nothing until this is called. Call activate() when you\n     * are ready for its callbacks and events to fire.\n     */\n    activate() {\n        binding_1.default.http_stream_activate(this.native_handle());\n    }\n    /**\n     * Closes and ends all communication on this stream. Called automatically after the 'end'\n     * event is delivered. Calling this manually is only necessary if you wish to terminate\n     * communication mid-request/response.\n     */\n    close() {\n        binding_1.default.http_stream_close(this.native_handle());\n    }\n    /** @internal */\n    _on_body(data) {\n        this.emit('data', data);\n    }\n    /** @internal */\n    _on_complete(error_code) {\n        if (error_code) {\n            this.emit('error', new error_1.CrtError(error_code));\n            this.close();\n            return;\n        }\n        // schedule death after end is delivered\n        this.on('end', () => {\n            this.close();\n        });\n        this.emit('end');\n    }\n}\nexports.HttpStream = HttpStream;\n/**\n * Stream that sends a request and receives a response.\n *\n * Create an HttpClientStream with {@link HttpClientConnection.request}.\n *\n * NOTE: The stream sends no data until {@link HttpStream.activate} is called.\n * Call {@link HttpStream.activate} when you're ready for callbacks and events to fire.\n *\n * @category HTTP\n */\nclass HttpClientStream extends HttpStream {\n    constructor(native_handle, connection, request) {\n        super(native_handle, connection);\n        this.request = request;\n    }\n    /**\n     * HTTP status code returned from the server.\n     * @return Either the status code, or undefined if the server response has not arrived yet.\n     */\n    status_code() {\n        return this.response_status_code;\n    }\n    // Overridden to allow uncorking on ready and response\n    on(event, listener) {\n        super.on(event, listener);\n        if (event == 'response') {\n            process.nextTick(() => {\n                this.uncork();\n            });\n        }\n        return this;\n    }\n    /** @internal */\n    _on_response(status_code, header_array) {\n        this.response_status_code = status_code;\n        let headers = new exports.HttpHeaders(header_array);\n        this.emit('response', status_code, headers);\n    }\n}\nexports.HttpClientStream = HttpClientStream;\n/**\n * Emitted when the http response headers have arrived.\n *\n * @event\n */\nHttpClientStream.RESPONSE = 'response';\n/**\n * Emitted when http response data is available.\n *\n * @event\n */\nHttpClientStream.DATA = 'data';\n/**\n * Emitted when an error occurs in stream processing\n *\n * @event\n */\nHttpClientStream.ERROR = 'error';\n/**\n * Emitted when the stream has completed\n *\n * @event\n */\nHttpClientStream.END = 'end';\n/**\n * Emitted when inline headers are delivered while communicating over H2\n *\n * @event\n */\nHttpClientStream.HEADERS = 'headers';\n/**\n * Creates, manages, and vends connections to a given host/port endpoint\n *\n * @category HTTP\n */\nclass HttpClientConnectionManager extends native_resource_1.NativeResource {\n    /**\n     * @param bootstrap Client bootstrap to use when initiating socket connections.  Leave undefined to use the\n     *          default system-wide bootstrap (recommended).\n     * @param host Host to connect to\n     * @param port Port to connect to on host\n     * @param max_connections Maximum number of connections to pool\n     * @param initial_window_size Optional initial window size\n     * @param socket_options Socket options to use when initiating socket connections\n     * @param tls_opts Optional TLS connection options\n     * @param proxy_options Optional proxy options\n     */\n    constructor(bootstrap, host, port, max_connections, initial_window_size, socket_options, tls_opts, proxy_options) {\n        if (socket_options == null || socket_options == undefined) {\n            throw new error_1.CrtError(\"HttpClientConnectionManager constructor: socket_options not defined\");\n        }\n        super(binding_1.default.http_connection_manager_new(bootstrap != null ? bootstrap.native_handle() : null, host, port, max_connections, initial_window_size, socket_options.native_handle(), tls_opts ? tls_opts.native_handle() : undefined, proxy_options ? proxy_options.create_native_handle() : undefined, undefined /* on_shutdown */));\n        this.bootstrap = bootstrap;\n        this.host = host;\n        this.port = port;\n        this.max_connections = max_connections;\n        this.initial_window_size = initial_window_size;\n        this.socket_options = socket_options;\n        this.tls_opts = tls_opts;\n        this.proxy_options = proxy_options;\n        this.connections = new Map();\n    }\n    /**\n    * Vends a connection from the pool\n    * @returns A promise that results in an HttpClientConnection. When done with the connection, return\n    *          it via {@link release}\n    */\n    acquire() {\n        return new Promise((resolve, reject) => {\n            // Only create 1 connection in JS/TS from each native connection\n            const on_acquired = (handle, error_code) => {\n                if (error_code) {\n                    reject(new error_1.CrtError(error_code));\n                    return;\n                }\n                let connection = this.connections.get(handle);\n                if (!connection) {\n                    connection = new HttpClientConnection(this.bootstrap, this.host, this.port, this.socket_options, this.tls_opts, this.proxy_options, handle);\n                    this.connections.set(handle, connection);\n                    connection.on('close', () => {\n                        this.connections.delete(handle);\n                    });\n                }\n                resolve(connection);\n            };\n            binding_1.default.http_connection_manager_acquire(this.native_handle(), on_acquired);\n        });\n    }\n    /**\n     * Returns an unused connection to the pool\n     * @param connection - The connection to return\n    */\n    release(connection) {\n        if (connection == null || connection == undefined) {\n            throw new error_1.CrtError(\"HttpClientConnectionManager release: connection not defined\");\n        }\n        binding_1.default.http_connection_manager_release(this.native_handle(), connection.native_handle());\n    }\n    /** Closes all connections and rejects all pending requests */\n    close() {\n        binding_1.default.http_connection_manager_close(this.native_handle());\n    }\n}\nexports.HttpClientConnectionManager = HttpClientConnectionManager;\n//# sourceMappingURL=http.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXdzLWNydC9kaXN0L25hdGl2ZS9odHRwLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQ0FBbUMsR0FBRyx3QkFBd0IsR0FBRyxrQkFBa0IsR0FBRyw0QkFBNEIsR0FBRyx3QkFBd0IsR0FBRywrQkFBK0IsR0FBRyxzQkFBc0IsR0FBRyxtQkFBbUIsR0FBRyxtQkFBbUIsR0FBRyxtQ0FBbUM7QUFDMVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxtQkFBTyxDQUFDLHNFQUFXO0FBQ3JELDBCQUEwQixtQkFBTyxDQUFDLHNGQUFtQjtBQUNyRCxnQkFBZ0IsbUJBQU8sQ0FBQyxrRUFBUztBQUNqQyxlQUFlLG1CQUFPLENBQUMsd0VBQWdCO0FBQ3ZDO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLHdFQUFnQjtBQUNyQywrREFBOEQsRUFBRSxxQ0FBcUMsOENBQThDLEVBQUM7QUFDcEosZ0JBQWdCLG1CQUFPLENBQUMsMEVBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnRUFBZ0UsK0JBQStCLEtBQUs7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRTtBQUMzRSxpRUFBaUU7QUFDakUsaUVBQWlFO0FBQ2pFO0FBQ0Esa0RBQWtELDRCQUE0QjtBQUM5RTtBQUNBO0FBQ0Esd0JBQXdCLHNDQUFzQztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHdCQUF3QjtBQUN2QztBQUNBO0FBQ0Esd0JBQXdCLDJCQUEyQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsbUNBQW1DO0FBQ3ZFO0FBQ0EseUNBQXlDLDJCQUEyQjtBQUNwRSxTQUFTLDJCQUEyQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wYXl3aW5kLy4vbm9kZV9tb2R1bGVzL2F3cy1jcnQvZGlzdC9uYXRpdmUvaHR0cC5qcz80OTRhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjAuXG4gKi9cbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSHR0cENsaWVudENvbm5lY3Rpb25NYW5hZ2VyID0gZXhwb3J0cy5IdHRwQ2xpZW50U3RyZWFtID0gZXhwb3J0cy5IdHRwU3RyZWFtID0gZXhwb3J0cy5IdHRwQ2xpZW50Q29ubmVjdGlvbiA9IGV4cG9ydHMuSHR0cFByb3h5T3B0aW9ucyA9IGV4cG9ydHMuSHR0cFByb3h5Q29ubmVjdGlvblR5cGUgPSBleHBvcnRzLkh0dHBDb25uZWN0aW9uID0gZXhwb3J0cy5IdHRwUmVxdWVzdCA9IGV4cG9ydHMuSHR0cEhlYWRlcnMgPSBleHBvcnRzLkh0dHBQcm94eUF1dGhlbnRpY2F0aW9uVHlwZSA9IHZvaWQgMDtcbi8qKlxuICpcbiAqIEEgbW9kdWxlIGNvbnRhaW5pbmcgc3VwcG9ydCBmb3IgY3JlYXRpbmcgaHR0cCBjb25uZWN0aW9ucyBhbmQgbWFraW5nIHJlcXVlc3RzIG9uIHRoZW0uXG4gKlxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKiBAbW9kdWxlIGh0dHBcbiAqIEBtZXJnZVRhcmdldFxuICovXG5jb25zdCBiaW5kaW5nXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vYmluZGluZ1wiKSk7XG5jb25zdCBuYXRpdmVfcmVzb3VyY2VfMSA9IHJlcXVpcmUoXCIuL25hdGl2ZV9yZXNvdXJjZVwiKTtcbmNvbnN0IGVycm9yXzEgPSByZXF1aXJlKFwiLi9lcnJvclwiKTtcbmNvbnN0IGh0dHBfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vaHR0cFwiKTtcbi8qKiBAaW50ZXJuYWwgKi9cbnZhciBodHRwXzIgPSByZXF1aXJlKFwiLi4vY29tbW9uL2h0dHBcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJIdHRwUHJveHlBdXRoZW50aWNhdGlvblR5cGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGh0dHBfMi5IdHRwUHJveHlBdXRoZW50aWNhdGlvblR5cGU7IH0gfSk7XG5jb25zdCBldmVudF8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9ldmVudFwiKTtcbi8qKlxuICogQGNhdGVnb3J5IEhUVFBcbiAqL1xuZXhwb3J0cy5IdHRwSGVhZGVycyA9IGJpbmRpbmdfMS5kZWZhdWx0Lkh0dHBIZWFkZXJzO1xuLyoqIEBpbnRlcm5hbCAqL1xuY29uc3QgbmF0aXZlSHR0cFJlcXVlc3QgPSBiaW5kaW5nXzEuZGVmYXVsdC5IdHRwUmVxdWVzdDtcbi8qKlxuICogQGNhdGVnb3J5IEhUVFBcbiAqL1xuY2xhc3MgSHR0cFJlcXVlc3QgZXh0ZW5kcyBuYXRpdmVIdHRwUmVxdWVzdCB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kLCBwYXRoLCBoZWFkZXJzLCBib2R5KSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgcGF0aCwgaGVhZGVycywgYm9keSA9PT0gbnVsbCB8fCBib2R5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBib2R5Lm5hdGl2ZV9oYW5kbGUoKSk7XG4gICAgfVxufVxuZXhwb3J0cy5IdHRwUmVxdWVzdCA9IEh0dHBSZXF1ZXN0O1xuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBIVFRQIGNvbm5lY3Rpb25zXG4gKlxuICogQGNhdGVnb3J5IEhUVFBcbiAqL1xuY2xhc3MgSHR0cENvbm5lY3Rpb24gZXh0ZW5kcyAoMCwgbmF0aXZlX3Jlc291cmNlXzEuTmF0aXZlUmVzb3VyY2VNaXhpbikoZXZlbnRfMS5CdWZmZXJlZEV2ZW50RW1pdHRlcikge1xuICAgIGNvbnN0cnVjdG9yKG5hdGl2ZV9oYW5kbGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fc3VwZXIobmF0aXZlX2hhbmRsZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlIHRoZSBjb25uZWN0aW9uLlxuICAgICAqIFNodXRkb3duIGlzIGFzeW5jaHJvbm91cy4gVGhpcyBjYWxsIGhhcyBubyBlZmZlY3QgaWYgdGhlIGNvbm5lY3Rpb24gaXMgYWxyZWFkeVxuICAgICAqIGNsb3NpbmcuXG4gICAgICovXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGJpbmRpbmdfMS5kZWZhdWx0Lmh0dHBfY29ubmVjdGlvbl9jbG9zZSh0aGlzLm5hdGl2ZV9oYW5kbGUoKSk7XG4gICAgfVxuICAgIC8vIE92ZXJyaWRkZW4gdG8gYWxsb3cgdW5jb3JraW5nIG9uIHJlYWR5XG4gICAgb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHN1cGVyLm9uKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgICAgIGlmIChldmVudCA9PSAnY29ubmVjdCcpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudW5jb3JrKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5leHBvcnRzLkh0dHBDb25uZWN0aW9uID0gSHR0cENvbm5lY3Rpb247XG4vKipcbiAqIEVtaXR0ZWQgd2hlbiB0aGUgY29ubmVjdGlvbiBpcyBjb25uZWN0ZWQgYW5kIHJlYWR5IHRvIHN0YXJ0IHN0cmVhbXNcbiAqXG4gKiBAZXZlbnRcbiAqL1xuSHR0cENvbm5lY3Rpb24uQ09OTkVDVCA9ICdjb25uZWN0Jztcbi8qKlxuICogRW1pdHRlZCB3aGVuIGFuIGVycm9yIG9jY3VycyBvbiB0aGUgY29ubmVjdGlvblxuICpcbiAqIEBldmVudFxuICovXG5IdHRwQ29ubmVjdGlvbi5FUlJPUiA9ICdlcnJvcic7XG4vKipcbiAqIEVtaXR0ZWQgd2hlbiB0aGUgY29ubmVjdGlvbiBoYXMgY29tcGxldGVkXG4gKlxuICogQGV2ZW50XG4gKi9cbkh0dHBDb25uZWN0aW9uLkNMT1NFID0gJ2Nsb3NlJztcbi8qKlxuICogUHJveHkgY29ubmVjdGlvbiB0eXBlcy5cbiAqXG4gKiBUaGUgb3JpZ2luYWwgYmVoYXZpb3Igd2FzIHRvIG1ha2UgYSB0dW5uZWxpbmcgY29ubmVjdGlvbiBpZiBUTFMgd2FzIHVzZWQsIGFuZCBhIGZvcndhcmRpbmcgY29ubmVjdGlvbiBpZiBpdCB3YXMgbm90LlxuICogVGhlcmUgYXJlIGxlZ2l0aW1hdGUgdXNlIGNhc2VzIGZvciBwbGFpbnRleHQgdHVubmVsaW5nIGNvbm5lY3Rpb25zLCBhbmQgc28gdGhlIGltcGxpY2l0IGJlaGF2aW9yIGhhcyBub3dcbiAqIGJlZW4gcmVwbGFjZWQgYnkgdGhpcyBzZXR0aW5nLCB3aXRoIGEgZGVmYXVsdCB0aGF0IG1hcHMgdG8gdGhlIG9sZCBiZWhhdmlvci5cbiAqXG4gKiBAY2F0ZWdvcnkgSFRUUFxuICovXG52YXIgSHR0cFByb3h5Q29ubmVjdGlvblR5cGU7XG4oZnVuY3Rpb24gKEh0dHBQcm94eUNvbm5lY3Rpb25UeXBlKSB7XG4gICAgLyoqXG4gICAgICogKERlZmF1bHQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5KS4gIElmIFRscyBvcHRpb25zIGFyZSBzdXBwbGllZCB0aGVuIHRoZSBjb25uZWN0aW9uIHdpbGwgYmUgYSB0dW5uZWxpbmdcbiAgICAgKiBvbmUsIG90aGVyd2lzZSBpdCB3aWxsIGJlIGEgZm9yd2FyZGluZyBvbmUuXG4gICAgICovXG4gICAgSHR0cFByb3h5Q29ubmVjdGlvblR5cGVbSHR0cFByb3h5Q29ubmVjdGlvblR5cGVbXCJMZWdhY3lcIl0gPSAwXSA9IFwiTGVnYWN5XCI7XG4gICAgLyoqXG4gICAgICogRXN0YWJsaXNoIGEgZm9yd2FyZGluZy1iYXNlZCBjb25uZWN0aW9uIHdpdGggdGhlIHByb3h5LiAgVGxzIGlzIG5vdCBhbGxvd2VkIGluIHRoaXMgY2FzZS5cbiAgICAgKi9cbiAgICBIdHRwUHJveHlDb25uZWN0aW9uVHlwZVtIdHRwUHJveHlDb25uZWN0aW9uVHlwZVtcIkZvcndhcmRpbmdcIl0gPSAxXSA9IFwiRm9yd2FyZGluZ1wiO1xuICAgIC8qKlxuICAgICAqIEVzdGFibGlzaCBhIHR1bm5lbGluZy1iYXNlZCBjb25uZWN0aW9uIHdpdGggdGhlIHByb3h5LlxuICAgICAqL1xuICAgIEh0dHBQcm94eUNvbm5lY3Rpb25UeXBlW0h0dHBQcm94eUNvbm5lY3Rpb25UeXBlW1wiVHVubmVsaW5nXCJdID0gMl0gPSBcIlR1bm5lbGluZ1wiO1xufSkoSHR0cFByb3h5Q29ubmVjdGlvblR5cGUgPSBleHBvcnRzLkh0dHBQcm94eUNvbm5lY3Rpb25UeXBlIHx8IChleHBvcnRzLkh0dHBQcm94eUNvbm5lY3Rpb25UeXBlID0ge30pKTtcbjtcbi8qKlxuICogUHJveHkgb3B0aW9ucyBmb3IgSFRUUCBjbGllbnRzLlxuICpcbiAqIEBjYXRlZ29yeSBIVFRQXG4gKi9cbmNsYXNzIEh0dHBQcm94eU9wdGlvbnMgZXh0ZW5kcyBodHRwXzEuQ29tbW9uSHR0cFByb3h5T3B0aW9ucyB7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaG9zdF9uYW1lIE5hbWUgb2YgdGhlIHByb3h5IHNlcnZlciB0byBjb25uZWN0IHRocm91Z2hcbiAgICAgKiBAcGFyYW0gcG9ydCBQb3J0IG51bWJlciBvZiB0aGUgcHJveHkgc2VydmVyIHRvIGNvbm5lY3QgdGhyb3VnaFxuICAgICAqIEBwYXJhbSBhdXRoX21ldGhvZCBUeXBlIG9mIHByb3h5IGF1dGhlbnRpY2F0aW9uIHRvIHVzZS4gRGVmYXVsdCBpcyB7QGxpbmsgSHR0cFByb3h5QXV0aGVudGljYXRpb25UeXBlLk5vbmV9XG4gICAgICogQHBhcmFtIGF1dGhfdXNlcm5hbWUgVXNlcm5hbWUgdG8gdXNlIHdoZW4gYGF1dGhfdHlwZWAgaXMge0BsaW5rIEh0dHBQcm94eUF1dGhlbnRpY2F0aW9uVHlwZS5CYXNpY31cbiAgICAgKiBAcGFyYW0gYXV0aF9wYXNzd29yZCBQYXNzd29yZCB0byB1c2Ugd2hlbiBgYXV0aF90eXBlYCBpcyB7QGxpbmsgSHR0cFByb3h5QXV0aGVudGljYXRpb25UeXBlLkJhc2ljfVxuICAgICAqIEBwYXJhbSB0bHNfb3B0cyBPcHRpb25hbCBUTFMgY29ubmVjdGlvbiBvcHRpb25zIGZvciB0aGUgY29ubmVjdGlvbiB0byB0aGUgcHJveHkgaG9zdC5cbiAgICAgKiAgICAgICAgICAgICAgICAgTXVzdCBiZSBkaXN0aW5jdCBmcm9tIHRoZSB7QGxpbmsgVGxzQ29ubmVjdGlvbk9wdGlvbnN9IHByb3ZpZGVkIHRvXG4gICAgICogICAgICAgICAgICAgICAgIHRoZSBIVFRQIGNvbm5lY3Rpb25cbiAgICAgKiBAcGFyYW0gY29ubmVjdGlvbl90eXBlIE9wdGlvbmFsIFR5cGUgb2YgY29ubmVjdGlvbiB0byBtYWtlLiAgSWYgbm90IHNwZWNpZmllZCxcbiAgICAgKiAgICAgICAgICAgICAgICAge0BsaW5rIEh0dHBQcm94eUNvbm5lY3Rpb25UeXBlLkxlZ2FjeX0gd2lsbCBiZSB1c2VkLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGhvc3RfbmFtZSwgcG9ydCwgYXV0aF9tZXRob2QgPSBodHRwXzEuSHR0cFByb3h5QXV0aGVudGljYXRpb25UeXBlLk5vbmUsIGF1dGhfdXNlcm5hbWUsIGF1dGhfcGFzc3dvcmQsIHRsc19vcHRzLCBjb25uZWN0aW9uX3R5cGUpIHtcbiAgICAgICAgc3VwZXIoaG9zdF9uYW1lLCBwb3J0LCBhdXRoX21ldGhvZCwgYXV0aF91c2VybmFtZSwgYXV0aF9wYXNzd29yZCk7XG4gICAgICAgIHRoaXMudGxzX29wdHMgPSB0bHNfb3B0cztcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uX3R5cGUgPSBjb25uZWN0aW9uX3R5cGU7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBjcmVhdGVfbmF0aXZlX2hhbmRsZSgpIHtcbiAgICAgICAgcmV0dXJuIGJpbmRpbmdfMS5kZWZhdWx0Lmh0dHBfcHJveHlfb3B0aW9uc19uZXcodGhpcy5ob3N0X25hbWUsIHRoaXMucG9ydCwgdGhpcy5hdXRoX21ldGhvZCwgdGhpcy5hdXRoX3VzZXJuYW1lLCB0aGlzLmF1dGhfcGFzc3dvcmQsIHRoaXMudGxzX29wdHMgPyB0aGlzLnRsc19vcHRzLm5hdGl2ZV9oYW5kbGUoKSA6IHVuZGVmaW5lZCwgdGhpcy5jb25uZWN0aW9uX3R5cGUgPyB0aGlzLmNvbm5lY3Rpb25fdHlwZSA6IEh0dHBQcm94eUNvbm5lY3Rpb25UeXBlLkxlZ2FjeSk7XG4gICAgfVxufVxuZXhwb3J0cy5IdHRwUHJveHlPcHRpb25zID0gSHR0cFByb3h5T3B0aW9ucztcbi8qKlxuICogUmVwcmVzZW50cyBhbiBIVFRQIGNvbm5lY3Rpb24gZnJvbSBhIGNsaWVudCB0byBhIHNlcnZlclxuICpcbiAqIEBjYXRlZ29yeSBIVFRQXG4gKi9cbmNsYXNzIEh0dHBDbGllbnRDb25uZWN0aW9uIGV4dGVuZHMgSHR0cENvbm5lY3Rpb24ge1xuICAgIC8qKiBBc3luY2hyb25vdXNseSBlc3RhYmxpc2ggYSBuZXcgSHR0cENsaWVudENvbm5lY3Rpb24uXG4gICAgICogQHBhcmFtIGJvb3RzdHJhcCBDbGllbnQgYm9vdHN0cmFwIHRvIHVzZSB3aGVuIGluaXRpYXRpbmcgc29ja2V0IGNvbm5lY3Rpb24uICBMZWF2ZSB1bmRlZmluZWQgdG8gdXNlIHRoZVxuICAgICAqICAgICAgICAgIGRlZmF1bHQgc3lzdGVtLXdpZGUgYm9vdHN0cmFwIChyZWNvbW1lbmRlZCkuXG4gICAgICogQHBhcmFtIGhvc3RfbmFtZSBIb3N0IHRvIGNvbm5lY3QgdG9cbiAgICAgKiBAcGFyYW0gcG9ydCBQb3J0IHRvIGNvbm5lY3QgdG8gb24gaG9zdFxuICAgICAqIEBwYXJhbSBzb2NrZXRfb3B0aW9ucyBTb2NrZXQgb3B0aW9uc1xuICAgICAqIEBwYXJhbSB0bHNfb3B0cyBPcHRpb25hbCBUTFMgY29ubmVjdGlvbiBvcHRpb25zXG4gICAgICogQHBhcmFtIHByb3h5X29wdGlvbnMgT3B0aW9uYWwgcHJveHkgb3B0aW9uc1xuICAgICovXG4gICAgY29uc3RydWN0b3IoYm9vdHN0cmFwLCBob3N0X25hbWUsIHBvcnQsIHNvY2tldF9vcHRpb25zLCB0bHNfb3B0cywgcHJveHlfb3B0aW9ucywgaGFuZGxlKSB7XG4gICAgICAgIGlmIChzb2NrZXRfb3B0aW9ucyA9PSBudWxsIHx8IHNvY2tldF9vcHRpb25zID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yXzEuQ3J0RXJyb3IoXCJIdHRwQ2xpZW50Q29ubmVjdGlvbiBjb25zdHJ1Y3Rvcjogc29ja2V0X29wdGlvbnMgbm90IGRlZmluZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoaGFuZGxlXG4gICAgICAgICAgICA/IGhhbmRsZVxuICAgICAgICAgICAgOiBiaW5kaW5nXzEuZGVmYXVsdC5odHRwX2Nvbm5lY3Rpb25fbmV3KGJvb3RzdHJhcCAhPSBudWxsID8gYm9vdHN0cmFwLm5hdGl2ZV9oYW5kbGUoKSA6IG51bGwsIChoYW5kbGUsIGVycm9yX2NvZGUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vbl9zZXR1cChoYW5kbGUsIGVycm9yX2NvZGUpO1xuICAgICAgICAgICAgfSwgKGhhbmRsZSwgZXJyb3JfY29kZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX29uX3NodXRkb3duKGhhbmRsZSwgZXJyb3JfY29kZSk7XG4gICAgICAgICAgICB9LCBob3N0X25hbWUsIHBvcnQsIHNvY2tldF9vcHRpb25zLm5hdGl2ZV9oYW5kbGUoKSwgdGxzX29wdHMgPyB0bHNfb3B0cy5uYXRpdmVfaGFuZGxlKCkgOiB1bmRlZmluZWQsIHByb3h5X29wdGlvbnMgPyBwcm94eV9vcHRpb25zLmNyZWF0ZV9uYXRpdmVfaGFuZGxlKCkgOiB1bmRlZmluZWQpKTtcbiAgICAgICAgdGhpcy5ib290c3RyYXAgPSBib290c3RyYXA7XG4gICAgICAgIHRoaXMuc29ja2V0X29wdGlvbnMgPSBzb2NrZXRfb3B0aW9ucztcbiAgICAgICAgdGhpcy50bHNfb3B0cyA9IHRsc19vcHRzO1xuICAgIH1cbiAgICBfb25fc2V0dXAobmF0aXZlX2hhbmRsZSwgZXJyb3JfY29kZSkge1xuICAgICAgICBpZiAoZXJyb3JfY29kZSkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBlcnJvcl8xLkNydEVycm9yKGVycm9yX2NvZGUpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoJ2Nvbm5lY3QnKTtcbiAgICB9XG4gICAgX29uX3NodXRkb3duKG5hdGl2ZV9oYW5kbGUsIGVycm9yX2NvZGUpIHtcbiAgICAgICAgaWYgKGVycm9yX2NvZGUpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgZXJyb3JfMS5DcnRFcnJvcihlcnJvcl9jb2RlKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KCdjbG9zZScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUge0BsaW5rIEh0dHBDbGllbnRTdHJlYW19IHRvIGNhcnJ5IG91dCB0aGUgcmVxdWVzdC9yZXNwb25zZSBleGNoYW5nZS5cbiAgICAgKlxuICAgICAqIE5PVEU6IFRoZSBzdHJlYW0gc2VuZHMgbm8gZGF0YSB1bnRpbCA6bWV0aDpgSHR0cENsaWVudFN0cmVhbS5hY3RpdmF0ZSgpYFxuICAgICAqIGlzIGNhbGxlZC4gQ2FsbCB7QGxpbmsgSHR0cFN0cmVhbS5hY3RpdmF0ZX0gd2hlbiB5b3UncmUgcmVhZHkgZm9yXG4gICAgICogY2FsbGJhY2tzIGFuZCBldmVudHMgdG8gZmlyZS5cbiAgICAgKiBAcGFyYW0gcmVxdWVzdCAtIFRoZSBIdHRwUmVxdWVzdCB0byBhdHRlbXB0IG9uIHRoaXMgY29ubmVjdGlvblxuICAgICAqIEByZXR1cm5zIEEgbmV3IHN0cmVhbSB0aGF0IHdpbGwgZGVsaXZlciBldmVudHMgZm9yIHRoZSByZXF1ZXN0XG4gICAgICovXG4gICAgcmVxdWVzdChyZXF1ZXN0KSB7XG4gICAgICAgIGxldCBzdHJlYW07XG4gICAgICAgIGNvbnN0IG9uX3Jlc3BvbnNlX2ltcGwgPSAoc3RhdHVzX2NvZGUsIGhlYWRlcnMpID0+IHtcbiAgICAgICAgICAgIHN0cmVhbS5fb25fcmVzcG9uc2Uoc3RhdHVzX2NvZGUsIGhlYWRlcnMpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvbl9ib2R5X2ltcGwgPSAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgc3RyZWFtLl9vbl9ib2R5KGRhdGEpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvbl9jb21wbGV0ZV9pbXBsID0gKGVycm9yX2NvZGUpID0+IHtcbiAgICAgICAgICAgIHN0cmVhbS5fb25fY29tcGxldGUoZXJyb3JfY29kZSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG5hdGl2ZV9oYW5kbGUgPSBiaW5kaW5nXzEuZGVmYXVsdC5odHRwX3N0cmVhbV9uZXcodGhpcy5uYXRpdmVfaGFuZGxlKCksIHJlcXVlc3QsIG9uX2NvbXBsZXRlX2ltcGwsIG9uX3Jlc3BvbnNlX2ltcGwsIG9uX2JvZHlfaW1wbCk7XG4gICAgICAgIHJldHVybiBzdHJlYW0gPSBuZXcgSHR0cENsaWVudFN0cmVhbShuYXRpdmVfaGFuZGxlLCB0aGlzLCByZXF1ZXN0KTtcbiAgICB9XG59XG5leHBvcnRzLkh0dHBDbGllbnRDb25uZWN0aW9uID0gSHR0cENsaWVudENvbm5lY3Rpb247XG4vKipcbiAqIFJlcHJlc2VudHMgYSBzaW5nbGUgaHR0cCBtZXNzYWdlIGV4Y2hhbmdlIChyZXF1ZXN0L3Jlc3BvbnNlKSBpbiBIVFRQLzEuMS4gSW4gSDIsIGl0IG1heVxuICogYWxzbyByZXByZXNlbnQgYSBQVVNIX1BST01JU0UgZm9sbG93ZWQgYnkgdGhlIGFjY29tcGFueWluZyByZXNwb25zZS5cbiAqXG4gKiBOT1RFOiBCaW5kaW5nIGVpdGhlciB0aGUgcmVhZHkgb3IgcmVzcG9uc2UgZXZlbnQgd2lsbCB1bmNvcmsgYW55IGJ1ZmZlcmVkIGV2ZW50cyBhbmQgc3RhcnRcbiAqIGV2ZW50IGRlbGl2ZXJ5XG4gKlxuICogQGNhdGVnb3J5IEhUVFBcbiAqL1xuY2xhc3MgSHR0cFN0cmVhbSBleHRlbmRzICgwLCBuYXRpdmVfcmVzb3VyY2VfMS5OYXRpdmVSZXNvdXJjZU1peGluKShldmVudF8xLkJ1ZmZlcmVkRXZlbnRFbWl0dGVyKSB7XG4gICAgY29uc3RydWN0b3IobmF0aXZlX2hhbmRsZSwgY29ubmVjdGlvbikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xuICAgICAgICB0aGlzLl9zdXBlcihuYXRpdmVfaGFuZGxlKTtcbiAgICAgICAgdGhpcy5jb3JrKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJlZ2luIHNlbmRpbmcgdGhlIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBUaGUgc3RyZWFtIGRvZXMgbm90aGluZyB1bnRpbCB0aGlzIGlzIGNhbGxlZC4gQ2FsbCBhY3RpdmF0ZSgpIHdoZW4geW91XG4gICAgICogYXJlIHJlYWR5IGZvciBpdHMgY2FsbGJhY2tzIGFuZCBldmVudHMgdG8gZmlyZS5cbiAgICAgKi9cbiAgICBhY3RpdmF0ZSgpIHtcbiAgICAgICAgYmluZGluZ18xLmRlZmF1bHQuaHR0cF9zdHJlYW1fYWN0aXZhdGUodGhpcy5uYXRpdmVfaGFuZGxlKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgYW5kIGVuZHMgYWxsIGNvbW11bmljYXRpb24gb24gdGhpcyBzdHJlYW0uIENhbGxlZCBhdXRvbWF0aWNhbGx5IGFmdGVyIHRoZSAnZW5kJ1xuICAgICAqIGV2ZW50IGlzIGRlbGl2ZXJlZC4gQ2FsbGluZyB0aGlzIG1hbnVhbGx5IGlzIG9ubHkgbmVjZXNzYXJ5IGlmIHlvdSB3aXNoIHRvIHRlcm1pbmF0ZVxuICAgICAqIGNvbW11bmljYXRpb24gbWlkLXJlcXVlc3QvcmVzcG9uc2UuXG4gICAgICovXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGJpbmRpbmdfMS5kZWZhdWx0Lmh0dHBfc3RyZWFtX2Nsb3NlKHRoaXMubmF0aXZlX2hhbmRsZSgpKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9vbl9ib2R5KGRhdGEpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdkYXRhJywgZGF0YSk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfb25fY29tcGxldGUoZXJyb3JfY29kZSkge1xuICAgICAgICBpZiAoZXJyb3JfY29kZSkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBlcnJvcl8xLkNydEVycm9yKGVycm9yX2NvZGUpKTtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBzY2hlZHVsZSBkZWF0aCBhZnRlciBlbmQgaXMgZGVsaXZlcmVkXG4gICAgICAgIHRoaXMub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZW1pdCgnZW5kJyk7XG4gICAgfVxufVxuZXhwb3J0cy5IdHRwU3RyZWFtID0gSHR0cFN0cmVhbTtcbi8qKlxuICogU3RyZWFtIHRoYXQgc2VuZHMgYSByZXF1ZXN0IGFuZCByZWNlaXZlcyBhIHJlc3BvbnNlLlxuICpcbiAqIENyZWF0ZSBhbiBIdHRwQ2xpZW50U3RyZWFtIHdpdGgge0BsaW5rIEh0dHBDbGllbnRDb25uZWN0aW9uLnJlcXVlc3R9LlxuICpcbiAqIE5PVEU6IFRoZSBzdHJlYW0gc2VuZHMgbm8gZGF0YSB1bnRpbCB7QGxpbmsgSHR0cFN0cmVhbS5hY3RpdmF0ZX0gaXMgY2FsbGVkLlxuICogQ2FsbCB7QGxpbmsgSHR0cFN0cmVhbS5hY3RpdmF0ZX0gd2hlbiB5b3UncmUgcmVhZHkgZm9yIGNhbGxiYWNrcyBhbmQgZXZlbnRzIHRvIGZpcmUuXG4gKlxuICogQGNhdGVnb3J5IEhUVFBcbiAqL1xuY2xhc3MgSHR0cENsaWVudFN0cmVhbSBleHRlbmRzIEh0dHBTdHJlYW0ge1xuICAgIGNvbnN0cnVjdG9yKG5hdGl2ZV9oYW5kbGUsIGNvbm5lY3Rpb24sIHJlcXVlc3QpIHtcbiAgICAgICAgc3VwZXIobmF0aXZlX2hhbmRsZSwgY29ubmVjdGlvbik7XG4gICAgICAgIHRoaXMucmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhUVFAgc3RhdHVzIGNvZGUgcmV0dXJuZWQgZnJvbSB0aGUgc2VydmVyLlxuICAgICAqIEByZXR1cm4gRWl0aGVyIHRoZSBzdGF0dXMgY29kZSwgb3IgdW5kZWZpbmVkIGlmIHRoZSBzZXJ2ZXIgcmVzcG9uc2UgaGFzIG5vdCBhcnJpdmVkIHlldC5cbiAgICAgKi9cbiAgICBzdGF0dXNfY29kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzcG9uc2Vfc3RhdHVzX2NvZGU7XG4gICAgfVxuICAgIC8vIE92ZXJyaWRkZW4gdG8gYWxsb3cgdW5jb3JraW5nIG9uIHJlYWR5IGFuZCByZXNwb25zZVxuICAgIG9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICBzdXBlci5vbihldmVudCwgbGlzdGVuZXIpO1xuICAgICAgICBpZiAoZXZlbnQgPT0gJ3Jlc3BvbnNlJykge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy51bmNvcmsoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX29uX3Jlc3BvbnNlKHN0YXR1c19jb2RlLCBoZWFkZXJfYXJyYXkpIHtcbiAgICAgICAgdGhpcy5yZXNwb25zZV9zdGF0dXNfY29kZSA9IHN0YXR1c19jb2RlO1xuICAgICAgICBsZXQgaGVhZGVycyA9IG5ldyBleHBvcnRzLkh0dHBIZWFkZXJzKGhlYWRlcl9hcnJheSk7XG4gICAgICAgIHRoaXMuZW1pdCgncmVzcG9uc2UnLCBzdGF0dXNfY29kZSwgaGVhZGVycyk7XG4gICAgfVxufVxuZXhwb3J0cy5IdHRwQ2xpZW50U3RyZWFtID0gSHR0cENsaWVudFN0cmVhbTtcbi8qKlxuICogRW1pdHRlZCB3aGVuIHRoZSBodHRwIHJlc3BvbnNlIGhlYWRlcnMgaGF2ZSBhcnJpdmVkLlxuICpcbiAqIEBldmVudFxuICovXG5IdHRwQ2xpZW50U3RyZWFtLlJFU1BPTlNFID0gJ3Jlc3BvbnNlJztcbi8qKlxuICogRW1pdHRlZCB3aGVuIGh0dHAgcmVzcG9uc2UgZGF0YSBpcyBhdmFpbGFibGUuXG4gKlxuICogQGV2ZW50XG4gKi9cbkh0dHBDbGllbnRTdHJlYW0uREFUQSA9ICdkYXRhJztcbi8qKlxuICogRW1pdHRlZCB3aGVuIGFuIGVycm9yIG9jY3VycyBpbiBzdHJlYW0gcHJvY2Vzc2luZ1xuICpcbiAqIEBldmVudFxuICovXG5IdHRwQ2xpZW50U3RyZWFtLkVSUk9SID0gJ2Vycm9yJztcbi8qKlxuICogRW1pdHRlZCB3aGVuIHRoZSBzdHJlYW0gaGFzIGNvbXBsZXRlZFxuICpcbiAqIEBldmVudFxuICovXG5IdHRwQ2xpZW50U3RyZWFtLkVORCA9ICdlbmQnO1xuLyoqXG4gKiBFbWl0dGVkIHdoZW4gaW5saW5lIGhlYWRlcnMgYXJlIGRlbGl2ZXJlZCB3aGlsZSBjb21tdW5pY2F0aW5nIG92ZXIgSDJcbiAqXG4gKiBAZXZlbnRcbiAqL1xuSHR0cENsaWVudFN0cmVhbS5IRUFERVJTID0gJ2hlYWRlcnMnO1xuLyoqXG4gKiBDcmVhdGVzLCBtYW5hZ2VzLCBhbmQgdmVuZHMgY29ubmVjdGlvbnMgdG8gYSBnaXZlbiBob3N0L3BvcnQgZW5kcG9pbnRcbiAqXG4gKiBAY2F0ZWdvcnkgSFRUUFxuICovXG5jbGFzcyBIdHRwQ2xpZW50Q29ubmVjdGlvbk1hbmFnZXIgZXh0ZW5kcyBuYXRpdmVfcmVzb3VyY2VfMS5OYXRpdmVSZXNvdXJjZSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGJvb3RzdHJhcCBDbGllbnQgYm9vdHN0cmFwIHRvIHVzZSB3aGVuIGluaXRpYXRpbmcgc29ja2V0IGNvbm5lY3Rpb25zLiAgTGVhdmUgdW5kZWZpbmVkIHRvIHVzZSB0aGVcbiAgICAgKiAgICAgICAgICBkZWZhdWx0IHN5c3RlbS13aWRlIGJvb3RzdHJhcCAocmVjb21tZW5kZWQpLlxuICAgICAqIEBwYXJhbSBob3N0IEhvc3QgdG8gY29ubmVjdCB0b1xuICAgICAqIEBwYXJhbSBwb3J0IFBvcnQgdG8gY29ubmVjdCB0byBvbiBob3N0XG4gICAgICogQHBhcmFtIG1heF9jb25uZWN0aW9ucyBNYXhpbXVtIG51bWJlciBvZiBjb25uZWN0aW9ucyB0byBwb29sXG4gICAgICogQHBhcmFtIGluaXRpYWxfd2luZG93X3NpemUgT3B0aW9uYWwgaW5pdGlhbCB3aW5kb3cgc2l6ZVxuICAgICAqIEBwYXJhbSBzb2NrZXRfb3B0aW9ucyBTb2NrZXQgb3B0aW9ucyB0byB1c2Ugd2hlbiBpbml0aWF0aW5nIHNvY2tldCBjb25uZWN0aW9uc1xuICAgICAqIEBwYXJhbSB0bHNfb3B0cyBPcHRpb25hbCBUTFMgY29ubmVjdGlvbiBvcHRpb25zXG4gICAgICogQHBhcmFtIHByb3h5X29wdGlvbnMgT3B0aW9uYWwgcHJveHkgb3B0aW9uc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGJvb3RzdHJhcCwgaG9zdCwgcG9ydCwgbWF4X2Nvbm5lY3Rpb25zLCBpbml0aWFsX3dpbmRvd19zaXplLCBzb2NrZXRfb3B0aW9ucywgdGxzX29wdHMsIHByb3h5X29wdGlvbnMpIHtcbiAgICAgICAgaWYgKHNvY2tldF9vcHRpb25zID09IG51bGwgfHwgc29ja2V0X29wdGlvbnMgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JfMS5DcnRFcnJvcihcIkh0dHBDbGllbnRDb25uZWN0aW9uTWFuYWdlciBjb25zdHJ1Y3Rvcjogc29ja2V0X29wdGlvbnMgbm90IGRlZmluZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoYmluZGluZ18xLmRlZmF1bHQuaHR0cF9jb25uZWN0aW9uX21hbmFnZXJfbmV3KGJvb3RzdHJhcCAhPSBudWxsID8gYm9vdHN0cmFwLm5hdGl2ZV9oYW5kbGUoKSA6IG51bGwsIGhvc3QsIHBvcnQsIG1heF9jb25uZWN0aW9ucywgaW5pdGlhbF93aW5kb3dfc2l6ZSwgc29ja2V0X29wdGlvbnMubmF0aXZlX2hhbmRsZSgpLCB0bHNfb3B0cyA/IHRsc19vcHRzLm5hdGl2ZV9oYW5kbGUoKSA6IHVuZGVmaW5lZCwgcHJveHlfb3B0aW9ucyA/IHByb3h5X29wdGlvbnMuY3JlYXRlX25hdGl2ZV9oYW5kbGUoKSA6IHVuZGVmaW5lZCwgdW5kZWZpbmVkIC8qIG9uX3NodXRkb3duICovKSk7XG4gICAgICAgIHRoaXMuYm9vdHN0cmFwID0gYm9vdHN0cmFwO1xuICAgICAgICB0aGlzLmhvc3QgPSBob3N0O1xuICAgICAgICB0aGlzLnBvcnQgPSBwb3J0O1xuICAgICAgICB0aGlzLm1heF9jb25uZWN0aW9ucyA9IG1heF9jb25uZWN0aW9ucztcbiAgICAgICAgdGhpcy5pbml0aWFsX3dpbmRvd19zaXplID0gaW5pdGlhbF93aW5kb3dfc2l6ZTtcbiAgICAgICAgdGhpcy5zb2NrZXRfb3B0aW9ucyA9IHNvY2tldF9vcHRpb25zO1xuICAgICAgICB0aGlzLnRsc19vcHRzID0gdGxzX29wdHM7XG4gICAgICAgIHRoaXMucHJveHlfb3B0aW9ucyA9IHByb3h5X29wdGlvbnM7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICogVmVuZHMgYSBjb25uZWN0aW9uIGZyb20gdGhlIHBvb2xcbiAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc3VsdHMgaW4gYW4gSHR0cENsaWVudENvbm5lY3Rpb24uIFdoZW4gZG9uZSB3aXRoIHRoZSBjb25uZWN0aW9uLCByZXR1cm5cbiAgICAqICAgICAgICAgIGl0IHZpYSB7QGxpbmsgcmVsZWFzZX1cbiAgICAqL1xuICAgIGFjcXVpcmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAvLyBPbmx5IGNyZWF0ZSAxIGNvbm5lY3Rpb24gaW4gSlMvVFMgZnJvbSBlYWNoIG5hdGl2ZSBjb25uZWN0aW9uXG4gICAgICAgICAgICBjb25zdCBvbl9hY3F1aXJlZCA9IChoYW5kbGUsIGVycm9yX2NvZGUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3JfY29kZSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IGVycm9yXzEuQ3J0RXJyb3IoZXJyb3JfY29kZSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBjb25uZWN0aW9uID0gdGhpcy5jb25uZWN0aW9ucy5nZXQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbiA9IG5ldyBIdHRwQ2xpZW50Q29ubmVjdGlvbih0aGlzLmJvb3RzdHJhcCwgdGhpcy5ob3N0LCB0aGlzLnBvcnQsIHRoaXMuc29ja2V0X29wdGlvbnMsIHRoaXMudGxzX29wdHMsIHRoaXMucHJveHlfb3B0aW9ucywgaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9ucy5zZXQoaGFuZGxlLCBjb25uZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbi5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25zLmRlbGV0ZShoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShjb25uZWN0aW9uKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBiaW5kaW5nXzEuZGVmYXVsdC5odHRwX2Nvbm5lY3Rpb25fbWFuYWdlcl9hY3F1aXJlKHRoaXMubmF0aXZlX2hhbmRsZSgpLCBvbl9hY3F1aXJlZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIHVudXNlZCBjb25uZWN0aW9uIHRvIHRoZSBwb29sXG4gICAgICogQHBhcmFtIGNvbm5lY3Rpb24gLSBUaGUgY29ubmVjdGlvbiB0byByZXR1cm5cbiAgICAqL1xuICAgIHJlbGVhc2UoY29ubmVjdGlvbikge1xuICAgICAgICBpZiAoY29ubmVjdGlvbiA9PSBudWxsIHx8IGNvbm5lY3Rpb24gPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JfMS5DcnRFcnJvcihcIkh0dHBDbGllbnRDb25uZWN0aW9uTWFuYWdlciByZWxlYXNlOiBjb25uZWN0aW9uIG5vdCBkZWZpbmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGJpbmRpbmdfMS5kZWZhdWx0Lmh0dHBfY29ubmVjdGlvbl9tYW5hZ2VyX3JlbGVhc2UodGhpcy5uYXRpdmVfaGFuZGxlKCksIGNvbm5lY3Rpb24ubmF0aXZlX2hhbmRsZSgpKTtcbiAgICB9XG4gICAgLyoqIENsb3NlcyBhbGwgY29ubmVjdGlvbnMgYW5kIHJlamVjdHMgYWxsIHBlbmRpbmcgcmVxdWVzdHMgKi9cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgYmluZGluZ18xLmRlZmF1bHQuaHR0cF9jb25uZWN0aW9uX21hbmFnZXJfY2xvc2UodGhpcy5uYXRpdmVfaGFuZGxlKCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuSHR0cENsaWVudENvbm5lY3Rpb25NYW5hZ2VyID0gSHR0cENsaWVudENvbm5lY3Rpb25NYW5hZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aHR0cC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/aws-crt/dist/native/http.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/aws-crt/dist/native/io.js":
/*!************************************************!*\
  !*** ./node_modules/aws-crt/dist/native/io.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n * SPDX-License-Identifier: Apache-2.0.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Pkcs11Lib = exports.TlsConnectionOptions = exports.ServerTlsContext = exports.ClientTlsContext = exports.TlsContext = exports.TlsContextOptions = exports.SocketOptions = exports.ClientBootstrap = exports.InputStream = exports.is_alpn_available = exports.enable_logging = exports.LogLevel = exports.error_code_to_name = exports.error_code_to_string = exports.SocketDomain = exports.SocketType = exports.TlsVersion = void 0;\n/**\n *\n * A module containing a grab bag of support for core network I/O functionality, including sockets, TLS, DNS, logging,\n * error handling, streams, and connection -> thread mapping.\n *\n * Categories include:\n * - Network: socket configuration\n * - TLS: tls configuration\n * - Logging: logging controls and configuration\n * - IO: everything else\n *\n * @packageDocumentation\n * @module io\n * @mergeTarget\n */\nconst binding_1 = __importDefault(__webpack_require__(/*! ./binding */ \"(ssr)/./node_modules/aws-crt/dist/native/binding.js\"));\nconst native_resource_1 = __webpack_require__(/*! ./native_resource */ \"(ssr)/./node_modules/aws-crt/dist/native/native_resource.js\");\nconst io_1 = __webpack_require__(/*! ../common/io */ \"(ssr)/./node_modules/aws-crt/dist/common/io.js\");\nvar io_2 = __webpack_require__(/*! ../common/io */ \"(ssr)/./node_modules/aws-crt/dist/common/io.js\");\nObject.defineProperty(exports, \"TlsVersion\", ({ enumerable: true, get: function () { return io_2.TlsVersion; } }));\nObject.defineProperty(exports, \"SocketType\", ({ enumerable: true, get: function () { return io_2.SocketType; } }));\nObject.defineProperty(exports, \"SocketDomain\", ({ enumerable: true, get: function () { return io_2.SocketDomain; } }));\nconst error_1 = __webpack_require__(/*! ./error */ \"(ssr)/./node_modules/aws-crt/dist/native/error.js\");\n/**\n * Convert a native error code into a human-readable string\n * @param error_code - An error code returned from a native API call, or delivered\n * via callback.\n * @returns Long-form description of the error\n * @see CrtError\n *\n * nodejs only.\n *\n * @category System\n */\nfunction error_code_to_string(error_code) {\n    return binding_1.default.error_code_to_string(error_code);\n}\nexports.error_code_to_string = error_code_to_string;\n/**\n * Convert a native error code into a human-readable identifier\n * @param error_code - An error code returned from a native API call, or delivered\n * via callback.\n * @return error name as a string\n * @see CrtError\n *\n * nodejs only.\n *\n * @category System\n */\nfunction error_code_to_name(error_code) {\n    return binding_1.default.error_code_to_name(error_code);\n}\nexports.error_code_to_name = error_code_to_name;\n/**\n * The amount of detail that will be logged\n * @category Logging\n */\nvar LogLevel;\n(function (LogLevel) {\n    /** No logging whatsoever. Equivalent to never calling {@link enable_logging}. */\n    LogLevel[LogLevel[\"NONE\"] = 0] = \"NONE\";\n    /** Only fatals. In practice, this will not do much, as the process will log and then crash (intentionally) if a fatal condition occurs */\n    LogLevel[LogLevel[\"FATAL\"] = 1] = \"FATAL\";\n    /** Only errors */\n    LogLevel[LogLevel[\"ERROR\"] = 2] = \"ERROR\";\n    /** Only warnings and errors */\n    LogLevel[LogLevel[\"WARN\"] = 3] = \"WARN\";\n    /** Information about connection/stream creation/destruction events */\n    LogLevel[LogLevel[\"INFO\"] = 4] = \"INFO\";\n    /** Enough information to debug the chain of events a given network connection encounters */\n    LogLevel[LogLevel[\"DEBUG\"] = 5] = \"DEBUG\";\n    /** Everything. Only use this if you really need to know EVERY single call */\n    LogLevel[LogLevel[\"TRACE\"] = 6] = \"TRACE\";\n})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));\n/**\n * Enables logging of the native AWS CRT libraries.\n * @param level - The logging level to filter to. It is not possible to log less than WARN.\n *\n * nodejs only.\n * @category Logging\n */\nfunction enable_logging(level) {\n    binding_1.default.io_logging_enable(level);\n}\nexports.enable_logging = enable_logging;\n/**\n * Returns true if ALPN is available on this platform natively\n * @return true if ALPN is supported natively, false otherwise\n *\n * nodejs only.\n * @category TLS\n*/\nfunction is_alpn_available() {\n    return binding_1.default.is_alpn_available();\n}\nexports.is_alpn_available = is_alpn_available;\n/**\n * Wraps a ```Readable``` for reading by native code, used to stream\n *  data into the AWS CRT libraries.\n *\n * nodejs only.\n * @category IO\n */\nclass InputStream extends native_resource_1.NativeResource {\n    constructor(source) {\n        super(binding_1.default.io_input_stream_new(16 * 1024));\n        this.source = source;\n        this.source.on('data', (data) => {\n            data = Buffer.isBuffer(data) ? data : Buffer.from(data.toString());\n            binding_1.default.io_input_stream_append(this.native_handle(), data);\n        });\n        this.source.on('end', () => {\n            binding_1.default.io_input_stream_append(this.native_handle(), undefined);\n        });\n    }\n}\nexports.InputStream = InputStream;\n/**\n * Represents native resources required to bootstrap a client connection\n * Things like a host resolver, event loop group, etc. There should only need\n * to be 1 of these per application, in most cases.\n *\n * nodejs only.\n * @category IO\n */\nclass ClientBootstrap extends native_resource_1.NativeResource {\n    constructor() {\n        super(binding_1.default.io_client_bootstrap_new());\n    }\n}\nexports.ClientBootstrap = ClientBootstrap;\n/**\n * Standard Berkeley socket style options.\n *\n * nodejs only.\n * @category Network\n*/\nclass SocketOptions extends native_resource_1.NativeResource {\n    constructor(type = io_1.SocketType.STREAM, domain = io_1.SocketDomain.IPV6, connect_timeout_ms = 5000, keepalive = false, keep_alive_interval_sec = 0, keep_alive_timeout_sec = 0, keep_alive_max_failed_probes = 0) {\n        super(binding_1.default.io_socket_options_new(type, domain, connect_timeout_ms, keep_alive_interval_sec, keep_alive_timeout_sec, keep_alive_max_failed_probes, keepalive));\n    }\n}\nexports.SocketOptions = SocketOptions;\n/**\n * Options for creating a {@link ClientTlsContext} or {@link ServerTlsContext}.\n *\n * nodejs only.\n * @category TLS\n */\nclass TlsContextOptions {\n    constructor() {\n        /** Minimum version of TLS to support. Uses OS/system default if unspecified. */\n        this.min_tls_version = io_1.TlsVersion.Default;\n        /** List of ALPN protocols to be used on platforms which support ALPN */\n        this.alpn_list = [];\n        /**\n         * In client mode, this turns off x.509 validation. Don't do this unless you are testing.\n         * It is much better to just override the default trust store and pass the self-signed\n         * certificate as the ca_file argument.\n         *\n         * In server mode (ServerTlsContext), this defaults to false. If you want to enforce mutual TLS on the server,\n         * set this to true.\n         */\n        this.verify_peer = true;\n    }\n    /**\n     * Overrides the default system trust store.\n     * @param ca_dirpath - Only used on Unix-style systems where all trust anchors are\n     * stored in a directory (e.g. /etc/ssl/certs).\n     * @param ca_filepath - Single file containing all trust CAs, in PEM format\n     */\n    override_default_trust_store_from_path(ca_dirpath, ca_filepath) {\n        this.ca_dirpath = ca_dirpath;\n        this.ca_filepath = ca_filepath;\n    }\n    /**\n     * Overrides the default system trust store.\n     * @param certificate_authority - String containing all trust CAs, in PEM format\n     */\n    override_default_trust_store(certificate_authority) {\n        this.certificate_authority = certificate_authority;\n    }\n    /**\n     * Create options configured for mutual TLS in client mode,\n     * with client certificate and private key provided as in-memory strings.\n     * @param certificate - Client certificate file contents, in PEM format\n     * @param private_key - Client private key file contents, in PEM format\n     *\n     * @returns newly configured TlsContextOptions object\n     */\n    static create_client_with_mtls(certificate, private_key) {\n        let opt = new TlsContextOptions();\n        opt.certificate = certificate;\n        opt.private_key = private_key;\n        opt.verify_peer = true;\n        return opt;\n    }\n    /**\n     * Create options configured for mutual TLS in client mode,\n     * with client certificate and private key provided via filepath.\n     * @param certificate_filepath - Path to client certificate, in PEM format\n     * @param private_key_filepath - Path to private key, in PEM format\n     *\n     * @returns newly configured TlsContextOptions object\n     */\n    static create_client_with_mtls_from_path(certificate_filepath, private_key_filepath) {\n        let opt = new TlsContextOptions();\n        opt.certificate_filepath = certificate_filepath;\n        opt.private_key_filepath = private_key_filepath;\n        opt.verify_peer = true;\n        return opt;\n    }\n    /**\n     * Create options for mutual TLS in client mode,\n     * with client certificate and private key bundled in a single PKCS#12 file.\n     * @param pkcs12_filepath - Path to PKCS#12 file containing client certificate and private key.\n     * @param pkcs12_password - PKCS#12 password\n     *\n     * @returns newly configured TlsContextOptions object\n    */\n    static create_client_with_mtls_pkcs12_from_path(pkcs12_filepath, pkcs12_password) {\n        let opt = new TlsContextOptions();\n        opt.pkcs12_filepath = pkcs12_filepath;\n        opt.pkcs12_password = pkcs12_password;\n        opt.verify_peer = true;\n        return opt;\n    }\n    /**\n     * @deprecated Renamed [[create_client_with_mtls_pkcs12_from_path]]\n     */\n    static create_client_with_mtls_pkcs_from_path(pkcs12_filepath, pkcs12_password) {\n        return this.create_client_with_mtls_pkcs12_from_path(pkcs12_filepath, pkcs12_password);\n    }\n    /**\n     * Create options configured for mutual TLS in client mode,\n     * using a PKCS#11 library for private key operations.\n     *\n     * NOTE: This configuration only works on Unix devices.\n     *\n     * @param options - PKCS#11 options\n     *\n     * @returns newly configured TlsContextOptions object\n     */\n    static create_client_with_mtls_pkcs11(options) {\n        let opt = new TlsContextOptions();\n        opt.pkcs11_options = options;\n        opt.verify_peer = true;\n        return opt;\n    }\n    /**\n     * Create options configured for mutual TLS in client mode,\n     * using a certificate in a Windows certificate store.\n     *\n     * NOTE: Windows only.\n     *\n     * @param certificate_path - Path to certificate in a Windows certificate store.\n     *      The path must use backslashes and end with the certificate's thumbprint.\n     *      Example: `CurrentUser\\MY\\A11F8A9B5DF5B98BA3508FBCA575D09570E0D2C6`\n     */\n    static create_client_with_mtls_windows_cert_store_path(certificate_path) {\n        let opt = new TlsContextOptions();\n        opt.windows_cert_store_path = certificate_path;\n        opt.verify_peer = true;\n        return opt;\n    }\n    /**\n     * Creates TLS context with peer verification disabled, along with a certificate and private key\n     * @param certificate_filepath - Path to certificate, in PEM format\n     * @param private_key_filepath - Path to private key, in PEM format\n     *\n     * @returns newly configured TlsContextOptions object\n     */\n    static create_server_with_mtls_from_path(certificate_filepath, private_key_filepath) {\n        let opt = new TlsContextOptions();\n        opt.certificate_filepath = certificate_filepath;\n        opt.private_key_filepath = private_key_filepath;\n        opt.verify_peer = false;\n        return opt;\n    }\n    /**\n     * Creates TLS context with peer verification disabled, along with a certificate and private key\n     * in PKCS#12 format\n     * @param pkcs12_filepath - Path to certificate, in PKCS#12 format\n     * @param pkcs12_password - PKCS#12 Password\n     *\n     * @returns newly configured TlsContextOptions object\n     */\n    static create_server_with_mtls_pkcs_from_path(pkcs12_filepath, pkcs12_password) {\n        let opt = new TlsContextOptions();\n        opt.pkcs12_filepath = pkcs12_filepath;\n        opt.pkcs12_password = pkcs12_password;\n        opt.verify_peer = false;\n        return opt;\n    }\n}\nexports.TlsContextOptions = TlsContextOptions;\n/**\n * Abstract base TLS context used for client/server TLS communications over sockets.\n *\n * @see ClientTlsContext\n * @see ServerTlsContext\n *\n * nodejs only.\n * @category TLS\n */\nclass TlsContext extends native_resource_1.NativeResource {\n    constructor(ctx_opt) {\n        if (ctx_opt == null || ctx_opt == undefined) {\n            throw new error_1.CrtError(\"TlsContext constructor: ctx_opt not defined\");\n        }\n        super(binding_1.default.io_tls_ctx_new(ctx_opt.min_tls_version, ctx_opt.ca_filepath, ctx_opt.ca_dirpath, ctx_opt.certificate_authority, (ctx_opt.alpn_list && ctx_opt.alpn_list.length > 0) ? ctx_opt.alpn_list.join(';') : undefined, ctx_opt.certificate_filepath, ctx_opt.certificate, ctx_opt.private_key_filepath, ctx_opt.private_key, ctx_opt.pkcs12_filepath, ctx_opt.pkcs12_password, ctx_opt.pkcs11_options, ctx_opt.windows_cert_store_path, ctx_opt.verify_peer));\n    }\n}\nexports.TlsContext = TlsContext;\n/**\n * TLS context used for client TLS communications over sockets. If no\n * options are supplied, the context will default to enabling peer verification\n * only.\n *\n * nodejs only.\n * @category TLS\n */\nclass ClientTlsContext extends TlsContext {\n    constructor(ctx_opt) {\n        if (!ctx_opt) {\n            ctx_opt = new TlsContextOptions();\n            ctx_opt.verify_peer = true;\n        }\n        super(ctx_opt);\n    }\n}\nexports.ClientTlsContext = ClientTlsContext;\n/**\n * TLS context used for server TLS communications over sockets. If no\n * options are supplied, the context will default to disabling peer verification\n * only.\n *\n * nodejs only.\n * @category TLS\n */\nclass ServerTlsContext extends TlsContext {\n    constructor(ctx_opt) {\n        if (!ctx_opt) {\n            ctx_opt = new TlsContextOptions();\n            ctx_opt.verify_peer = false;\n        }\n        super(ctx_opt);\n    }\n}\nexports.ServerTlsContext = ServerTlsContext;\n/**\n * TLS options that are unique to a given connection using a shared TlsContext.\n *\n * nodejs only.\n * @category TLS\n */\nclass TlsConnectionOptions extends native_resource_1.NativeResource {\n    constructor(tls_ctx, server_name, alpn_list = []) {\n        if (tls_ctx == null || tls_ctx == undefined) {\n            throw new error_1.CrtError(\"TlsConnectionOptions constructor: tls_ctx not defined\");\n        }\n        super(binding_1.default.io_tls_connection_options_new(tls_ctx.native_handle(), server_name, (alpn_list && alpn_list.length > 0) ? alpn_list.join(';') : undefined));\n        this.tls_ctx = tls_ctx;\n        this.server_name = server_name;\n        this.alpn_list = alpn_list;\n    }\n}\nexports.TlsConnectionOptions = TlsConnectionOptions;\n/**\n * Handle to a loaded PKCS#11 library.\n *\n * For most use cases, a single instance of Pkcs11Lib should be used\n * for the lifetime of your application.\n *\n * nodejs only.\n * @category TLS\n */\nclass Pkcs11Lib extends native_resource_1.NativeResource {\n    /**\n     * @param path - Path to PKCS#11 library.\n     * @param behavior - Specifies how `C_Initialize()` and `C_Finalize()`\n     *                   will be called on the PKCS#11 library.\n     */\n    constructor(path, behavior = Pkcs11Lib.InitializeFinalizeBehavior.DEFAULT) {\n        super(binding_1.default.io_pkcs11_lib_new(path, behavior));\n    }\n    /**\n     * Release the PKCS#11 library immediately, without waiting for the GC.\n     */\n    close() {\n        binding_1.default.io_pkcs11_lib_close(this.native_handle());\n    }\n}\nexports.Pkcs11Lib = Pkcs11Lib;\n(function (Pkcs11Lib) {\n    /**\n     * Controls `C_Initialize()` and `C_Finalize()` are called on the PKCS#11 library.\n     */\n    let InitializeFinalizeBehavior;\n    (function (InitializeFinalizeBehavior) {\n        /**\n         * Default behavior that accommodates most use cases.\n         *\n         * `C_Initialize()` is called on creation, and \"already-initialized\"\n         * errors are ignored. `C_Finalize()` is never called, just in case\n         * another part of your application is still using the PKCS#11 library.\n         */\n        InitializeFinalizeBehavior[InitializeFinalizeBehavior[\"DEFAULT\"] = 0] = \"DEFAULT\";\n        /**\n         * Skip calling `C_Initialize()` and `C_Finalize()`.\n         *\n         * Use this if your application has already initialized the PKCS#11 library,\n         * and you do not want `C_Initialize()` called again.\n         */\n        InitializeFinalizeBehavior[InitializeFinalizeBehavior[\"OMIT\"] = 1] = \"OMIT\";\n        /**\n         * `C_Initialize()` is called on creation and `C_Finalize()` is called on cleanup.\n         *\n         * If `C_Initialize()` reports that's it's already initialized, this is\n         * treated as an error. Use this if you need perfect cleanup (ex: running\n         * valgrind with --leak-check).\n         */\n        InitializeFinalizeBehavior[InitializeFinalizeBehavior[\"STRICT\"] = 2] = \"STRICT\";\n    })(InitializeFinalizeBehavior = Pkcs11Lib.InitializeFinalizeBehavior || (Pkcs11Lib.InitializeFinalizeBehavior = {}));\n})(Pkcs11Lib = exports.Pkcs11Lib || (exports.Pkcs11Lib = {}));\n//# sourceMappingURL=io.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXdzLWNydC9kaXN0L25hdGl2ZS9pby5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCLEdBQUcsNEJBQTRCLEdBQUcsd0JBQXdCLEdBQUcsd0JBQXdCLEdBQUcsa0JBQWtCLEdBQUcseUJBQXlCLEdBQUcscUJBQXFCLEdBQUcsdUJBQXVCLEdBQUcsbUJBQW1CLEdBQUcseUJBQXlCLEdBQUcsc0JBQXNCLEdBQUcsZ0JBQWdCLEdBQUcsMEJBQTBCLEdBQUcsNEJBQTRCLEdBQUcsb0JBQW9CLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCO0FBQ3BhO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxtQkFBTyxDQUFDLHNFQUFXO0FBQ3JELDBCQUEwQixtQkFBTyxDQUFDLHNGQUFtQjtBQUNyRCxhQUFhLG1CQUFPLENBQUMsb0VBQWM7QUFDbkMsV0FBVyxtQkFBTyxDQUFDLG9FQUFjO0FBQ2pDLDhDQUE2QyxFQUFFLHFDQUFxQywyQkFBMkIsRUFBQztBQUNoSCw4Q0FBNkMsRUFBRSxxQ0FBcUMsMkJBQTJCLEVBQUM7QUFDaEgsZ0RBQStDLEVBQUUscUNBQXFDLDZCQUE2QixFQUFDO0FBQ3BILGdCQUFnQixtQkFBTyxDQUFDLGtFQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQscUJBQXFCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQ0FBa0MsZ0JBQWdCLEtBQUs7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLDJCQUEyQix3QkFBd0IsSUFBSSx1QkFBdUI7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrTkFBK047QUFDL047QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJKQUEySjtBQUMzSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLGlIQUFpSDtBQUN0SCxDQUFDLG9DQUFvQyxpQkFBaUIsS0FBSztBQUMzRCIsInNvdXJjZXMiOlsid2VicGFjazovL3BheXdpbmQvLi9ub2RlX21vZHVsZXMvYXdzLWNydC9kaXN0L25hdGl2ZS9pby5qcz80YTI1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjAuXG4gKi9cbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUGtjczExTGliID0gZXhwb3J0cy5UbHNDb25uZWN0aW9uT3B0aW9ucyA9IGV4cG9ydHMuU2VydmVyVGxzQ29udGV4dCA9IGV4cG9ydHMuQ2xpZW50VGxzQ29udGV4dCA9IGV4cG9ydHMuVGxzQ29udGV4dCA9IGV4cG9ydHMuVGxzQ29udGV4dE9wdGlvbnMgPSBleHBvcnRzLlNvY2tldE9wdGlvbnMgPSBleHBvcnRzLkNsaWVudEJvb3RzdHJhcCA9IGV4cG9ydHMuSW5wdXRTdHJlYW0gPSBleHBvcnRzLmlzX2FscG5fYXZhaWxhYmxlID0gZXhwb3J0cy5lbmFibGVfbG9nZ2luZyA9IGV4cG9ydHMuTG9nTGV2ZWwgPSBleHBvcnRzLmVycm9yX2NvZGVfdG9fbmFtZSA9IGV4cG9ydHMuZXJyb3JfY29kZV90b19zdHJpbmcgPSBleHBvcnRzLlNvY2tldERvbWFpbiA9IGV4cG9ydHMuU29ja2V0VHlwZSA9IGV4cG9ydHMuVGxzVmVyc2lvbiA9IHZvaWQgMDtcbi8qKlxuICpcbiAqIEEgbW9kdWxlIGNvbnRhaW5pbmcgYSBncmFiIGJhZyBvZiBzdXBwb3J0IGZvciBjb3JlIG5ldHdvcmsgSS9PIGZ1bmN0aW9uYWxpdHksIGluY2x1ZGluZyBzb2NrZXRzLCBUTFMsIEROUywgbG9nZ2luZyxcbiAqIGVycm9yIGhhbmRsaW5nLCBzdHJlYW1zLCBhbmQgY29ubmVjdGlvbiAtPiB0aHJlYWQgbWFwcGluZy5cbiAqXG4gKiBDYXRlZ29yaWVzIGluY2x1ZGU6XG4gKiAtIE5ldHdvcms6IHNvY2tldCBjb25maWd1cmF0aW9uXG4gKiAtIFRMUzogdGxzIGNvbmZpZ3VyYXRpb25cbiAqIC0gTG9nZ2luZzogbG9nZ2luZyBjb250cm9scyBhbmQgY29uZmlndXJhdGlvblxuICogLSBJTzogZXZlcnl0aGluZyBlbHNlXG4gKlxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKiBAbW9kdWxlIGlvXG4gKiBAbWVyZ2VUYXJnZXRcbiAqL1xuY29uc3QgYmluZGluZ18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2JpbmRpbmdcIikpO1xuY29uc3QgbmF0aXZlX3Jlc291cmNlXzEgPSByZXF1aXJlKFwiLi9uYXRpdmVfcmVzb3VyY2VcIik7XG5jb25zdCBpb18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9pb1wiKTtcbnZhciBpb18yID0gcmVxdWlyZShcIi4uL2NvbW1vbi9pb1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRsc1ZlcnNpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlvXzIuVGxzVmVyc2lvbjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNvY2tldFR5cGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlvXzIuU29ja2V0VHlwZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNvY2tldERvbWFpblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW9fMi5Tb2NrZXREb21haW47IH0gfSk7XG5jb25zdCBlcnJvcl8xID0gcmVxdWlyZShcIi4vZXJyb3JcIik7XG4vKipcbiAqIENvbnZlcnQgYSBuYXRpdmUgZXJyb3IgY29kZSBpbnRvIGEgaHVtYW4tcmVhZGFibGUgc3RyaW5nXG4gKiBAcGFyYW0gZXJyb3JfY29kZSAtIEFuIGVycm9yIGNvZGUgcmV0dXJuZWQgZnJvbSBhIG5hdGl2ZSBBUEkgY2FsbCwgb3IgZGVsaXZlcmVkXG4gKiB2aWEgY2FsbGJhY2suXG4gKiBAcmV0dXJucyBMb25nLWZvcm0gZGVzY3JpcHRpb24gb2YgdGhlIGVycm9yXG4gKiBAc2VlIENydEVycm9yXG4gKlxuICogbm9kZWpzIG9ubHkuXG4gKlxuICogQGNhdGVnb3J5IFN5c3RlbVxuICovXG5mdW5jdGlvbiBlcnJvcl9jb2RlX3RvX3N0cmluZyhlcnJvcl9jb2RlKSB7XG4gICAgcmV0dXJuIGJpbmRpbmdfMS5kZWZhdWx0LmVycm9yX2NvZGVfdG9fc3RyaW5nKGVycm9yX2NvZGUpO1xufVxuZXhwb3J0cy5lcnJvcl9jb2RlX3RvX3N0cmluZyA9IGVycm9yX2NvZGVfdG9fc3RyaW5nO1xuLyoqXG4gKiBDb252ZXJ0IGEgbmF0aXZlIGVycm9yIGNvZGUgaW50byBhIGh1bWFuLXJlYWRhYmxlIGlkZW50aWZpZXJcbiAqIEBwYXJhbSBlcnJvcl9jb2RlIC0gQW4gZXJyb3IgY29kZSByZXR1cm5lZCBmcm9tIGEgbmF0aXZlIEFQSSBjYWxsLCBvciBkZWxpdmVyZWRcbiAqIHZpYSBjYWxsYmFjay5cbiAqIEByZXR1cm4gZXJyb3IgbmFtZSBhcyBhIHN0cmluZ1xuICogQHNlZSBDcnRFcnJvclxuICpcbiAqIG5vZGVqcyBvbmx5LlxuICpcbiAqIEBjYXRlZ29yeSBTeXN0ZW1cbiAqL1xuZnVuY3Rpb24gZXJyb3JfY29kZV90b19uYW1lKGVycm9yX2NvZGUpIHtcbiAgICByZXR1cm4gYmluZGluZ18xLmRlZmF1bHQuZXJyb3JfY29kZV90b19uYW1lKGVycm9yX2NvZGUpO1xufVxuZXhwb3J0cy5lcnJvcl9jb2RlX3RvX25hbWUgPSBlcnJvcl9jb2RlX3RvX25hbWU7XG4vKipcbiAqIFRoZSBhbW91bnQgb2YgZGV0YWlsIHRoYXQgd2lsbCBiZSBsb2dnZWRcbiAqIEBjYXRlZ29yeSBMb2dnaW5nXG4gKi9cbnZhciBMb2dMZXZlbDtcbihmdW5jdGlvbiAoTG9nTGV2ZWwpIHtcbiAgICAvKiogTm8gbG9nZ2luZyB3aGF0c29ldmVyLiBFcXVpdmFsZW50IHRvIG5ldmVyIGNhbGxpbmcge0BsaW5rIGVuYWJsZV9sb2dnaW5nfS4gKi9cbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIk5PTkVcIl0gPSAwXSA9IFwiTk9ORVwiO1xuICAgIC8qKiBPbmx5IGZhdGFscy4gSW4gcHJhY3RpY2UsIHRoaXMgd2lsbCBub3QgZG8gbXVjaCwgYXMgdGhlIHByb2Nlc3Mgd2lsbCBsb2cgYW5kIHRoZW4gY3Jhc2ggKGludGVudGlvbmFsbHkpIGlmIGEgZmF0YWwgY29uZGl0aW9uIG9jY3VycyAqL1xuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiRkFUQUxcIl0gPSAxXSA9IFwiRkFUQUxcIjtcbiAgICAvKiogT25seSBlcnJvcnMgKi9cbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIkVSUk9SXCJdID0gMl0gPSBcIkVSUk9SXCI7XG4gICAgLyoqIE9ubHkgd2FybmluZ3MgYW5kIGVycm9ycyAqL1xuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiV0FSTlwiXSA9IDNdID0gXCJXQVJOXCI7XG4gICAgLyoqIEluZm9ybWF0aW9uIGFib3V0IGNvbm5lY3Rpb24vc3RyZWFtIGNyZWF0aW9uL2Rlc3RydWN0aW9uIGV2ZW50cyAqL1xuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiSU5GT1wiXSA9IDRdID0gXCJJTkZPXCI7XG4gICAgLyoqIEVub3VnaCBpbmZvcm1hdGlvbiB0byBkZWJ1ZyB0aGUgY2hhaW4gb2YgZXZlbnRzIGEgZ2l2ZW4gbmV0d29yayBjb25uZWN0aW9uIGVuY291bnRlcnMgKi9cbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIkRFQlVHXCJdID0gNV0gPSBcIkRFQlVHXCI7XG4gICAgLyoqIEV2ZXJ5dGhpbmcuIE9ubHkgdXNlIHRoaXMgaWYgeW91IHJlYWxseSBuZWVkIHRvIGtub3cgRVZFUlkgc2luZ2xlIGNhbGwgKi9cbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIlRSQUNFXCJdID0gNl0gPSBcIlRSQUNFXCI7XG59KShMb2dMZXZlbCA9IGV4cG9ydHMuTG9nTGV2ZWwgfHwgKGV4cG9ydHMuTG9nTGV2ZWwgPSB7fSkpO1xuLyoqXG4gKiBFbmFibGVzIGxvZ2dpbmcgb2YgdGhlIG5hdGl2ZSBBV1MgQ1JUIGxpYnJhcmllcy5cbiAqIEBwYXJhbSBsZXZlbCAtIFRoZSBsb2dnaW5nIGxldmVsIHRvIGZpbHRlciB0by4gSXQgaXMgbm90IHBvc3NpYmxlIHRvIGxvZyBsZXNzIHRoYW4gV0FSTi5cbiAqXG4gKiBub2RlanMgb25seS5cbiAqIEBjYXRlZ29yeSBMb2dnaW5nXG4gKi9cbmZ1bmN0aW9uIGVuYWJsZV9sb2dnaW5nKGxldmVsKSB7XG4gICAgYmluZGluZ18xLmRlZmF1bHQuaW9fbG9nZ2luZ19lbmFibGUobGV2ZWwpO1xufVxuZXhwb3J0cy5lbmFibGVfbG9nZ2luZyA9IGVuYWJsZV9sb2dnaW5nO1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgQUxQTiBpcyBhdmFpbGFibGUgb24gdGhpcyBwbGF0Zm9ybSBuYXRpdmVseVxuICogQHJldHVybiB0cnVlIGlmIEFMUE4gaXMgc3VwcG9ydGVkIG5hdGl2ZWx5LCBmYWxzZSBvdGhlcndpc2VcbiAqXG4gKiBub2RlanMgb25seS5cbiAqIEBjYXRlZ29yeSBUTFNcbiovXG5mdW5jdGlvbiBpc19hbHBuX2F2YWlsYWJsZSgpIHtcbiAgICByZXR1cm4gYmluZGluZ18xLmRlZmF1bHQuaXNfYWxwbl9hdmFpbGFibGUoKTtcbn1cbmV4cG9ydHMuaXNfYWxwbl9hdmFpbGFibGUgPSBpc19hbHBuX2F2YWlsYWJsZTtcbi8qKlxuICogV3JhcHMgYSBgYGBSZWFkYWJsZWBgYCBmb3IgcmVhZGluZyBieSBuYXRpdmUgY29kZSwgdXNlZCB0byBzdHJlYW1cbiAqICBkYXRhIGludG8gdGhlIEFXUyBDUlQgbGlicmFyaWVzLlxuICpcbiAqIG5vZGVqcyBvbmx5LlxuICogQGNhdGVnb3J5IElPXG4gKi9cbmNsYXNzIElucHV0U3RyZWFtIGV4dGVuZHMgbmF0aXZlX3Jlc291cmNlXzEuTmF0aXZlUmVzb3VyY2Uge1xuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSkge1xuICAgICAgICBzdXBlcihiaW5kaW5nXzEuZGVmYXVsdC5pb19pbnB1dF9zdHJlYW1fbmV3KDE2ICogMTAyNCkpO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5zb3VyY2Uub24oJ2RhdGEnLCAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgZGF0YSA9IEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSA/IGRhdGEgOiBCdWZmZXIuZnJvbShkYXRhLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgYmluZGluZ18xLmRlZmF1bHQuaW9faW5wdXRfc3RyZWFtX2FwcGVuZCh0aGlzLm5hdGl2ZV9oYW5kbGUoKSwgZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNvdXJjZS5vbignZW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgYmluZGluZ18xLmRlZmF1bHQuaW9faW5wdXRfc3RyZWFtX2FwcGVuZCh0aGlzLm5hdGl2ZV9oYW5kbGUoKSwgdW5kZWZpbmVkKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5JbnB1dFN0cmVhbSA9IElucHV0U3RyZWFtO1xuLyoqXG4gKiBSZXByZXNlbnRzIG5hdGl2ZSByZXNvdXJjZXMgcmVxdWlyZWQgdG8gYm9vdHN0cmFwIGEgY2xpZW50IGNvbm5lY3Rpb25cbiAqIFRoaW5ncyBsaWtlIGEgaG9zdCByZXNvbHZlciwgZXZlbnQgbG9vcCBncm91cCwgZXRjLiBUaGVyZSBzaG91bGQgb25seSBuZWVkXG4gKiB0byBiZSAxIG9mIHRoZXNlIHBlciBhcHBsaWNhdGlvbiwgaW4gbW9zdCBjYXNlcy5cbiAqXG4gKiBub2RlanMgb25seS5cbiAqIEBjYXRlZ29yeSBJT1xuICovXG5jbGFzcyBDbGllbnRCb290c3RyYXAgZXh0ZW5kcyBuYXRpdmVfcmVzb3VyY2VfMS5OYXRpdmVSZXNvdXJjZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKGJpbmRpbmdfMS5kZWZhdWx0LmlvX2NsaWVudF9ib290c3RyYXBfbmV3KCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2xpZW50Qm9vdHN0cmFwID0gQ2xpZW50Qm9vdHN0cmFwO1xuLyoqXG4gKiBTdGFuZGFyZCBCZXJrZWxleSBzb2NrZXQgc3R5bGUgb3B0aW9ucy5cbiAqXG4gKiBub2RlanMgb25seS5cbiAqIEBjYXRlZ29yeSBOZXR3b3JrXG4qL1xuY2xhc3MgU29ja2V0T3B0aW9ucyBleHRlbmRzIG5hdGl2ZV9yZXNvdXJjZV8xLk5hdGl2ZVJlc291cmNlIHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlID0gaW9fMS5Tb2NrZXRUeXBlLlNUUkVBTSwgZG9tYWluID0gaW9fMS5Tb2NrZXREb21haW4uSVBWNiwgY29ubmVjdF90aW1lb3V0X21zID0gNTAwMCwga2VlcGFsaXZlID0gZmFsc2UsIGtlZXBfYWxpdmVfaW50ZXJ2YWxfc2VjID0gMCwga2VlcF9hbGl2ZV90aW1lb3V0X3NlYyA9IDAsIGtlZXBfYWxpdmVfbWF4X2ZhaWxlZF9wcm9iZXMgPSAwKSB7XG4gICAgICAgIHN1cGVyKGJpbmRpbmdfMS5kZWZhdWx0LmlvX3NvY2tldF9vcHRpb25zX25ldyh0eXBlLCBkb21haW4sIGNvbm5lY3RfdGltZW91dF9tcywga2VlcF9hbGl2ZV9pbnRlcnZhbF9zZWMsIGtlZXBfYWxpdmVfdGltZW91dF9zZWMsIGtlZXBfYWxpdmVfbWF4X2ZhaWxlZF9wcm9iZXMsIGtlZXBhbGl2ZSkpO1xuICAgIH1cbn1cbmV4cG9ydHMuU29ja2V0T3B0aW9ucyA9IFNvY2tldE9wdGlvbnM7XG4vKipcbiAqIE9wdGlvbnMgZm9yIGNyZWF0aW5nIGEge0BsaW5rIENsaWVudFRsc0NvbnRleHR9IG9yIHtAbGluayBTZXJ2ZXJUbHNDb250ZXh0fS5cbiAqXG4gKiBub2RlanMgb25seS5cbiAqIEBjYXRlZ29yeSBUTFNcbiAqL1xuY2xhc3MgVGxzQ29udGV4dE9wdGlvbnMge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvKiogTWluaW11bSB2ZXJzaW9uIG9mIFRMUyB0byBzdXBwb3J0LiBVc2VzIE9TL3N5c3RlbSBkZWZhdWx0IGlmIHVuc3BlY2lmaWVkLiAqL1xuICAgICAgICB0aGlzLm1pbl90bHNfdmVyc2lvbiA9IGlvXzEuVGxzVmVyc2lvbi5EZWZhdWx0O1xuICAgICAgICAvKiogTGlzdCBvZiBBTFBOIHByb3RvY29scyB0byBiZSB1c2VkIG9uIHBsYXRmb3JtcyB3aGljaCBzdXBwb3J0IEFMUE4gKi9cbiAgICAgICAgdGhpcy5hbHBuX2xpc3QgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluIGNsaWVudCBtb2RlLCB0aGlzIHR1cm5zIG9mZiB4LjUwOSB2YWxpZGF0aW9uLiBEb24ndCBkbyB0aGlzIHVubGVzcyB5b3UgYXJlIHRlc3RpbmcuXG4gICAgICAgICAqIEl0IGlzIG11Y2ggYmV0dGVyIHRvIGp1c3Qgb3ZlcnJpZGUgdGhlIGRlZmF1bHQgdHJ1c3Qgc3RvcmUgYW5kIHBhc3MgdGhlIHNlbGYtc2lnbmVkXG4gICAgICAgICAqIGNlcnRpZmljYXRlIGFzIHRoZSBjYV9maWxlIGFyZ3VtZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBJbiBzZXJ2ZXIgbW9kZSAoU2VydmVyVGxzQ29udGV4dCksIHRoaXMgZGVmYXVsdHMgdG8gZmFsc2UuIElmIHlvdSB3YW50IHRvIGVuZm9yY2UgbXV0dWFsIFRMUyBvbiB0aGUgc2VydmVyLFxuICAgICAgICAgKiBzZXQgdGhpcyB0byB0cnVlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52ZXJpZnlfcGVlciA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyB0aGUgZGVmYXVsdCBzeXN0ZW0gdHJ1c3Qgc3RvcmUuXG4gICAgICogQHBhcmFtIGNhX2RpcnBhdGggLSBPbmx5IHVzZWQgb24gVW5peC1zdHlsZSBzeXN0ZW1zIHdoZXJlIGFsbCB0cnVzdCBhbmNob3JzIGFyZVxuICAgICAqIHN0b3JlZCBpbiBhIGRpcmVjdG9yeSAoZS5nLiAvZXRjL3NzbC9jZXJ0cykuXG4gICAgICogQHBhcmFtIGNhX2ZpbGVwYXRoIC0gU2luZ2xlIGZpbGUgY29udGFpbmluZyBhbGwgdHJ1c3QgQ0FzLCBpbiBQRU0gZm9ybWF0XG4gICAgICovXG4gICAgb3ZlcnJpZGVfZGVmYXVsdF90cnVzdF9zdG9yZV9mcm9tX3BhdGgoY2FfZGlycGF0aCwgY2FfZmlsZXBhdGgpIHtcbiAgICAgICAgdGhpcy5jYV9kaXJwYXRoID0gY2FfZGlycGF0aDtcbiAgICAgICAgdGhpcy5jYV9maWxlcGF0aCA9IGNhX2ZpbGVwYXRoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgdGhlIGRlZmF1bHQgc3lzdGVtIHRydXN0IHN0b3JlLlxuICAgICAqIEBwYXJhbSBjZXJ0aWZpY2F0ZV9hdXRob3JpdHkgLSBTdHJpbmcgY29udGFpbmluZyBhbGwgdHJ1c3QgQ0FzLCBpbiBQRU0gZm9ybWF0XG4gICAgICovXG4gICAgb3ZlcnJpZGVfZGVmYXVsdF90cnVzdF9zdG9yZShjZXJ0aWZpY2F0ZV9hdXRob3JpdHkpIHtcbiAgICAgICAgdGhpcy5jZXJ0aWZpY2F0ZV9hdXRob3JpdHkgPSBjZXJ0aWZpY2F0ZV9hdXRob3JpdHk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBvcHRpb25zIGNvbmZpZ3VyZWQgZm9yIG11dHVhbCBUTFMgaW4gY2xpZW50IG1vZGUsXG4gICAgICogd2l0aCBjbGllbnQgY2VydGlmaWNhdGUgYW5kIHByaXZhdGUga2V5IHByb3ZpZGVkIGFzIGluLW1lbW9yeSBzdHJpbmdzLlxuICAgICAqIEBwYXJhbSBjZXJ0aWZpY2F0ZSAtIENsaWVudCBjZXJ0aWZpY2F0ZSBmaWxlIGNvbnRlbnRzLCBpbiBQRU0gZm9ybWF0XG4gICAgICogQHBhcmFtIHByaXZhdGVfa2V5IC0gQ2xpZW50IHByaXZhdGUga2V5IGZpbGUgY29udGVudHMsIGluIFBFTSBmb3JtYXRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIG5ld2x5IGNvbmZpZ3VyZWQgVGxzQ29udGV4dE9wdGlvbnMgb2JqZWN0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZV9jbGllbnRfd2l0aF9tdGxzKGNlcnRpZmljYXRlLCBwcml2YXRlX2tleSkge1xuICAgICAgICBsZXQgb3B0ID0gbmV3IFRsc0NvbnRleHRPcHRpb25zKCk7XG4gICAgICAgIG9wdC5jZXJ0aWZpY2F0ZSA9IGNlcnRpZmljYXRlO1xuICAgICAgICBvcHQucHJpdmF0ZV9rZXkgPSBwcml2YXRlX2tleTtcbiAgICAgICAgb3B0LnZlcmlmeV9wZWVyID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG9wdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIG9wdGlvbnMgY29uZmlndXJlZCBmb3IgbXV0dWFsIFRMUyBpbiBjbGllbnQgbW9kZSxcbiAgICAgKiB3aXRoIGNsaWVudCBjZXJ0aWZpY2F0ZSBhbmQgcHJpdmF0ZSBrZXkgcHJvdmlkZWQgdmlhIGZpbGVwYXRoLlxuICAgICAqIEBwYXJhbSBjZXJ0aWZpY2F0ZV9maWxlcGF0aCAtIFBhdGggdG8gY2xpZW50IGNlcnRpZmljYXRlLCBpbiBQRU0gZm9ybWF0XG4gICAgICogQHBhcmFtIHByaXZhdGVfa2V5X2ZpbGVwYXRoIC0gUGF0aCB0byBwcml2YXRlIGtleSwgaW4gUEVNIGZvcm1hdFxuICAgICAqXG4gICAgICogQHJldHVybnMgbmV3bHkgY29uZmlndXJlZCBUbHNDb250ZXh0T3B0aW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlX2NsaWVudF93aXRoX210bHNfZnJvbV9wYXRoKGNlcnRpZmljYXRlX2ZpbGVwYXRoLCBwcml2YXRlX2tleV9maWxlcGF0aCkge1xuICAgICAgICBsZXQgb3B0ID0gbmV3IFRsc0NvbnRleHRPcHRpb25zKCk7XG4gICAgICAgIG9wdC5jZXJ0aWZpY2F0ZV9maWxlcGF0aCA9IGNlcnRpZmljYXRlX2ZpbGVwYXRoO1xuICAgICAgICBvcHQucHJpdmF0ZV9rZXlfZmlsZXBhdGggPSBwcml2YXRlX2tleV9maWxlcGF0aDtcbiAgICAgICAgb3B0LnZlcmlmeV9wZWVyID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG9wdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIG9wdGlvbnMgZm9yIG11dHVhbCBUTFMgaW4gY2xpZW50IG1vZGUsXG4gICAgICogd2l0aCBjbGllbnQgY2VydGlmaWNhdGUgYW5kIHByaXZhdGUga2V5IGJ1bmRsZWQgaW4gYSBzaW5nbGUgUEtDUyMxMiBmaWxlLlxuICAgICAqIEBwYXJhbSBwa2NzMTJfZmlsZXBhdGggLSBQYXRoIHRvIFBLQ1MjMTIgZmlsZSBjb250YWluaW5nIGNsaWVudCBjZXJ0aWZpY2F0ZSBhbmQgcHJpdmF0ZSBrZXkuXG4gICAgICogQHBhcmFtIHBrY3MxMl9wYXNzd29yZCAtIFBLQ1MjMTIgcGFzc3dvcmRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIG5ld2x5IGNvbmZpZ3VyZWQgVGxzQ29udGV4dE9wdGlvbnMgb2JqZWN0XG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlX2NsaWVudF93aXRoX210bHNfcGtjczEyX2Zyb21fcGF0aChwa2NzMTJfZmlsZXBhdGgsIHBrY3MxMl9wYXNzd29yZCkge1xuICAgICAgICBsZXQgb3B0ID0gbmV3IFRsc0NvbnRleHRPcHRpb25zKCk7XG4gICAgICAgIG9wdC5wa2NzMTJfZmlsZXBhdGggPSBwa2NzMTJfZmlsZXBhdGg7XG4gICAgICAgIG9wdC5wa2NzMTJfcGFzc3dvcmQgPSBwa2NzMTJfcGFzc3dvcmQ7XG4gICAgICAgIG9wdC52ZXJpZnlfcGVlciA9IHRydWU7XG4gICAgICAgIHJldHVybiBvcHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIFJlbmFtZWQgW1tjcmVhdGVfY2xpZW50X3dpdGhfbXRsc19wa2NzMTJfZnJvbV9wYXRoXV1cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlX2NsaWVudF93aXRoX210bHNfcGtjc19mcm9tX3BhdGgocGtjczEyX2ZpbGVwYXRoLCBwa2NzMTJfcGFzc3dvcmQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlX2NsaWVudF93aXRoX210bHNfcGtjczEyX2Zyb21fcGF0aChwa2NzMTJfZmlsZXBhdGgsIHBrY3MxMl9wYXNzd29yZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBvcHRpb25zIGNvbmZpZ3VyZWQgZm9yIG11dHVhbCBUTFMgaW4gY2xpZW50IG1vZGUsXG4gICAgICogdXNpbmcgYSBQS0NTIzExIGxpYnJhcnkgZm9yIHByaXZhdGUga2V5IG9wZXJhdGlvbnMuXG4gICAgICpcbiAgICAgKiBOT1RFOiBUaGlzIGNvbmZpZ3VyYXRpb24gb25seSB3b3JrcyBvbiBVbml4IGRldmljZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFBLQ1MjMTEgb3B0aW9uc1xuICAgICAqXG4gICAgICogQHJldHVybnMgbmV3bHkgY29uZmlndXJlZCBUbHNDb250ZXh0T3B0aW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlX2NsaWVudF93aXRoX210bHNfcGtjczExKG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IG9wdCA9IG5ldyBUbHNDb250ZXh0T3B0aW9ucygpO1xuICAgICAgICBvcHQucGtjczExX29wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICBvcHQudmVyaWZ5X3BlZXIgPSB0cnVlO1xuICAgICAgICByZXR1cm4gb3B0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgb3B0aW9ucyBjb25maWd1cmVkIGZvciBtdXR1YWwgVExTIGluIGNsaWVudCBtb2RlLFxuICAgICAqIHVzaW5nIGEgY2VydGlmaWNhdGUgaW4gYSBXaW5kb3dzIGNlcnRpZmljYXRlIHN0b3JlLlxuICAgICAqXG4gICAgICogTk9URTogV2luZG93cyBvbmx5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNlcnRpZmljYXRlX3BhdGggLSBQYXRoIHRvIGNlcnRpZmljYXRlIGluIGEgV2luZG93cyBjZXJ0aWZpY2F0ZSBzdG9yZS5cbiAgICAgKiAgICAgIFRoZSBwYXRoIG11c3QgdXNlIGJhY2tzbGFzaGVzIGFuZCBlbmQgd2l0aCB0aGUgY2VydGlmaWNhdGUncyB0aHVtYnByaW50LlxuICAgICAqICAgICAgRXhhbXBsZTogYEN1cnJlbnRVc2VyXFxNWVxcQTExRjhBOUI1REY1Qjk4QkEzNTA4RkJDQTU3NUQwOTU3MEUwRDJDNmBcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlX2NsaWVudF93aXRoX210bHNfd2luZG93c19jZXJ0X3N0b3JlX3BhdGgoY2VydGlmaWNhdGVfcGF0aCkge1xuICAgICAgICBsZXQgb3B0ID0gbmV3IFRsc0NvbnRleHRPcHRpb25zKCk7XG4gICAgICAgIG9wdC53aW5kb3dzX2NlcnRfc3RvcmVfcGF0aCA9IGNlcnRpZmljYXRlX3BhdGg7XG4gICAgICAgIG9wdC52ZXJpZnlfcGVlciA9IHRydWU7XG4gICAgICAgIHJldHVybiBvcHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgVExTIGNvbnRleHQgd2l0aCBwZWVyIHZlcmlmaWNhdGlvbiBkaXNhYmxlZCwgYWxvbmcgd2l0aCBhIGNlcnRpZmljYXRlIGFuZCBwcml2YXRlIGtleVxuICAgICAqIEBwYXJhbSBjZXJ0aWZpY2F0ZV9maWxlcGF0aCAtIFBhdGggdG8gY2VydGlmaWNhdGUsIGluIFBFTSBmb3JtYXRcbiAgICAgKiBAcGFyYW0gcHJpdmF0ZV9rZXlfZmlsZXBhdGggLSBQYXRoIHRvIHByaXZhdGUga2V5LCBpbiBQRU0gZm9ybWF0XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBuZXdseSBjb25maWd1cmVkIFRsc0NvbnRleHRPcHRpb25zIG9iamVjdFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVfc2VydmVyX3dpdGhfbXRsc19mcm9tX3BhdGgoY2VydGlmaWNhdGVfZmlsZXBhdGgsIHByaXZhdGVfa2V5X2ZpbGVwYXRoKSB7XG4gICAgICAgIGxldCBvcHQgPSBuZXcgVGxzQ29udGV4dE9wdGlvbnMoKTtcbiAgICAgICAgb3B0LmNlcnRpZmljYXRlX2ZpbGVwYXRoID0gY2VydGlmaWNhdGVfZmlsZXBhdGg7XG4gICAgICAgIG9wdC5wcml2YXRlX2tleV9maWxlcGF0aCA9IHByaXZhdGVfa2V5X2ZpbGVwYXRoO1xuICAgICAgICBvcHQudmVyaWZ5X3BlZXIgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIG9wdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBUTFMgY29udGV4dCB3aXRoIHBlZXIgdmVyaWZpY2F0aW9uIGRpc2FibGVkLCBhbG9uZyB3aXRoIGEgY2VydGlmaWNhdGUgYW5kIHByaXZhdGUga2V5XG4gICAgICogaW4gUEtDUyMxMiBmb3JtYXRcbiAgICAgKiBAcGFyYW0gcGtjczEyX2ZpbGVwYXRoIC0gUGF0aCB0byBjZXJ0aWZpY2F0ZSwgaW4gUEtDUyMxMiBmb3JtYXRcbiAgICAgKiBAcGFyYW0gcGtjczEyX3Bhc3N3b3JkIC0gUEtDUyMxMiBQYXNzd29yZFxuICAgICAqXG4gICAgICogQHJldHVybnMgbmV3bHkgY29uZmlndXJlZCBUbHNDb250ZXh0T3B0aW9ucyBvYmplY3RcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlX3NlcnZlcl93aXRoX210bHNfcGtjc19mcm9tX3BhdGgocGtjczEyX2ZpbGVwYXRoLCBwa2NzMTJfcGFzc3dvcmQpIHtcbiAgICAgICAgbGV0IG9wdCA9IG5ldyBUbHNDb250ZXh0T3B0aW9ucygpO1xuICAgICAgICBvcHQucGtjczEyX2ZpbGVwYXRoID0gcGtjczEyX2ZpbGVwYXRoO1xuICAgICAgICBvcHQucGtjczEyX3Bhc3N3b3JkID0gcGtjczEyX3Bhc3N3b3JkO1xuICAgICAgICBvcHQudmVyaWZ5X3BlZXIgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIG9wdDtcbiAgICB9XG59XG5leHBvcnRzLlRsc0NvbnRleHRPcHRpb25zID0gVGxzQ29udGV4dE9wdGlvbnM7XG4vKipcbiAqIEFic3RyYWN0IGJhc2UgVExTIGNvbnRleHQgdXNlZCBmb3IgY2xpZW50L3NlcnZlciBUTFMgY29tbXVuaWNhdGlvbnMgb3ZlciBzb2NrZXRzLlxuICpcbiAqIEBzZWUgQ2xpZW50VGxzQ29udGV4dFxuICogQHNlZSBTZXJ2ZXJUbHNDb250ZXh0XG4gKlxuICogbm9kZWpzIG9ubHkuXG4gKiBAY2F0ZWdvcnkgVExTXG4gKi9cbmNsYXNzIFRsc0NvbnRleHQgZXh0ZW5kcyBuYXRpdmVfcmVzb3VyY2VfMS5OYXRpdmVSZXNvdXJjZSB7XG4gICAgY29uc3RydWN0b3IoY3R4X29wdCkge1xuICAgICAgICBpZiAoY3R4X29wdCA9PSBudWxsIHx8IGN0eF9vcHQgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JfMS5DcnRFcnJvcihcIlRsc0NvbnRleHQgY29uc3RydWN0b3I6IGN0eF9vcHQgbm90IGRlZmluZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoYmluZGluZ18xLmRlZmF1bHQuaW9fdGxzX2N0eF9uZXcoY3R4X29wdC5taW5fdGxzX3ZlcnNpb24sIGN0eF9vcHQuY2FfZmlsZXBhdGgsIGN0eF9vcHQuY2FfZGlycGF0aCwgY3R4X29wdC5jZXJ0aWZpY2F0ZV9hdXRob3JpdHksIChjdHhfb3B0LmFscG5fbGlzdCAmJiBjdHhfb3B0LmFscG5fbGlzdC5sZW5ndGggPiAwKSA/IGN0eF9vcHQuYWxwbl9saXN0LmpvaW4oJzsnKSA6IHVuZGVmaW5lZCwgY3R4X29wdC5jZXJ0aWZpY2F0ZV9maWxlcGF0aCwgY3R4X29wdC5jZXJ0aWZpY2F0ZSwgY3R4X29wdC5wcml2YXRlX2tleV9maWxlcGF0aCwgY3R4X29wdC5wcml2YXRlX2tleSwgY3R4X29wdC5wa2NzMTJfZmlsZXBhdGgsIGN0eF9vcHQucGtjczEyX3Bhc3N3b3JkLCBjdHhfb3B0LnBrY3MxMV9vcHRpb25zLCBjdHhfb3B0LndpbmRvd3NfY2VydF9zdG9yZV9wYXRoLCBjdHhfb3B0LnZlcmlmeV9wZWVyKSk7XG4gICAgfVxufVxuZXhwb3J0cy5UbHNDb250ZXh0ID0gVGxzQ29udGV4dDtcbi8qKlxuICogVExTIGNvbnRleHQgdXNlZCBmb3IgY2xpZW50IFRMUyBjb21tdW5pY2F0aW9ucyBvdmVyIHNvY2tldHMuIElmIG5vXG4gKiBvcHRpb25zIGFyZSBzdXBwbGllZCwgdGhlIGNvbnRleHQgd2lsbCBkZWZhdWx0IHRvIGVuYWJsaW5nIHBlZXIgdmVyaWZpY2F0aW9uXG4gKiBvbmx5LlxuICpcbiAqIG5vZGVqcyBvbmx5LlxuICogQGNhdGVnb3J5IFRMU1xuICovXG5jbGFzcyBDbGllbnRUbHNDb250ZXh0IGV4dGVuZHMgVGxzQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IoY3R4X29wdCkge1xuICAgICAgICBpZiAoIWN0eF9vcHQpIHtcbiAgICAgICAgICAgIGN0eF9vcHQgPSBuZXcgVGxzQ29udGV4dE9wdGlvbnMoKTtcbiAgICAgICAgICAgIGN0eF9vcHQudmVyaWZ5X3BlZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKGN0eF9vcHQpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2xpZW50VGxzQ29udGV4dCA9IENsaWVudFRsc0NvbnRleHQ7XG4vKipcbiAqIFRMUyBjb250ZXh0IHVzZWQgZm9yIHNlcnZlciBUTFMgY29tbXVuaWNhdGlvbnMgb3ZlciBzb2NrZXRzLiBJZiBub1xuICogb3B0aW9ucyBhcmUgc3VwcGxpZWQsIHRoZSBjb250ZXh0IHdpbGwgZGVmYXVsdCB0byBkaXNhYmxpbmcgcGVlciB2ZXJpZmljYXRpb25cbiAqIG9ubHkuXG4gKlxuICogbm9kZWpzIG9ubHkuXG4gKiBAY2F0ZWdvcnkgVExTXG4gKi9cbmNsYXNzIFNlcnZlclRsc0NvbnRleHQgZXh0ZW5kcyBUbHNDb250ZXh0IHtcbiAgICBjb25zdHJ1Y3RvcihjdHhfb3B0KSB7XG4gICAgICAgIGlmICghY3R4X29wdCkge1xuICAgICAgICAgICAgY3R4X29wdCA9IG5ldyBUbHNDb250ZXh0T3B0aW9ucygpO1xuICAgICAgICAgICAgY3R4X29wdC52ZXJpZnlfcGVlciA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKGN0eF9vcHQpO1xuICAgIH1cbn1cbmV4cG9ydHMuU2VydmVyVGxzQ29udGV4dCA9IFNlcnZlclRsc0NvbnRleHQ7XG4vKipcbiAqIFRMUyBvcHRpb25zIHRoYXQgYXJlIHVuaXF1ZSB0byBhIGdpdmVuIGNvbm5lY3Rpb24gdXNpbmcgYSBzaGFyZWQgVGxzQ29udGV4dC5cbiAqXG4gKiBub2RlanMgb25seS5cbiAqIEBjYXRlZ29yeSBUTFNcbiAqL1xuY2xhc3MgVGxzQ29ubmVjdGlvbk9wdGlvbnMgZXh0ZW5kcyBuYXRpdmVfcmVzb3VyY2VfMS5OYXRpdmVSZXNvdXJjZSB7XG4gICAgY29uc3RydWN0b3IodGxzX2N0eCwgc2VydmVyX25hbWUsIGFscG5fbGlzdCA9IFtdKSB7XG4gICAgICAgIGlmICh0bHNfY3R4ID09IG51bGwgfHwgdGxzX2N0eCA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcl8xLkNydEVycm9yKFwiVGxzQ29ubmVjdGlvbk9wdGlvbnMgY29uc3RydWN0b3I6IHRsc19jdHggbm90IGRlZmluZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoYmluZGluZ18xLmRlZmF1bHQuaW9fdGxzX2Nvbm5lY3Rpb25fb3B0aW9uc19uZXcodGxzX2N0eC5uYXRpdmVfaGFuZGxlKCksIHNlcnZlcl9uYW1lLCAoYWxwbl9saXN0ICYmIGFscG5fbGlzdC5sZW5ndGggPiAwKSA/IGFscG5fbGlzdC5qb2luKCc7JykgOiB1bmRlZmluZWQpKTtcbiAgICAgICAgdGhpcy50bHNfY3R4ID0gdGxzX2N0eDtcbiAgICAgICAgdGhpcy5zZXJ2ZXJfbmFtZSA9IHNlcnZlcl9uYW1lO1xuICAgICAgICB0aGlzLmFscG5fbGlzdCA9IGFscG5fbGlzdDtcbiAgICB9XG59XG5leHBvcnRzLlRsc0Nvbm5lY3Rpb25PcHRpb25zID0gVGxzQ29ubmVjdGlvbk9wdGlvbnM7XG4vKipcbiAqIEhhbmRsZSB0byBhIGxvYWRlZCBQS0NTIzExIGxpYnJhcnkuXG4gKlxuICogRm9yIG1vc3QgdXNlIGNhc2VzLCBhIHNpbmdsZSBpbnN0YW5jZSBvZiBQa2NzMTFMaWIgc2hvdWxkIGJlIHVzZWRcbiAqIGZvciB0aGUgbGlmZXRpbWUgb2YgeW91ciBhcHBsaWNhdGlvbi5cbiAqXG4gKiBub2RlanMgb25seS5cbiAqIEBjYXRlZ29yeSBUTFNcbiAqL1xuY2xhc3MgUGtjczExTGliIGV4dGVuZHMgbmF0aXZlX3Jlc291cmNlXzEuTmF0aXZlUmVzb3VyY2Uge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBwYXRoIC0gUGF0aCB0byBQS0NTIzExIGxpYnJhcnkuXG4gICAgICogQHBhcmFtIGJlaGF2aW9yIC0gU3BlY2lmaWVzIGhvdyBgQ19Jbml0aWFsaXplKClgIGFuZCBgQ19GaW5hbGl6ZSgpYFxuICAgICAqICAgICAgICAgICAgICAgICAgIHdpbGwgYmUgY2FsbGVkIG9uIHRoZSBQS0NTIzExIGxpYnJhcnkuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocGF0aCwgYmVoYXZpb3IgPSBQa2NzMTFMaWIuSW5pdGlhbGl6ZUZpbmFsaXplQmVoYXZpb3IuREVGQVVMVCkge1xuICAgICAgICBzdXBlcihiaW5kaW5nXzEuZGVmYXVsdC5pb19wa2NzMTFfbGliX25ldyhwYXRoLCBiZWhhdmlvcikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWxlYXNlIHRoZSBQS0NTIzExIGxpYnJhcnkgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBmb3IgdGhlIEdDLlxuICAgICAqL1xuICAgIGNsb3NlKCkge1xuICAgICAgICBiaW5kaW5nXzEuZGVmYXVsdC5pb19wa2NzMTFfbGliX2Nsb3NlKHRoaXMubmF0aXZlX2hhbmRsZSgpKTtcbiAgICB9XG59XG5leHBvcnRzLlBrY3MxMUxpYiA9IFBrY3MxMUxpYjtcbihmdW5jdGlvbiAoUGtjczExTGliKSB7XG4gICAgLyoqXG4gICAgICogQ29udHJvbHMgYENfSW5pdGlhbGl6ZSgpYCBhbmQgYENfRmluYWxpemUoKWAgYXJlIGNhbGxlZCBvbiB0aGUgUEtDUyMxMSBsaWJyYXJ5LlxuICAgICAqL1xuICAgIGxldCBJbml0aWFsaXplRmluYWxpemVCZWhhdmlvcjtcbiAgICAoZnVuY3Rpb24gKEluaXRpYWxpemVGaW5hbGl6ZUJlaGF2aW9yKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZhdWx0IGJlaGF2aW9yIHRoYXQgYWNjb21tb2RhdGVzIG1vc3QgdXNlIGNhc2VzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBgQ19Jbml0aWFsaXplKClgIGlzIGNhbGxlZCBvbiBjcmVhdGlvbiwgYW5kIFwiYWxyZWFkeS1pbml0aWFsaXplZFwiXG4gICAgICAgICAqIGVycm9ycyBhcmUgaWdub3JlZC4gYENfRmluYWxpemUoKWAgaXMgbmV2ZXIgY2FsbGVkLCBqdXN0IGluIGNhc2VcbiAgICAgICAgICogYW5vdGhlciBwYXJ0IG9mIHlvdXIgYXBwbGljYXRpb24gaXMgc3RpbGwgdXNpbmcgdGhlIFBLQ1MjMTEgbGlicmFyeS5cbiAgICAgICAgICovXG4gICAgICAgIEluaXRpYWxpemVGaW5hbGl6ZUJlaGF2aW9yW0luaXRpYWxpemVGaW5hbGl6ZUJlaGF2aW9yW1wiREVGQVVMVFwiXSA9IDBdID0gXCJERUZBVUxUXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTa2lwIGNhbGxpbmcgYENfSW5pdGlhbGl6ZSgpYCBhbmQgYENfRmluYWxpemUoKWAuXG4gICAgICAgICAqXG4gICAgICAgICAqIFVzZSB0aGlzIGlmIHlvdXIgYXBwbGljYXRpb24gaGFzIGFscmVhZHkgaW5pdGlhbGl6ZWQgdGhlIFBLQ1MjMTEgbGlicmFyeSxcbiAgICAgICAgICogYW5kIHlvdSBkbyBub3Qgd2FudCBgQ19Jbml0aWFsaXplKClgIGNhbGxlZCBhZ2Fpbi5cbiAgICAgICAgICovXG4gICAgICAgIEluaXRpYWxpemVGaW5hbGl6ZUJlaGF2aW9yW0luaXRpYWxpemVGaW5hbGl6ZUJlaGF2aW9yW1wiT01JVFwiXSA9IDFdID0gXCJPTUlUXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBgQ19Jbml0aWFsaXplKClgIGlzIGNhbGxlZCBvbiBjcmVhdGlvbiBhbmQgYENfRmluYWxpemUoKWAgaXMgY2FsbGVkIG9uIGNsZWFudXAuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIGBDX0luaXRpYWxpemUoKWAgcmVwb3J0cyB0aGF0J3MgaXQncyBhbHJlYWR5IGluaXRpYWxpemVkLCB0aGlzIGlzXG4gICAgICAgICAqIHRyZWF0ZWQgYXMgYW4gZXJyb3IuIFVzZSB0aGlzIGlmIHlvdSBuZWVkIHBlcmZlY3QgY2xlYW51cCAoZXg6IHJ1bm5pbmdcbiAgICAgICAgICogdmFsZ3JpbmQgd2l0aCAtLWxlYWstY2hlY2spLlxuICAgICAgICAgKi9cbiAgICAgICAgSW5pdGlhbGl6ZUZpbmFsaXplQmVoYXZpb3JbSW5pdGlhbGl6ZUZpbmFsaXplQmVoYXZpb3JbXCJTVFJJQ1RcIl0gPSAyXSA9IFwiU1RSSUNUXCI7XG4gICAgfSkoSW5pdGlhbGl6ZUZpbmFsaXplQmVoYXZpb3IgPSBQa2NzMTFMaWIuSW5pdGlhbGl6ZUZpbmFsaXplQmVoYXZpb3IgfHwgKFBrY3MxMUxpYi5Jbml0aWFsaXplRmluYWxpemVCZWhhdmlvciA9IHt9KSk7XG59KShQa2NzMTFMaWIgPSBleHBvcnRzLlBrY3MxMUxpYiB8fCAoZXhwb3J0cy5Qa2NzMTFMaWIgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW8uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/aws-crt/dist/native/io.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/aws-crt/dist/native/iot.js":
/*!*************************************************!*\
  !*** ./node_modules/aws-crt/dist/native/iot.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n * SPDX-License-Identifier: Apache-2.0.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * Module for AWS IoT MQTT client configuration and connection establishment.\n *\n * @packageDocumentation\n * @module iot\n * @mergeTarget\n */\n__exportStar(__webpack_require__(/*! ./aws_iot */ \"(ssr)/./node_modules/aws-crt/dist/native/aws_iot.js\"), exports);\n__exportStar(__webpack_require__(/*! ./aws_iot_mqtt5 */ \"(ssr)/./node_modules/aws-crt/dist/native/aws_iot_mqtt5.js\"), exports);\n//# sourceMappingURL=iot.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXdzLWNydC9kaXN0L25hdGl2ZS9pb3QuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQyxzRUFBVztBQUNoQyxhQUFhLG1CQUFPLENBQUMsa0ZBQWlCO0FBQ3RDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGF5d2luZC8uL25vZGVfbW9kdWxlcy9hd3MtY3J0L2Rpc3QvbmF0aXZlL2lvdC5qcz82NGQyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjAuXG4gKi9cbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBNb2R1bGUgZm9yIEFXUyBJb1QgTVFUVCBjbGllbnQgY29uZmlndXJhdGlvbiBhbmQgY29ubmVjdGlvbiBlc3RhYmxpc2htZW50LlxuICpcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuICogQG1vZHVsZSBpb3RcbiAqIEBtZXJnZVRhcmdldFxuICovXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYXdzX2lvdFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYXdzX2lvdF9tcXR0NVwiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pb3QuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/aws-crt/dist/native/iot.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/aws-crt/dist/native/mqtt.js":
/*!**************************************************!*\
  !*** ./node_modules/aws-crt/dist/native/mqtt.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n * SPDX-License-Identifier: Apache-2.0.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MqttClientConnection = exports.MqttClient = exports.MqttWill = exports.QoS = exports.HttpProxyOptions = void 0;\n/**\n *\n * A module containing support for mqtt connection establishment and operations.\n *\n * @packageDocumentation\n * @module mqtt\n * @mergeTarget\n */\nconst binding_1 = __importDefault(__webpack_require__(/*! ./binding */ \"(ssr)/./node_modules/aws-crt/dist/native/binding.js\"));\nconst native_resource_1 = __webpack_require__(/*! ./native_resource */ \"(ssr)/./node_modules/aws-crt/dist/native/native_resource.js\");\nconst event_1 = __webpack_require__(/*! ../common/event */ \"(ssr)/./node_modules/aws-crt/dist/common/event.js\");\nconst crt = __importStar(__webpack_require__(/*! ../common/mqtt_shared */ \"(ssr)/./node_modules/aws-crt/dist/common/mqtt_shared.js\"));\nconst error_1 = __webpack_require__(/*! ./error */ \"(ssr)/./node_modules/aws-crt/dist/native/error.js\");\nconst io = __importStar(__webpack_require__(/*! ./io */ \"(ssr)/./node_modules/aws-crt/dist/native/io.js\"));\nvar http_1 = __webpack_require__(/*! ./http */ \"(ssr)/./node_modules/aws-crt/dist/native/http.js\");\nObject.defineProperty(exports, \"HttpProxyOptions\", ({ enumerable: true, get: function () { return http_1.HttpProxyOptions; } }));\nconst mqtt_1 = __webpack_require__(/*! ../common/mqtt */ \"(ssr)/./node_modules/aws-crt/dist/common/mqtt.js\");\nvar mqtt_2 = __webpack_require__(/*! ../common/mqtt */ \"(ssr)/./node_modules/aws-crt/dist/common/mqtt.js\");\nObject.defineProperty(exports, \"QoS\", ({ enumerable: true, get: function () { return mqtt_2.QoS; } }));\nObject.defineProperty(exports, \"MqttWill\", ({ enumerable: true, get: function () { return mqtt_2.MqttWill; } }));\n/**\n * MQTT client\n *\n * @category MQTT\n */\nclass MqttClient extends native_resource_1.NativeResource {\n    /**\n     * @param bootstrap The {@link ClientBootstrap} to use for socket connections.  Leave undefined to use the\n     *          default system-wide bootstrap (recommended).\n     */\n    constructor(bootstrap = undefined) {\n        super(binding_1.default.mqtt_client_new(bootstrap != null ? bootstrap.native_handle() : null));\n        this.bootstrap = bootstrap;\n    }\n    /**\n     * Creates a new {@link MqttClientConnection}\n     * @param config Configuration for the mqtt connection\n     * @returns A new connection\n     */\n    new_connection(config) {\n        return new MqttClientConnection(this, config);\n    }\n}\nexports.MqttClient = MqttClient;\n;\n/**\n * MQTT client connection\n *\n * @category MQTT\n */\nclass MqttClientConnection extends (0, native_resource_1.NativeResourceMixin)(event_1.BufferedEventEmitter) {\n    /**\n     * @param client The client that owns this connection\n     * @param config The configuration for this connection\n     */\n    constructor(client, config) {\n        super();\n        this.client = client;\n        this.config = config;\n        if (config == null || config == undefined) {\n            throw new error_1.CrtError(\"MqttClientConnection constructor: config not defined\");\n        }\n        // If there is a will, ensure that its payload is normalized to a DataView\n        const will = config.will ?\n            {\n                topic: config.will.topic,\n                qos: config.will.qos,\n                payload: crt.normalize_payload(config.will.payload),\n                retain: config.will.retain\n            }\n            : undefined;\n        /** clamp reconnection time out values */\n        var min_sec = mqtt_1.DEFAULT_RECONNECT_MIN_SEC;\n        var max_sec = mqtt_1.DEFAULT_RECONNECT_MAX_SEC;\n        if (config.reconnect_min_sec) {\n            min_sec = config.reconnect_min_sec;\n            // clamp max, in case they only passed in min\n            max_sec = Math.max(min_sec, max_sec);\n        }\n        if (config.reconnect_max_sec) {\n            max_sec = config.reconnect_max_sec;\n            // clamp min, in case they only passed in max (or passed in min > max)\n            min_sec = Math.min(min_sec, max_sec);\n        }\n        if (client == undefined || client == null) {\n            throw new error_1.CrtError(\"MqttClientConnection constructor: client not defined\");\n        }\n        if (config.socket_options == undefined || config.socket_options == null) {\n            throw new error_1.CrtError(\"MqttClientConnection constructor: socket_options in configuration not defined\");\n        }\n        this._super(binding_1.default.mqtt_client_connection_new(client.native_handle(), (error_code) => { this._on_connection_interrupted(error_code); }, (return_code, session_present) => { this._on_connection_resumed(return_code, session_present); }, config.tls_ctx ? config.tls_ctx.native_handle() : null, will, config.username, config.password, config.use_websocket, config.proxy_options ? config.proxy_options.create_native_handle() : undefined, config.websocket_handshake_transform, min_sec, max_sec));\n        this.tls_ctx = config.tls_ctx;\n        binding_1.default.mqtt_client_connection_on_message(this.native_handle(), this._on_any_publish.bind(this));\n        binding_1.default.mqtt_client_connection_on_closed(this.native_handle(), this._on_connection_closed.bind(this));\n        /*\n         * Failed mqtt operations (which is normal) emit error events as well as rejecting the original promise.\n         * By installing a default error handler here we help prevent common issues where operation failures bring\n         * the whole program to an end because a handler wasn't installed.  Programs that install their own handler\n         * will be unaffected.\n         */\n        this.on('error', (error) => { });\n    }\n    close() {\n        binding_1.default.mqtt_client_connection_close(this.native_handle());\n    }\n    // Overridden to allow uncorking on ready\n    on(event, listener) {\n        super.on(event, listener);\n        if (event == 'connect') {\n            process.nextTick(() => {\n                this.uncork();\n            });\n        }\n        return this;\n    }\n    /**\n     * Open the actual connection to the server (async).\n     * @returns A Promise which completes whether the connection succeeds or fails.\n     *          If connection fails, the Promise will reject with an exception.\n     *          If connection succeeds, the Promise will return a boolean that is\n     *          true for resuming an existing session, or false if the session is new\n     */\n    connect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                reject = this._reject(reject);\n                if (this.config.socket_options == null || this.config.socket_options == undefined) {\n                    throw new error_1.CrtError(\"MqttClientConnection connect: socket_options in configuration not defined\");\n                }\n                try {\n                    binding_1.default.mqtt_client_connection_connect(this.native_handle(), this.config.client_id, this.config.host_name, this.config.port, this.config.socket_options.native_handle(), this.config.keep_alive, this.config.ping_timeout, this.config.protocol_operation_timeout, this.config.clean_session, this._on_connect_callback.bind(this, resolve, reject));\n                }\n                catch (e) {\n                    reject(e);\n                }\n            });\n        });\n    }\n    /**\n     * The connection will automatically reconnect when disconnected, removing the need for this function.\n     * To cease automatic reconnection attempts, call {@link disconnect}.\n     * @deprecated\n     */\n    reconnect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                reject = this._reject(reject);\n                try {\n                    binding_1.default.mqtt_client_connection_reconnect(this.native_handle(), this._on_connect_callback.bind(this, resolve, reject));\n                }\n                catch (e) {\n                    reject(e);\n                }\n            });\n        });\n    }\n    /**\n     * Publish message (async).\n     * If the device is offline, the PUBLISH packet will be sent once the connection resumes.\n     *\n     * @param topic Topic name\n     * @param payload Contents of message\n     * @param qos Quality of Service for delivering this message\n     * @param retain If true, the server will store the message and its QoS so that it can be\n     *               delivered to future subscribers whose subscriptions match the topic name\n     * @returns Promise which returns a {@link MqttRequest} which will contain the packet id of\n     *          the PUBLISH packet.\n     *\n     * * For QoS 0, completes as soon as the packet is sent.\n     * * For QoS 1, completes when PUBACK is received.\n     * * For QoS 2, completes when PUBCOMP is received.\n     */\n    publish(topic, payload, qos, retain = false) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Skip payload since it can be several different types\n            if (typeof (topic) !== 'string') {\n                return Promise.reject(\"topic is not a string\");\n            }\n            if (typeof (qos) !== 'number') {\n                return Promise.reject(\"qos is not a number\");\n            }\n            if (typeof (retain) !== 'boolean') {\n                return Promise.reject(\"retain is not a boolean\");\n            }\n            return new Promise((resolve, reject) => {\n                reject = this._reject(reject);\n                try {\n                    binding_1.default.mqtt_client_connection_publish(this.native_handle(), topic, crt.normalize_payload(payload), qos, retain, this._on_puback_callback.bind(this, resolve, reject));\n                }\n                catch (e) {\n                    reject(e);\n                }\n            });\n        });\n    }\n    /**\n     * Subscribe to a topic filter (async).\n     * The client sends a SUBSCRIBE packet and the server responds with a SUBACK.\n     *\n     * subscribe() may be called while the device is offline, though the async\n     * operation cannot complete successfully until the connection resumes.\n     *\n     * Once subscribed, `callback` is invoked each time a message matching\n     * the `topic` is received. It is possible for such messages to arrive before\n     * the SUBACK is received.\n     *\n     * @param topic Subscribe to this topic filter, which may include wildcards\n     * @param qos Maximum requested QoS that server may use when sending messages to the client.\n     *            The server may grant a lower QoS in the SUBACK\n     * @param on_message Optional callback invoked when message received.\n     * @returns Promise which returns a {@link MqttSubscribeRequest} which will contain the\n     *          result of the SUBSCRIBE. The Promise resolves when a SUBACK is returned\n     *          from the server or is rejected when an exception occurs.\n     */\n    subscribe(topic, qos, on_message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof (topic) !== 'string') {\n                return Promise.reject(\"topic is not a string\");\n            }\n            if (typeof (qos) !== 'number') {\n                return Promise.reject(\"qos is not a number\");\n            }\n            return new Promise((resolve, reject) => {\n                reject = this._reject(reject);\n                try {\n                    binding_1.default.mqtt_client_connection_subscribe(this.native_handle(), topic, qos, on_message, this._on_suback_callback.bind(this, resolve, reject));\n                }\n                catch (e) {\n                    reject(e);\n                }\n            });\n        });\n    }\n    /**\n     * Unsubscribe from a topic filter (async).\n     * The client sends an UNSUBSCRIBE packet, and the server responds with an UNSUBACK.\n     * @param topic The topic filter to unsubscribe from. May contain wildcards.\n     * @returns Promise wihch returns a {@link MqttRequest} which will contain the packet id\n     *          of the UNSUBSCRIBE packet being acknowledged. Promise is resolved when an\n     *          UNSUBACK is received from the server or is rejected when an exception occurs.\n     */\n    unsubscribe(topic) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof (topic) !== 'string') {\n                return Promise.reject(\"topic is not a string\");\n            }\n            return new Promise((resolve, reject) => {\n                reject = this._reject(reject);\n                try {\n                    binding_1.default.mqtt_client_connection_unsubscribe(this.native_handle(), topic, this._on_unsuback_callback.bind(this, resolve, reject));\n                }\n                catch (e) {\n                    reject(e);\n                }\n            });\n        });\n    }\n    /**\n     * Close the connection (async).\n     *\n     * Will free all native resources, rendering the connection unusable after the disconnect() call.\n     *\n     * @returns Promise which completes when the connection is closed.\n    */\n    disconnect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                reject = this._reject(reject);\n                try {\n                    binding_1.default.mqtt_client_connection_disconnect(this.native_handle(), this._on_disconnect_callback.bind(this, resolve));\n                }\n                catch (e) {\n                    reject(e);\n                }\n            });\n        });\n    }\n    /**\n     * Queries a small set of numerical statistics about the current state of the connection's operation queue\n     *\n     * @group Node-only\n     */\n    getQueueStatistics() {\n        return binding_1.default.mqtt_client_connection_get_queue_statistics(this.native_handle());\n    }\n    // Wrap a promise rejection with a function that will also emit the error as an event\n    _reject(reject) {\n        return (reason) => {\n            reject(reason);\n            process.nextTick(() => {\n                this.emit('error', new error_1.CrtError(reason));\n            });\n        };\n    }\n    _on_connection_interrupted(error_code) {\n        this.emit('interrupt', new error_1.CrtError(error_code));\n    }\n    _on_connection_resumed(return_code, session_present) {\n        this.emit('resume', return_code, session_present);\n        let successCallbackData = { session_present: session_present, reason_code: return_code };\n        this.emit('connection_success', successCallbackData);\n    }\n    _on_any_publish(topic, payload, dup, qos, retain) {\n        this.emit('message', topic, payload, dup, qos, retain);\n    }\n    _on_connection_closed() {\n        let closedCallbackData = {};\n        this.emit('closed', closedCallbackData);\n        /**\n         * We call close() here instead of on disconnect because on_close is always called AFTER disconnect\n         * but if we call close() before, then we cannot emit the closed callback.\n         */\n        this.close();\n    }\n    _on_connect_callback(resolve, reject, error_code, return_code, session_present) {\n        if (error_code == 0 && return_code == 0) {\n            resolve(session_present);\n            this.emit('connect', session_present);\n            let successCallbackData = { session_present: session_present, reason_code: return_code };\n            this.emit('connection_success', successCallbackData);\n        }\n        else if (error_code != 0) {\n            reject(\"Failed to connect: \" + io.error_code_to_string(error_code));\n            let failureCallbackData = { error: new error_1.CrtError(error_code) };\n            this.emit('connection_failure', failureCallbackData);\n        }\n        else {\n            reject(\"Server rejected connection.\");\n            let failureCallbackData = { error: new error_1.CrtError(5134) }; // 5134 = AWS_ERROR_MQTT_UNEXPECTED_HANGUP\n            this.emit('connection_failure', failureCallbackData);\n        }\n    }\n    _on_puback_callback(resolve, reject, packet_id, error_code) {\n        if (error_code == 0) {\n            resolve({ packet_id });\n        }\n        else {\n            reject(\"Failed to publish: \" + io.error_code_to_string(error_code));\n        }\n    }\n    _on_suback_callback(resolve, reject, packet_id, topic, qos, error_code) {\n        if (error_code == 0) {\n            resolve({ packet_id, topic, qos, error_code });\n        }\n        else {\n            reject(\"Failed to subscribe: \" + io.error_code_to_string(error_code));\n        }\n    }\n    _on_unsuback_callback(resolve, reject, packet_id, error_code) {\n        if (error_code == 0) {\n            resolve({ packet_id });\n        }\n        else {\n            reject(\"Failed to unsubscribe: \" + io.error_code_to_string(error_code));\n        }\n    }\n    _on_disconnect_callback(resolve) {\n        resolve();\n        this.emit('disconnect');\n        /** NOTE: We are NOT calling close() here but instead calling it at\n         * on_closed because it is always called after disconnect */\n    }\n}\nexports.MqttClientConnection = MqttClientConnection;\n/**\n * Emitted when the connection successfully establishes itself for the first time\n *\n * @event\n */\nMqttClientConnection.CONNECT = 'connect';\n/**\n * Emitted when connection has disconnected successfully.\n *\n * @event\n */\nMqttClientConnection.DISCONNECT = 'disconnect';\n/**\n * Emitted when an error occurs.  The error will contain the error\n * code and message.\n *\n * @event\n */\nMqttClientConnection.ERROR = 'error';\n/**\n * Emitted when the connection is dropped unexpectedly. The error will contain the error\n * code and message.  The underlying mqtt implementation will attempt to reconnect.\n *\n * @event\n */\nMqttClientConnection.INTERRUPT = 'interrupt';\n/**\n * Emitted when the connection reconnects (after an interrupt). Only triggers on connections after the initial one.\n *\n * @event\n */\nMqttClientConnection.RESUME = 'resume';\n/**\n * Emitted when any MQTT publish message arrives.\n *\n * @event\n */\nMqttClientConnection.MESSAGE = 'message';\n/**\n * Emitted on every successful connect and reconnect.\n * Will contain a number with the connection reason code and\n * a boolean indicating whether the connection resumed a session.\n *\n * @event\n */\nMqttClientConnection.CONNECTION_SUCCESS = 'connection_success';\n/**\n * Emitted on an unsuccessful connect and reconnect.\n * Will contain an error code indicating the reason for the unsuccessful connection.\n *\n * @event\n */\nMqttClientConnection.CONNECTION_FAILURE = 'connection_failure';\n/**\n * Emitted when the MQTT connection was disconnected and shutdown successfully.\n *\n * @event\n */\nMqttClientConnection.CLOSED = 'closed';\n//# sourceMappingURL=mqtt.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXdzLWNydC9kaXN0L25hdGl2ZS9tcXR0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDRCQUE0QixHQUFHLGtCQUFrQixHQUFHLGdCQUFnQixHQUFHLFdBQVcsR0FBRyx3QkFBd0I7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxtQkFBTyxDQUFDLHNFQUFXO0FBQ3JELDBCQUEwQixtQkFBTyxDQUFDLHNGQUFtQjtBQUNyRCxnQkFBZ0IsbUJBQU8sQ0FBQywwRUFBaUI7QUFDekMseUJBQXlCLG1CQUFPLENBQUMsc0ZBQXVCO0FBQ3hELGdCQUFnQixtQkFBTyxDQUFDLGtFQUFTO0FBQ2pDLHdCQUF3QixtQkFBTyxDQUFDLDREQUFNO0FBQ3RDLGFBQWEsbUJBQU8sQ0FBQyxnRUFBUTtBQUM3QixvREFBbUQsRUFBRSxxQ0FBcUMsbUNBQW1DLEVBQUM7QUFDOUgsZUFBZSxtQkFBTyxDQUFDLHdFQUFnQjtBQUN2QyxhQUFhLG1CQUFPLENBQUMsd0VBQWdCO0FBQ3JDLHVDQUFzQyxFQUFFLHFDQUFxQyxzQkFBc0IsRUFBQztBQUNwRyw0Q0FBMkMsRUFBRSxxQ0FBcUMsMkJBQTJCLEVBQUM7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsdUJBQXVCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkdBQTJHLDhDQUE4QyxzQ0FBc0MsNERBQTREO0FBQzNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsaUJBQWlCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsbUJBQW1CO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDRCQUE0QjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxtQkFBbUI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxxQ0FBcUM7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1DQUFtQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wYXl3aW5kLy4vbm9kZV9tb2R1bGVzL2F3cy1jcnQvZGlzdC9uYXRpdmUvbXF0dC5qcz83YTU2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjAuXG4gKi9cbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1xdHRDbGllbnRDb25uZWN0aW9uID0gZXhwb3J0cy5NcXR0Q2xpZW50ID0gZXhwb3J0cy5NcXR0V2lsbCA9IGV4cG9ydHMuUW9TID0gZXhwb3J0cy5IdHRwUHJveHlPcHRpb25zID0gdm9pZCAwO1xuLyoqXG4gKlxuICogQSBtb2R1bGUgY29udGFpbmluZyBzdXBwb3J0IGZvciBtcXR0IGNvbm5lY3Rpb24gZXN0YWJsaXNobWVudCBhbmQgb3BlcmF0aW9ucy5cbiAqXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqIEBtb2R1bGUgbXF0dFxuICogQG1lcmdlVGFyZ2V0XG4gKi9cbmNvbnN0IGJpbmRpbmdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9iaW5kaW5nXCIpKTtcbmNvbnN0IG5hdGl2ZV9yZXNvdXJjZV8xID0gcmVxdWlyZShcIi4vbmF0aXZlX3Jlc291cmNlXCIpO1xuY29uc3QgZXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vZXZlbnRcIik7XG5jb25zdCBjcnQgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL2NvbW1vbi9tcXR0X3NoYXJlZFwiKSk7XG5jb25zdCBlcnJvcl8xID0gcmVxdWlyZShcIi4vZXJyb3JcIik7XG5jb25zdCBpbyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9pb1wiKSk7XG52YXIgaHR0cF8xID0gcmVxdWlyZShcIi4vaHR0cFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkh0dHBQcm94eU9wdGlvbnNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGh0dHBfMS5IdHRwUHJveHlPcHRpb25zOyB9IH0pO1xuY29uc3QgbXF0dF8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9tcXR0XCIpO1xudmFyIG1xdHRfMiA9IHJlcXVpcmUoXCIuLi9jb21tb24vbXF0dFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlFvU1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbXF0dF8yLlFvUzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1xdHRXaWxsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtcXR0XzIuTXF0dFdpbGw7IH0gfSk7XG4vKipcbiAqIE1RVFQgY2xpZW50XG4gKlxuICogQGNhdGVnb3J5IE1RVFRcbiAqL1xuY2xhc3MgTXF0dENsaWVudCBleHRlbmRzIG5hdGl2ZV9yZXNvdXJjZV8xLk5hdGl2ZVJlc291cmNlIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gYm9vdHN0cmFwIFRoZSB7QGxpbmsgQ2xpZW50Qm9vdHN0cmFwfSB0byB1c2UgZm9yIHNvY2tldCBjb25uZWN0aW9ucy4gIExlYXZlIHVuZGVmaW5lZCB0byB1c2UgdGhlXG4gICAgICogICAgICAgICAgZGVmYXVsdCBzeXN0ZW0td2lkZSBib290c3RyYXAgKHJlY29tbWVuZGVkKS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihib290c3RyYXAgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3VwZXIoYmluZGluZ18xLmRlZmF1bHQubXF0dF9jbGllbnRfbmV3KGJvb3RzdHJhcCAhPSBudWxsID8gYm9vdHN0cmFwLm5hdGl2ZV9oYW5kbGUoKSA6IG51bGwpKTtcbiAgICAgICAgdGhpcy5ib290c3RyYXAgPSBib290c3RyYXA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcge0BsaW5rIE1xdHRDbGllbnRDb25uZWN0aW9ufVxuICAgICAqIEBwYXJhbSBjb25maWcgQ29uZmlndXJhdGlvbiBmb3IgdGhlIG1xdHQgY29ubmVjdGlvblxuICAgICAqIEByZXR1cm5zIEEgbmV3IGNvbm5lY3Rpb25cbiAgICAgKi9cbiAgICBuZXdfY29ubmVjdGlvbihjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNcXR0Q2xpZW50Q29ubmVjdGlvbih0aGlzLCBjb25maWcpO1xuICAgIH1cbn1cbmV4cG9ydHMuTXF0dENsaWVudCA9IE1xdHRDbGllbnQ7XG47XG4vKipcbiAqIE1RVFQgY2xpZW50IGNvbm5lY3Rpb25cbiAqXG4gKiBAY2F0ZWdvcnkgTVFUVFxuICovXG5jbGFzcyBNcXR0Q2xpZW50Q29ubmVjdGlvbiBleHRlbmRzICgwLCBuYXRpdmVfcmVzb3VyY2VfMS5OYXRpdmVSZXNvdXJjZU1peGluKShldmVudF8xLkJ1ZmZlcmVkRXZlbnRFbWl0dGVyKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGNsaWVudCBUaGUgY2xpZW50IHRoYXQgb3ducyB0aGlzIGNvbm5lY3Rpb25cbiAgICAgKiBAcGFyYW0gY29uZmlnIFRoZSBjb25maWd1cmF0aW9uIGZvciB0aGlzIGNvbm5lY3Rpb25cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihjbGllbnQsIGNvbmZpZykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIGlmIChjb25maWcgPT0gbnVsbCB8fCBjb25maWcgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JfMS5DcnRFcnJvcihcIk1xdHRDbGllbnRDb25uZWN0aW9uIGNvbnN0cnVjdG9yOiBjb25maWcgbm90IGRlZmluZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSB3aWxsLCBlbnN1cmUgdGhhdCBpdHMgcGF5bG9hZCBpcyBub3JtYWxpemVkIHRvIGEgRGF0YVZpZXdcbiAgICAgICAgY29uc3Qgd2lsbCA9IGNvbmZpZy53aWxsID9cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0b3BpYzogY29uZmlnLndpbGwudG9waWMsXG4gICAgICAgICAgICAgICAgcW9zOiBjb25maWcud2lsbC5xb3MsXG4gICAgICAgICAgICAgICAgcGF5bG9hZDogY3J0Lm5vcm1hbGl6ZV9wYXlsb2FkKGNvbmZpZy53aWxsLnBheWxvYWQpLFxuICAgICAgICAgICAgICAgIHJldGFpbjogY29uZmlnLndpbGwucmV0YWluXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgLyoqIGNsYW1wIHJlY29ubmVjdGlvbiB0aW1lIG91dCB2YWx1ZXMgKi9cbiAgICAgICAgdmFyIG1pbl9zZWMgPSBtcXR0XzEuREVGQVVMVF9SRUNPTk5FQ1RfTUlOX1NFQztcbiAgICAgICAgdmFyIG1heF9zZWMgPSBtcXR0XzEuREVGQVVMVF9SRUNPTk5FQ1RfTUFYX1NFQztcbiAgICAgICAgaWYgKGNvbmZpZy5yZWNvbm5lY3RfbWluX3NlYykge1xuICAgICAgICAgICAgbWluX3NlYyA9IGNvbmZpZy5yZWNvbm5lY3RfbWluX3NlYztcbiAgICAgICAgICAgIC8vIGNsYW1wIG1heCwgaW4gY2FzZSB0aGV5IG9ubHkgcGFzc2VkIGluIG1pblxuICAgICAgICAgICAgbWF4X3NlYyA9IE1hdGgubWF4KG1pbl9zZWMsIG1heF9zZWMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWcucmVjb25uZWN0X21heF9zZWMpIHtcbiAgICAgICAgICAgIG1heF9zZWMgPSBjb25maWcucmVjb25uZWN0X21heF9zZWM7XG4gICAgICAgICAgICAvLyBjbGFtcCBtaW4sIGluIGNhc2UgdGhleSBvbmx5IHBhc3NlZCBpbiBtYXggKG9yIHBhc3NlZCBpbiBtaW4gPiBtYXgpXG4gICAgICAgICAgICBtaW5fc2VjID0gTWF0aC5taW4obWluX3NlYywgbWF4X3NlYyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsaWVudCA9PSB1bmRlZmluZWQgfHwgY2xpZW50ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcl8xLkNydEVycm9yKFwiTXF0dENsaWVudENvbm5lY3Rpb24gY29uc3RydWN0b3I6IGNsaWVudCBub3QgZGVmaW5lZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLnNvY2tldF9vcHRpb25zID09IHVuZGVmaW5lZCB8fCBjb25maWcuc29ja2V0X29wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yXzEuQ3J0RXJyb3IoXCJNcXR0Q2xpZW50Q29ubmVjdGlvbiBjb25zdHJ1Y3Rvcjogc29ja2V0X29wdGlvbnMgaW4gY29uZmlndXJhdGlvbiBub3QgZGVmaW5lZFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdXBlcihiaW5kaW5nXzEuZGVmYXVsdC5tcXR0X2NsaWVudF9jb25uZWN0aW9uX25ldyhjbGllbnQubmF0aXZlX2hhbmRsZSgpLCAoZXJyb3JfY29kZSkgPT4geyB0aGlzLl9vbl9jb25uZWN0aW9uX2ludGVycnVwdGVkKGVycm9yX2NvZGUpOyB9LCAocmV0dXJuX2NvZGUsIHNlc3Npb25fcHJlc2VudCkgPT4geyB0aGlzLl9vbl9jb25uZWN0aW9uX3Jlc3VtZWQocmV0dXJuX2NvZGUsIHNlc3Npb25fcHJlc2VudCk7IH0sIGNvbmZpZy50bHNfY3R4ID8gY29uZmlnLnRsc19jdHgubmF0aXZlX2hhbmRsZSgpIDogbnVsbCwgd2lsbCwgY29uZmlnLnVzZXJuYW1lLCBjb25maWcucGFzc3dvcmQsIGNvbmZpZy51c2Vfd2Vic29ja2V0LCBjb25maWcucHJveHlfb3B0aW9ucyA/IGNvbmZpZy5wcm94eV9vcHRpb25zLmNyZWF0ZV9uYXRpdmVfaGFuZGxlKCkgOiB1bmRlZmluZWQsIGNvbmZpZy53ZWJzb2NrZXRfaGFuZHNoYWtlX3RyYW5zZm9ybSwgbWluX3NlYywgbWF4X3NlYykpO1xuICAgICAgICB0aGlzLnRsc19jdHggPSBjb25maWcudGxzX2N0eDtcbiAgICAgICAgYmluZGluZ18xLmRlZmF1bHQubXF0dF9jbGllbnRfY29ubmVjdGlvbl9vbl9tZXNzYWdlKHRoaXMubmF0aXZlX2hhbmRsZSgpLCB0aGlzLl9vbl9hbnlfcHVibGlzaC5iaW5kKHRoaXMpKTtcbiAgICAgICAgYmluZGluZ18xLmRlZmF1bHQubXF0dF9jbGllbnRfY29ubmVjdGlvbl9vbl9jbG9zZWQodGhpcy5uYXRpdmVfaGFuZGxlKCksIHRoaXMuX29uX2Nvbm5lY3Rpb25fY2xvc2VkLmJpbmQodGhpcykpO1xuICAgICAgICAvKlxuICAgICAgICAgKiBGYWlsZWQgbXF0dCBvcGVyYXRpb25zICh3aGljaCBpcyBub3JtYWwpIGVtaXQgZXJyb3IgZXZlbnRzIGFzIHdlbGwgYXMgcmVqZWN0aW5nIHRoZSBvcmlnaW5hbCBwcm9taXNlLlxuICAgICAgICAgKiBCeSBpbnN0YWxsaW5nIGEgZGVmYXVsdCBlcnJvciBoYW5kbGVyIGhlcmUgd2UgaGVscCBwcmV2ZW50IGNvbW1vbiBpc3N1ZXMgd2hlcmUgb3BlcmF0aW9uIGZhaWx1cmVzIGJyaW5nXG4gICAgICAgICAqIHRoZSB3aG9sZSBwcm9ncmFtIHRvIGFuIGVuZCBiZWNhdXNlIGEgaGFuZGxlciB3YXNuJ3QgaW5zdGFsbGVkLiAgUHJvZ3JhbXMgdGhhdCBpbnN0YWxsIHRoZWlyIG93biBoYW5kbGVyXG4gICAgICAgICAqIHdpbGwgYmUgdW5hZmZlY3RlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub24oJ2Vycm9yJywgKGVycm9yKSA9PiB7IH0pO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgYmluZGluZ18xLmRlZmF1bHQubXF0dF9jbGllbnRfY29ubmVjdGlvbl9jbG9zZSh0aGlzLm5hdGl2ZV9oYW5kbGUoKSk7XG4gICAgfVxuICAgIC8vIE92ZXJyaWRkZW4gdG8gYWxsb3cgdW5jb3JraW5nIG9uIHJlYWR5XG4gICAgb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHN1cGVyLm9uKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgICAgIGlmIChldmVudCA9PSAnY29ubmVjdCcpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudW5jb3JrKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3BlbiB0aGUgYWN0dWFsIGNvbm5lY3Rpb24gdG8gdGhlIHNlcnZlciAoYXN5bmMpLlxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSB3aGljaCBjb21wbGV0ZXMgd2hldGhlciB0aGUgY29ubmVjdGlvbiBzdWNjZWVkcyBvciBmYWlscy5cbiAgICAgKiAgICAgICAgICBJZiBjb25uZWN0aW9uIGZhaWxzLCB0aGUgUHJvbWlzZSB3aWxsIHJlamVjdCB3aXRoIGFuIGV4Y2VwdGlvbi5cbiAgICAgKiAgICAgICAgICBJZiBjb25uZWN0aW9uIHN1Y2NlZWRzLCB0aGUgUHJvbWlzZSB3aWxsIHJldHVybiBhIGJvb2xlYW4gdGhhdCBpc1xuICAgICAqICAgICAgICAgIHRydWUgZm9yIHJlc3VtaW5nIGFuIGV4aXN0aW5nIHNlc3Npb24sIG9yIGZhbHNlIGlmIHRoZSBzZXNzaW9uIGlzIG5ld1xuICAgICAqL1xuICAgIGNvbm5lY3QoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlamVjdCA9IHRoaXMuX3JlamVjdChyZWplY3QpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5zb2NrZXRfb3B0aW9ucyA9PSBudWxsIHx8IHRoaXMuY29uZmlnLnNvY2tldF9vcHRpb25zID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JfMS5DcnRFcnJvcihcIk1xdHRDbGllbnRDb25uZWN0aW9uIGNvbm5lY3Q6IHNvY2tldF9vcHRpb25zIGluIGNvbmZpZ3VyYXRpb24gbm90IGRlZmluZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGJpbmRpbmdfMS5kZWZhdWx0Lm1xdHRfY2xpZW50X2Nvbm5lY3Rpb25fY29ubmVjdCh0aGlzLm5hdGl2ZV9oYW5kbGUoKSwgdGhpcy5jb25maWcuY2xpZW50X2lkLCB0aGlzLmNvbmZpZy5ob3N0X25hbWUsIHRoaXMuY29uZmlnLnBvcnQsIHRoaXMuY29uZmlnLnNvY2tldF9vcHRpb25zLm5hdGl2ZV9oYW5kbGUoKSwgdGhpcy5jb25maWcua2VlcF9hbGl2ZSwgdGhpcy5jb25maWcucGluZ190aW1lb3V0LCB0aGlzLmNvbmZpZy5wcm90b2NvbF9vcGVyYXRpb25fdGltZW91dCwgdGhpcy5jb25maWcuY2xlYW5fc2Vzc2lvbiwgdGhpcy5fb25fY29ubmVjdF9jYWxsYmFjay5iaW5kKHRoaXMsIHJlc29sdmUsIHJlamVjdCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgY29ubmVjdGlvbiB3aWxsIGF1dG9tYXRpY2FsbHkgcmVjb25uZWN0IHdoZW4gZGlzY29ubmVjdGVkLCByZW1vdmluZyB0aGUgbmVlZCBmb3IgdGhpcyBmdW5jdGlvbi5cbiAgICAgKiBUbyBjZWFzZSBhdXRvbWF0aWMgcmVjb25uZWN0aW9uIGF0dGVtcHRzLCBjYWxsIHtAbGluayBkaXNjb25uZWN0fS5cbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIHJlY29ubmVjdCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmVqZWN0ID0gdGhpcy5fcmVqZWN0KHJlamVjdCk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYmluZGluZ18xLmRlZmF1bHQubXF0dF9jbGllbnRfY29ubmVjdGlvbl9yZWNvbm5lY3QodGhpcy5uYXRpdmVfaGFuZGxlKCksIHRoaXMuX29uX2Nvbm5lY3RfY2FsbGJhY2suYmluZCh0aGlzLCByZXNvbHZlLCByZWplY3QpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVibGlzaCBtZXNzYWdlIChhc3luYykuXG4gICAgICogSWYgdGhlIGRldmljZSBpcyBvZmZsaW5lLCB0aGUgUFVCTElTSCBwYWNrZXQgd2lsbCBiZSBzZW50IG9uY2UgdGhlIGNvbm5lY3Rpb24gcmVzdW1lcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0b3BpYyBUb3BpYyBuYW1lXG4gICAgICogQHBhcmFtIHBheWxvYWQgQ29udGVudHMgb2YgbWVzc2FnZVxuICAgICAqIEBwYXJhbSBxb3MgUXVhbGl0eSBvZiBTZXJ2aWNlIGZvciBkZWxpdmVyaW5nIHRoaXMgbWVzc2FnZVxuICAgICAqIEBwYXJhbSByZXRhaW4gSWYgdHJ1ZSwgdGhlIHNlcnZlciB3aWxsIHN0b3JlIHRoZSBtZXNzYWdlIGFuZCBpdHMgUW9TIHNvIHRoYXQgaXQgY2FuIGJlXG4gICAgICogICAgICAgICAgICAgICBkZWxpdmVyZWQgdG8gZnV0dXJlIHN1YnNjcmliZXJzIHdob3NlIHN1YnNjcmlwdGlvbnMgbWF0Y2ggdGhlIHRvcGljIG5hbWVcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJldHVybnMgYSB7QGxpbmsgTXF0dFJlcXVlc3R9IHdoaWNoIHdpbGwgY29udGFpbiB0aGUgcGFja2V0IGlkIG9mXG4gICAgICogICAgICAgICAgdGhlIFBVQkxJU0ggcGFja2V0LlxuICAgICAqXG4gICAgICogKiBGb3IgUW9TIDAsIGNvbXBsZXRlcyBhcyBzb29uIGFzIHRoZSBwYWNrZXQgaXMgc2VudC5cbiAgICAgKiAqIEZvciBRb1MgMSwgY29tcGxldGVzIHdoZW4gUFVCQUNLIGlzIHJlY2VpdmVkLlxuICAgICAqICogRm9yIFFvUyAyLCBjb21wbGV0ZXMgd2hlbiBQVUJDT01QIGlzIHJlY2VpdmVkLlxuICAgICAqL1xuICAgIHB1Ymxpc2godG9waWMsIHBheWxvYWQsIHFvcywgcmV0YWluID0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIFNraXAgcGF5bG9hZCBzaW5jZSBpdCBjYW4gYmUgc2V2ZXJhbCBkaWZmZXJlbnQgdHlwZXNcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKHRvcGljKSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXCJ0b3BpYyBpcyBub3QgYSBzdHJpbmdcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIChxb3MpICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcInFvcyBpcyBub3QgYSBudW1iZXJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIChyZXRhaW4pICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXCJyZXRhaW4gaXMgbm90IGEgYm9vbGVhblwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmVqZWN0ID0gdGhpcy5fcmVqZWN0KHJlamVjdCk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYmluZGluZ18xLmRlZmF1bHQubXF0dF9jbGllbnRfY29ubmVjdGlvbl9wdWJsaXNoKHRoaXMubmF0aXZlX2hhbmRsZSgpLCB0b3BpYywgY3J0Lm5vcm1hbGl6ZV9wYXlsb2FkKHBheWxvYWQpLCBxb3MsIHJldGFpbiwgdGhpcy5fb25fcHViYWNrX2NhbGxiYWNrLmJpbmQodGhpcywgcmVzb2x2ZSwgcmVqZWN0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZSB0byBhIHRvcGljIGZpbHRlciAoYXN5bmMpLlxuICAgICAqIFRoZSBjbGllbnQgc2VuZHMgYSBTVUJTQ1JJQkUgcGFja2V0IGFuZCB0aGUgc2VydmVyIHJlc3BvbmRzIHdpdGggYSBTVUJBQ0suXG4gICAgICpcbiAgICAgKiBzdWJzY3JpYmUoKSBtYXkgYmUgY2FsbGVkIHdoaWxlIHRoZSBkZXZpY2UgaXMgb2ZmbGluZSwgdGhvdWdoIHRoZSBhc3luY1xuICAgICAqIG9wZXJhdGlvbiBjYW5ub3QgY29tcGxldGUgc3VjY2Vzc2Z1bGx5IHVudGlsIHRoZSBjb25uZWN0aW9uIHJlc3VtZXMuXG4gICAgICpcbiAgICAgKiBPbmNlIHN1YnNjcmliZWQsIGBjYWxsYmFja2AgaXMgaW52b2tlZCBlYWNoIHRpbWUgYSBtZXNzYWdlIG1hdGNoaW5nXG4gICAgICogdGhlIGB0b3BpY2AgaXMgcmVjZWl2ZWQuIEl0IGlzIHBvc3NpYmxlIGZvciBzdWNoIG1lc3NhZ2VzIHRvIGFycml2ZSBiZWZvcmVcbiAgICAgKiB0aGUgU1VCQUNLIGlzIHJlY2VpdmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRvcGljIFN1YnNjcmliZSB0byB0aGlzIHRvcGljIGZpbHRlciwgd2hpY2ggbWF5IGluY2x1ZGUgd2lsZGNhcmRzXG4gICAgICogQHBhcmFtIHFvcyBNYXhpbXVtIHJlcXVlc3RlZCBRb1MgdGhhdCBzZXJ2ZXIgbWF5IHVzZSB3aGVuIHNlbmRpbmcgbWVzc2FnZXMgdG8gdGhlIGNsaWVudC5cbiAgICAgKiAgICAgICAgICAgIFRoZSBzZXJ2ZXIgbWF5IGdyYW50IGEgbG93ZXIgUW9TIGluIHRoZSBTVUJBQ0tcbiAgICAgKiBAcGFyYW0gb25fbWVzc2FnZSBPcHRpb25hbCBjYWxsYmFjayBpbnZva2VkIHdoZW4gbWVzc2FnZSByZWNlaXZlZC5cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJldHVybnMgYSB7QGxpbmsgTXF0dFN1YnNjcmliZVJlcXVlc3R9IHdoaWNoIHdpbGwgY29udGFpbiB0aGVcbiAgICAgKiAgICAgICAgICByZXN1bHQgb2YgdGhlIFNVQlNDUklCRS4gVGhlIFByb21pc2UgcmVzb2x2ZXMgd2hlbiBhIFNVQkFDSyBpcyByZXR1cm5lZFxuICAgICAqICAgICAgICAgIGZyb20gdGhlIHNlcnZlciBvciBpcyByZWplY3RlZCB3aGVuIGFuIGV4Y2VwdGlvbiBvY2N1cnMuXG4gICAgICovXG4gICAgc3Vic2NyaWJlKHRvcGljLCBxb3MsIG9uX21lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKHRvcGljKSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXCJ0b3BpYyBpcyBub3QgYSBzdHJpbmdcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIChxb3MpICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcInFvcyBpcyBub3QgYSBudW1iZXJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlamVjdCA9IHRoaXMuX3JlamVjdChyZWplY3QpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGJpbmRpbmdfMS5kZWZhdWx0Lm1xdHRfY2xpZW50X2Nvbm5lY3Rpb25fc3Vic2NyaWJlKHRoaXMubmF0aXZlX2hhbmRsZSgpLCB0b3BpYywgcW9zLCBvbl9tZXNzYWdlLCB0aGlzLl9vbl9zdWJhY2tfY2FsbGJhY2suYmluZCh0aGlzLCByZXNvbHZlLCByZWplY3QpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5zdWJzY3JpYmUgZnJvbSBhIHRvcGljIGZpbHRlciAoYXN5bmMpLlxuICAgICAqIFRoZSBjbGllbnQgc2VuZHMgYW4gVU5TVUJTQ1JJQkUgcGFja2V0LCBhbmQgdGhlIHNlcnZlciByZXNwb25kcyB3aXRoIGFuIFVOU1VCQUNLLlxuICAgICAqIEBwYXJhbSB0b3BpYyBUaGUgdG9waWMgZmlsdGVyIHRvIHVuc3Vic2NyaWJlIGZyb20uIE1heSBjb250YWluIHdpbGRjYXJkcy5cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdpaGNoIHJldHVybnMgYSB7QGxpbmsgTXF0dFJlcXVlc3R9IHdoaWNoIHdpbGwgY29udGFpbiB0aGUgcGFja2V0IGlkXG4gICAgICogICAgICAgICAgb2YgdGhlIFVOU1VCU0NSSUJFIHBhY2tldCBiZWluZyBhY2tub3dsZWRnZWQuIFByb21pc2UgaXMgcmVzb2x2ZWQgd2hlbiBhblxuICAgICAqICAgICAgICAgIFVOU1VCQUNLIGlzIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlciBvciBpcyByZWplY3RlZCB3aGVuIGFuIGV4Y2VwdGlvbiBvY2N1cnMuXG4gICAgICovXG4gICAgdW5zdWJzY3JpYmUodG9waWMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKHRvcGljKSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXCJ0b3BpYyBpcyBub3QgYSBzdHJpbmdcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlamVjdCA9IHRoaXMuX3JlamVjdChyZWplY3QpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGJpbmRpbmdfMS5kZWZhdWx0Lm1xdHRfY2xpZW50X2Nvbm5lY3Rpb25fdW5zdWJzY3JpYmUodGhpcy5uYXRpdmVfaGFuZGxlKCksIHRvcGljLCB0aGlzLl9vbl91bnN1YmFja19jYWxsYmFjay5iaW5kKHRoaXMsIHJlc29sdmUsIHJlamVjdCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZSB0aGUgY29ubmVjdGlvbiAoYXN5bmMpLlxuICAgICAqXG4gICAgICogV2lsbCBmcmVlIGFsbCBuYXRpdmUgcmVzb3VyY2VzLCByZW5kZXJpbmcgdGhlIGNvbm5lY3Rpb24gdW51c2FibGUgYWZ0ZXIgdGhlIGRpc2Nvbm5lY3QoKSBjYWxsLlxuICAgICAqXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB3aGljaCBjb21wbGV0ZXMgd2hlbiB0aGUgY29ubmVjdGlvbiBpcyBjbG9zZWQuXG4gICAgKi9cbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICByZWplY3QgPSB0aGlzLl9yZWplY3QocmVqZWN0KTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBiaW5kaW5nXzEuZGVmYXVsdC5tcXR0X2NsaWVudF9jb25uZWN0aW9uX2Rpc2Nvbm5lY3QodGhpcy5uYXRpdmVfaGFuZGxlKCksIHRoaXMuX29uX2Rpc2Nvbm5lY3RfY2FsbGJhY2suYmluZCh0aGlzLCByZXNvbHZlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1ZXJpZXMgYSBzbWFsbCBzZXQgb2YgbnVtZXJpY2FsIHN0YXRpc3RpY3MgYWJvdXQgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGNvbm5lY3Rpb24ncyBvcGVyYXRpb24gcXVldWVcbiAgICAgKlxuICAgICAqIEBncm91cCBOb2RlLW9ubHlcbiAgICAgKi9cbiAgICBnZXRRdWV1ZVN0YXRpc3RpY3MoKSB7XG4gICAgICAgIHJldHVybiBiaW5kaW5nXzEuZGVmYXVsdC5tcXR0X2NsaWVudF9jb25uZWN0aW9uX2dldF9xdWV1ZV9zdGF0aXN0aWNzKHRoaXMubmF0aXZlX2hhbmRsZSgpKTtcbiAgICB9XG4gICAgLy8gV3JhcCBhIHByb21pc2UgcmVqZWN0aW9uIHdpdGggYSBmdW5jdGlvbiB0aGF0IHdpbGwgYWxzbyBlbWl0IHRoZSBlcnJvciBhcyBhbiBldmVudFxuICAgIF9yZWplY3QocmVqZWN0KSB7XG4gICAgICAgIHJldHVybiAocmVhc29uKSA9PiB7XG4gICAgICAgICAgICByZWplY3QocmVhc29uKTtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgZXJyb3JfMS5DcnRFcnJvcihyZWFzb24pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBfb25fY29ubmVjdGlvbl9pbnRlcnJ1cHRlZChlcnJvcl9jb2RlKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnaW50ZXJydXB0JywgbmV3IGVycm9yXzEuQ3J0RXJyb3IoZXJyb3JfY29kZSkpO1xuICAgIH1cbiAgICBfb25fY29ubmVjdGlvbl9yZXN1bWVkKHJldHVybl9jb2RlLCBzZXNzaW9uX3ByZXNlbnQpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdyZXN1bWUnLCByZXR1cm5fY29kZSwgc2Vzc2lvbl9wcmVzZW50KTtcbiAgICAgICAgbGV0IHN1Y2Nlc3NDYWxsYmFja0RhdGEgPSB7IHNlc3Npb25fcHJlc2VudDogc2Vzc2lvbl9wcmVzZW50LCByZWFzb25fY29kZTogcmV0dXJuX2NvZGUgfTtcbiAgICAgICAgdGhpcy5lbWl0KCdjb25uZWN0aW9uX3N1Y2Nlc3MnLCBzdWNjZXNzQ2FsbGJhY2tEYXRhKTtcbiAgICB9XG4gICAgX29uX2FueV9wdWJsaXNoKHRvcGljLCBwYXlsb2FkLCBkdXAsIHFvcywgcmV0YWluKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIHRvcGljLCBwYXlsb2FkLCBkdXAsIHFvcywgcmV0YWluKTtcbiAgICB9XG4gICAgX29uX2Nvbm5lY3Rpb25fY2xvc2VkKCkge1xuICAgICAgICBsZXQgY2xvc2VkQ2FsbGJhY2tEYXRhID0ge307XG4gICAgICAgIHRoaXMuZW1pdCgnY2xvc2VkJywgY2xvc2VkQ2FsbGJhY2tEYXRhKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdlIGNhbGwgY2xvc2UoKSBoZXJlIGluc3RlYWQgb2Ygb24gZGlzY29ubmVjdCBiZWNhdXNlIG9uX2Nsb3NlIGlzIGFsd2F5cyBjYWxsZWQgQUZURVIgZGlzY29ubmVjdFxuICAgICAgICAgKiBidXQgaWYgd2UgY2FsbCBjbG9zZSgpIGJlZm9yZSwgdGhlbiB3ZSBjYW5ub3QgZW1pdCB0aGUgY2xvc2VkIGNhbGxiYWNrLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH1cbiAgICBfb25fY29ubmVjdF9jYWxsYmFjayhyZXNvbHZlLCByZWplY3QsIGVycm9yX2NvZGUsIHJldHVybl9jb2RlLCBzZXNzaW9uX3ByZXNlbnQpIHtcbiAgICAgICAgaWYgKGVycm9yX2NvZGUgPT0gMCAmJiByZXR1cm5fY29kZSA9PSAwKSB7XG4gICAgICAgICAgICByZXNvbHZlKHNlc3Npb25fcHJlc2VudCk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Nvbm5lY3QnLCBzZXNzaW9uX3ByZXNlbnQpO1xuICAgICAgICAgICAgbGV0IHN1Y2Nlc3NDYWxsYmFja0RhdGEgPSB7IHNlc3Npb25fcHJlc2VudDogc2Vzc2lvbl9wcmVzZW50LCByZWFzb25fY29kZTogcmV0dXJuX2NvZGUgfTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnY29ubmVjdGlvbl9zdWNjZXNzJywgc3VjY2Vzc0NhbGxiYWNrRGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXJyb3JfY29kZSAhPSAwKSB7XG4gICAgICAgICAgICByZWplY3QoXCJGYWlsZWQgdG8gY29ubmVjdDogXCIgKyBpby5lcnJvcl9jb2RlX3RvX3N0cmluZyhlcnJvcl9jb2RlKSk7XG4gICAgICAgICAgICBsZXQgZmFpbHVyZUNhbGxiYWNrRGF0YSA9IHsgZXJyb3I6IG5ldyBlcnJvcl8xLkNydEVycm9yKGVycm9yX2NvZGUpIH07XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Nvbm5lY3Rpb25fZmFpbHVyZScsIGZhaWx1cmVDYWxsYmFja0RhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KFwiU2VydmVyIHJlamVjdGVkIGNvbm5lY3Rpb24uXCIpO1xuICAgICAgICAgICAgbGV0IGZhaWx1cmVDYWxsYmFja0RhdGEgPSB7IGVycm9yOiBuZXcgZXJyb3JfMS5DcnRFcnJvcig1MTM0KSB9OyAvLyA1MTM0ID0gQVdTX0VSUk9SX01RVFRfVU5FWFBFQ1RFRF9IQU5HVVBcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnY29ubmVjdGlvbl9mYWlsdXJlJywgZmFpbHVyZUNhbGxiYWNrRGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX29uX3B1YmFja19jYWxsYmFjayhyZXNvbHZlLCByZWplY3QsIHBhY2tldF9pZCwgZXJyb3JfY29kZSkge1xuICAgICAgICBpZiAoZXJyb3JfY29kZSA9PSAwKSB7XG4gICAgICAgICAgICByZXNvbHZlKHsgcGFja2V0X2lkIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KFwiRmFpbGVkIHRvIHB1Ymxpc2g6IFwiICsgaW8uZXJyb3JfY29kZV90b19zdHJpbmcoZXJyb3JfY29kZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9vbl9zdWJhY2tfY2FsbGJhY2socmVzb2x2ZSwgcmVqZWN0LCBwYWNrZXRfaWQsIHRvcGljLCBxb3MsIGVycm9yX2NvZGUpIHtcbiAgICAgICAgaWYgKGVycm9yX2NvZGUgPT0gMCkge1xuICAgICAgICAgICAgcmVzb2x2ZSh7IHBhY2tldF9pZCwgdG9waWMsIHFvcywgZXJyb3JfY29kZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlamVjdChcIkZhaWxlZCB0byBzdWJzY3JpYmU6IFwiICsgaW8uZXJyb3JfY29kZV90b19zdHJpbmcoZXJyb3JfY29kZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9vbl91bnN1YmFja19jYWxsYmFjayhyZXNvbHZlLCByZWplY3QsIHBhY2tldF9pZCwgZXJyb3JfY29kZSkge1xuICAgICAgICBpZiAoZXJyb3JfY29kZSA9PSAwKSB7XG4gICAgICAgICAgICByZXNvbHZlKHsgcGFja2V0X2lkIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KFwiRmFpbGVkIHRvIHVuc3Vic2NyaWJlOiBcIiArIGlvLmVycm9yX2NvZGVfdG9fc3RyaW5nKGVycm9yX2NvZGUpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfb25fZGlzY29ubmVjdF9jYWxsYmFjayhyZXNvbHZlKSB7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgdGhpcy5lbWl0KCdkaXNjb25uZWN0Jyk7XG4gICAgICAgIC8qKiBOT1RFOiBXZSBhcmUgTk9UIGNhbGxpbmcgY2xvc2UoKSBoZXJlIGJ1dCBpbnN0ZWFkIGNhbGxpbmcgaXQgYXRcbiAgICAgICAgICogb25fY2xvc2VkIGJlY2F1c2UgaXQgaXMgYWx3YXlzIGNhbGxlZCBhZnRlciBkaXNjb25uZWN0ICovXG4gICAgfVxufVxuZXhwb3J0cy5NcXR0Q2xpZW50Q29ubmVjdGlvbiA9IE1xdHRDbGllbnRDb25uZWN0aW9uO1xuLyoqXG4gKiBFbWl0dGVkIHdoZW4gdGhlIGNvbm5lY3Rpb24gc3VjY2Vzc2Z1bGx5IGVzdGFibGlzaGVzIGl0c2VsZiBmb3IgdGhlIGZpcnN0IHRpbWVcbiAqXG4gKiBAZXZlbnRcbiAqL1xuTXF0dENsaWVudENvbm5lY3Rpb24uQ09OTkVDVCA9ICdjb25uZWN0Jztcbi8qKlxuICogRW1pdHRlZCB3aGVuIGNvbm5lY3Rpb24gaGFzIGRpc2Nvbm5lY3RlZCBzdWNjZXNzZnVsbHkuXG4gKlxuICogQGV2ZW50XG4gKi9cbk1xdHRDbGllbnRDb25uZWN0aW9uLkRJU0NPTk5FQ1QgPSAnZGlzY29ubmVjdCc7XG4vKipcbiAqIEVtaXR0ZWQgd2hlbiBhbiBlcnJvciBvY2N1cnMuICBUaGUgZXJyb3Igd2lsbCBjb250YWluIHRoZSBlcnJvclxuICogY29kZSBhbmQgbWVzc2FnZS5cbiAqXG4gKiBAZXZlbnRcbiAqL1xuTXF0dENsaWVudENvbm5lY3Rpb24uRVJST1IgPSAnZXJyb3InO1xuLyoqXG4gKiBFbWl0dGVkIHdoZW4gdGhlIGNvbm5lY3Rpb24gaXMgZHJvcHBlZCB1bmV4cGVjdGVkbHkuIFRoZSBlcnJvciB3aWxsIGNvbnRhaW4gdGhlIGVycm9yXG4gKiBjb2RlIGFuZCBtZXNzYWdlLiAgVGhlIHVuZGVybHlpbmcgbXF0dCBpbXBsZW1lbnRhdGlvbiB3aWxsIGF0dGVtcHQgdG8gcmVjb25uZWN0LlxuICpcbiAqIEBldmVudFxuICovXG5NcXR0Q2xpZW50Q29ubmVjdGlvbi5JTlRFUlJVUFQgPSAnaW50ZXJydXB0Jztcbi8qKlxuICogRW1pdHRlZCB3aGVuIHRoZSBjb25uZWN0aW9uIHJlY29ubmVjdHMgKGFmdGVyIGFuIGludGVycnVwdCkuIE9ubHkgdHJpZ2dlcnMgb24gY29ubmVjdGlvbnMgYWZ0ZXIgdGhlIGluaXRpYWwgb25lLlxuICpcbiAqIEBldmVudFxuICovXG5NcXR0Q2xpZW50Q29ubmVjdGlvbi5SRVNVTUUgPSAncmVzdW1lJztcbi8qKlxuICogRW1pdHRlZCB3aGVuIGFueSBNUVRUIHB1Ymxpc2ggbWVzc2FnZSBhcnJpdmVzLlxuICpcbiAqIEBldmVudFxuICovXG5NcXR0Q2xpZW50Q29ubmVjdGlvbi5NRVNTQUdFID0gJ21lc3NhZ2UnO1xuLyoqXG4gKiBFbWl0dGVkIG9uIGV2ZXJ5IHN1Y2Nlc3NmdWwgY29ubmVjdCBhbmQgcmVjb25uZWN0LlxuICogV2lsbCBjb250YWluIGEgbnVtYmVyIHdpdGggdGhlIGNvbm5lY3Rpb24gcmVhc29uIGNvZGUgYW5kXG4gKiBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBjb25uZWN0aW9uIHJlc3VtZWQgYSBzZXNzaW9uLlxuICpcbiAqIEBldmVudFxuICovXG5NcXR0Q2xpZW50Q29ubmVjdGlvbi5DT05ORUNUSU9OX1NVQ0NFU1MgPSAnY29ubmVjdGlvbl9zdWNjZXNzJztcbi8qKlxuICogRW1pdHRlZCBvbiBhbiB1bnN1Y2Nlc3NmdWwgY29ubmVjdCBhbmQgcmVjb25uZWN0LlxuICogV2lsbCBjb250YWluIGFuIGVycm9yIGNvZGUgaW5kaWNhdGluZyB0aGUgcmVhc29uIGZvciB0aGUgdW5zdWNjZXNzZnVsIGNvbm5lY3Rpb24uXG4gKlxuICogQGV2ZW50XG4gKi9cbk1xdHRDbGllbnRDb25uZWN0aW9uLkNPTk5FQ1RJT05fRkFJTFVSRSA9ICdjb25uZWN0aW9uX2ZhaWx1cmUnO1xuLyoqXG4gKiBFbWl0dGVkIHdoZW4gdGhlIE1RVFQgY29ubmVjdGlvbiB3YXMgZGlzY29ubmVjdGVkIGFuZCBzaHV0ZG93biBzdWNjZXNzZnVsbHkuXG4gKlxuICogQGV2ZW50XG4gKi9cbk1xdHRDbGllbnRDb25uZWN0aW9uLkNMT1NFRCA9ICdjbG9zZWQnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bXF0dC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/aws-crt/dist/native/mqtt.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/aws-crt/dist/native/mqtt5.js":
/*!***************************************************!*\
  !*** ./node_modules/aws-crt/dist/native/mqtt5.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n * SPDX-License-Identifier: Apache-2.0.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Mqtt5Client = exports.ClientExtendedValidationAndFlowControl = exports.ClientOperationQueueBehavior = exports.HttpProxyOptions = void 0;\n/**\n * Node.js specific MQTT5 client implementation\n *\n * DEVELOPER PREVIEW DISCLAIMER\n *\n * MQTT5 support is currently in **developer preview**.  We encourage feedback at all times, but feedback during the\n * preview window is especially valuable in shaping the final product.  During the preview period we may make\n * backwards-incompatible changes to the public API, but in general, this is something we will try our best to avoid.\n *\n * [MQTT5 Client User Guide](https://www.github.com/awslabs/aws-crt-nodejs/blob/main/MQTT5-UserGuide.md)\n *\n * @packageDocumentation\n * @module mqtt5\n * @mergeTarget\n *\n */\nconst binding_1 = __importDefault(__webpack_require__(/*! ./binding */ \"(ssr)/./node_modules/aws-crt/dist/native/binding.js\"));\nconst native_resource_1 = __webpack_require__(/*! ./native_resource */ \"(ssr)/./node_modules/aws-crt/dist/native/native_resource.js\");\nconst event_1 = __webpack_require__(/*! ../common/event */ \"(ssr)/./node_modules/aws-crt/dist/common/event.js\");\nconst io = __importStar(__webpack_require__(/*! ./io */ \"(ssr)/./node_modules/aws-crt/dist/native/io.js\"));\nconst mqtt_shared = __importStar(__webpack_require__(/*! ../common/mqtt_shared */ \"(ssr)/./node_modules/aws-crt/dist/common/mqtt_shared.js\"));\nconst error_1 = __webpack_require__(/*! ./error */ \"(ssr)/./node_modules/aws-crt/dist/native/error.js\");\nvar http_1 = __webpack_require__(/*! ./http */ \"(ssr)/./node_modules/aws-crt/dist/native/http.js\");\nObject.defineProperty(exports, \"HttpProxyOptions\", ({ enumerable: true, get: function () { return http_1.HttpProxyOptions; } }));\n__exportStar(__webpack_require__(/*! ../common/mqtt5 */ \"(ssr)/./node_modules/aws-crt/dist/common/mqtt5.js\"), exports);\n__exportStar(__webpack_require__(/*! ../common/mqtt5_packet */ \"(ssr)/./node_modules/aws-crt/dist/common/mqtt5_packet.js\"), exports);\n;\n/**\n * Controls how disconnects affect the queued and in-progress operations tracked by the client.  Also controls\n * how operations are handled while the client is not connected.  In particular, if the client is not connected,\n * then any operation that would be failed on disconnect (according to these rules) will be rejected.\n */\nvar ClientOperationQueueBehavior;\n(function (ClientOperationQueueBehavior) {\n    /** Same as FailQos0PublishOnDisconnect */\n    ClientOperationQueueBehavior[ClientOperationQueueBehavior[\"Default\"] = 0] = \"Default\";\n    /**\n     * Re-queues QoS 1+ publishes on disconnect; un-acked publishes go to the front while unprocessed publishes stay\n     * in place.  All other operations (QoS 0 publishes, subscribe, unsubscribe) are failed.\n     */\n    ClientOperationQueueBehavior[ClientOperationQueueBehavior[\"FailNonQos1PublishOnDisconnect\"] = 1] = \"FailNonQos1PublishOnDisconnect\";\n    /**\n     * QoS 0 publishes that are not complete at the time of disconnection are failed.  Un-acked QoS 1+ publishes are\n     * re-queued at the head of the line for immediate retransmission on a session resumption.  All other operations\n     * are requeued in original order behind any retransmissions.\n     */\n    ClientOperationQueueBehavior[ClientOperationQueueBehavior[\"FailQos0PublishOnDisconnect\"] = 2] = \"FailQos0PublishOnDisconnect\";\n    /**\n     * All operations that are not complete at the time of disconnection are failed, except operations that\n     * the MQTT5 spec requires to be retransmitted (un-acked QoS1+ publishes).\n     */\n    ClientOperationQueueBehavior[ClientOperationQueueBehavior[\"FailAllOnDisconnect\"] = 3] = \"FailAllOnDisconnect\";\n})(ClientOperationQueueBehavior = exports.ClientOperationQueueBehavior || (exports.ClientOperationQueueBehavior = {}));\n/**\n * Additional controls for client behavior with respect to operation validation and flow control; these checks\n * go beyond the MQTT5 spec to respect limits of specific MQTT brokers.\n */\nvar ClientExtendedValidationAndFlowControl;\n(function (ClientExtendedValidationAndFlowControl) {\n    /**\n     * Do not do any additional validation or flow control\n     */\n    ClientExtendedValidationAndFlowControl[ClientExtendedValidationAndFlowControl[\"None\"] = 0] = \"None\";\n    /**\n     * Apply additional client-side validation and operational flow control that respects the\n     * default AWS IoT Core limits.\n     *\n     * Currently applies the following additional validation:\n     *\n     * 1. No more than 8 subscriptions per SUBSCRIBE packet\n     * 1. Topics and topic filters have a maximum of 7 slashes (8 segments), not counting any AWS rules prefix\n     * 1. Topics must be <= 256 bytes in length\n     * 1. Client id must be <= 128 bytes in length\n     *\n     * Also applies the following flow control:\n     *\n     * 1. Outbound throughput throttled to 512KB/s\n     * 1. Outbound publish TPS throttled to 100\n     */\n    ClientExtendedValidationAndFlowControl[ClientExtendedValidationAndFlowControl[\"AwsIotCoreDefaults\"] = 1] = \"AwsIotCoreDefaults\";\n})(ClientExtendedValidationAndFlowControl = exports.ClientExtendedValidationAndFlowControl || (exports.ClientExtendedValidationAndFlowControl = {}));\n/**\n * Node.js specific MQTT5 client implementation\n *\n * DEVELOPER PREVIEW DISCLAIMER\n *\n * MQTT5 support is currently in **developer preview**.  We encourage feedback at all times, but feedback during the\n * preview window is especially valuable in shaping the final product.  During the preview period we may make\n * backwards-incompatible changes to the public API, but in general, this is something we will try our best to avoid.\n *\n * Not all parts of the MQTT5 spec are supported. We currently do not support:\n *\n * * AUTH packets and the authentication fields in the CONNECT packet\n * * QoS 2\n *\n * [MQTT5 Client User Guide](https://www.github.com/awslabs/aws-crt-nodejs/blob/main/MQTT5-UserGuide.md)\n *\n * This client is based on native resources.  When finished with the client, you must call close() to dispose of\n * them or they will leak.\n *\n */\nclass Mqtt5Client extends (0, native_resource_1.NativeResourceMixin)(event_1.BufferedEventEmitter) {\n    /**\n     * Client constructor\n     *\n     * @param config The configuration for this client\n     */\n    constructor(config) {\n        super();\n        this._super(binding_1.default.mqtt5_client_new(this, config, (client) => { Mqtt5Client._s_on_stopped(client); }, (client) => { Mqtt5Client._s_on_attempting_connect(client); }, (client, connack, settings) => { Mqtt5Client._s_on_connection_success(client, connack, settings); }, (client, errorCode, connack) => { Mqtt5Client._s_on_connection_failure(client, new error_1.CrtError(errorCode), connack); }, (client, errorCode, disconnect) => { Mqtt5Client._s_on_disconnection(client, new error_1.CrtError(errorCode), disconnect); }, (client, message) => { Mqtt5Client._s_on_message_received(client, message); }, config.clientBootstrap ? config.clientBootstrap.native_handle() : null, config.socketOptions ? config.socketOptions.native_handle() : null, config.tlsCtx ? config.tlsCtx.native_handle() : null, config.httpProxyOptions ? config.httpProxyOptions.create_native_handle() : null));\n    }\n    /**\n     * Triggers cleanup of native resources associated with the MQTT5 client.  Once this has been invoked, callbacks\n     * and events are not guaranteed to be received.\n     *\n     * This must be called when finished with a client; otherwise, native resources will leak.  It is not safe\n     * to invoke any further operations on the client after close() has been called.\n     *\n     * For a running client, safe and proper shutdown can be accomplished by\n     *\n     * ```ts\n     * const stopped = once(client, \"stopped\");\n     * client.stop();\n     * await stopped;\n     * client.close();\n     * ```\n     *\n     * This is an asynchronous operation.\n     *\n     * @group Node-only\n     */\n    close() {\n        binding_1.default.mqtt5_client_close(this.native_handle());\n    }\n    /**\n     * Notifies the MQTT5 client that you want it to maintain connectivity to the configured endpoint.\n     * The client will attempt to stay connected using the properties of the reconnect-related parameters\n     * in the mqtt5 client configuration.\n     *\n     * This is an asynchronous operation.\n     */\n    start() {\n        binding_1.default.mqtt5_client_start(this.native_handle());\n    }\n    /**\n     * Notifies the MQTT5 client that you want it to end connectivity to the configured endpoint, disconnecting any\n     * existing connection and halting reconnection attempts.\n     *\n     * This is an asynchronous operation.  Once the process completes, no further events will be emitted until the client\n     * has {@link start} invoked.  Invoking {@link start start()} after a {@link stop stop()} will always result in a\n     * new MQTT session.\n     *\n     * @param disconnectPacket (optional) properties of a DISCONNECT packet to send as part of the shutdown process\n     */\n    stop(disconnectPacket) {\n        binding_1.default.mqtt5_client_stop(this.native_handle(), disconnectPacket);\n    }\n    /**\n     * Subscribe to one or more topic filters by queuing a SUBSCRIBE packet to be sent to the server.\n     *\n     * @param packet SUBSCRIBE packet to send to the server\n     * @returns a promise that will be rejected with an error or resolved with the SUBACK response\n     */\n    subscribe(packet) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                function curriedPromiseCallback(client, errorCode, suback) {\n                    return Mqtt5Client._s_on_suback_callback(resolve, reject, client, errorCode, suback);\n                }\n                try {\n                    binding_1.default.mqtt5_client_subscribe(this.native_handle(), packet, curriedPromiseCallback);\n                }\n                catch (e) {\n                    reject(e);\n                }\n            });\n        });\n    }\n    /**\n     * Unsubscribe from one or more topic filters by queuing an UNSUBSCRIBE packet to be sent to the server.\n     *\n     * @param packet UNSUBSCRIBE packet to send to the server\n     * @returns a promise that will be rejected with an error or resolved with the UNSUBACK response\n     */\n    unsubscribe(packet) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                function curriedPromiseCallback(client, errorCode, unsuback) {\n                    return Mqtt5Client._s_on_unsuback_callback(resolve, reject, client, errorCode, unsuback);\n                }\n                try {\n                    binding_1.default.mqtt5_client_unsubscribe(this.native_handle(), packet, curriedPromiseCallback);\n                }\n                catch (e) {\n                    reject(e);\n                }\n            });\n        });\n    }\n    /**\n     * Send a message to subscribing clients by queuing a PUBLISH packet to be sent to the server.\n     *\n     * @param packet PUBLISH packet to send to the server\n     * @returns a promise that will be rejected with an error or resolved with the PUBACK response (QoS 1) or\n     * undefined (QoS 0)\n     */\n    publish(packet) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                if (packet && packet.payload) {\n                    packet.payload = mqtt_shared.normalize_payload(packet.payload);\n                }\n                function curriedPromiseCallback(client, errorCode, result) {\n                    return Mqtt5Client._s_on_puback_callback(resolve, reject, client, errorCode, result);\n                }\n                try {\n                    binding_1.default.mqtt5_client_publish(this.native_handle(), packet, curriedPromiseCallback);\n                }\n                catch (e) {\n                    reject(e);\n                }\n            });\n        });\n    }\n    /**\n     * Queries a small set of numerical statistics about the current state of the client's operation queue\n     *\n     * @group Node-only\n     */\n    getQueueStatistics() {\n        return binding_1.default.mqtt5_client_get_queue_statistics(this.native_handle());\n    }\n    on(event, listener) {\n        super.on(event, listener);\n        return this;\n    }\n    /*\n     * Private helper functions\n     *\n     * Callbacks come through static functions so that the native threadsafe function objects do not\n     * capture the client object itself, simplifying the number of strong references to the client floating around.\n     */\n    static _s_on_stopped(client) {\n        process.nextTick(() => {\n            let stoppedEvent = {};\n            client.emit(Mqtt5Client.STOPPED, stoppedEvent);\n        });\n    }\n    static _s_on_attempting_connect(client) {\n        process.nextTick(() => {\n            let attemptingConnectEvent = {};\n            client.emit(Mqtt5Client.ATTEMPTING_CONNECT, attemptingConnectEvent);\n        });\n    }\n    static _s_on_connection_success(client, connack, settings) {\n        let connectionSuccessEvent = {\n            connack: connack,\n            settings: settings\n        };\n        process.nextTick(() => {\n            client.emit(Mqtt5Client.CONNECTION_SUCCESS, connectionSuccessEvent);\n        });\n    }\n    static _s_on_connection_failure(client, error, connack) {\n        let connectionFailureEvent = {\n            error: error\n        };\n        if (connack !== null && connack !== undefined) {\n            connectionFailureEvent.connack = connack;\n        }\n        process.nextTick(() => {\n            client.emit(Mqtt5Client.CONNECTION_FAILURE, connectionFailureEvent);\n        });\n    }\n    static _s_on_disconnection(client, error, disconnect) {\n        let disconnectionEvent = {\n            error: error\n        };\n        if (disconnect !== null && disconnect !== undefined) {\n            disconnectionEvent.disconnect = disconnect;\n        }\n        process.nextTick(() => {\n            client.emit(Mqtt5Client.DISCONNECTION, disconnectionEvent);\n        });\n    }\n    static _s_on_suback_callback(resolve, reject, client, errorCode, suback) {\n        if (errorCode == 0 && suback !== undefined) {\n            resolve(suback);\n        }\n        else {\n            reject(io.error_code_to_string(errorCode));\n        }\n    }\n    static _s_on_unsuback_callback(resolve, reject, client, errorCode, unsuback) {\n        if (errorCode == 0 && unsuback !== undefined) {\n            resolve(unsuback);\n        }\n        else {\n            reject(io.error_code_to_string(errorCode));\n        }\n    }\n    static _s_on_puback_callback(resolve, reject, client, errorCode, result) {\n        if (errorCode == 0) {\n            resolve(result);\n        }\n        else {\n            reject(io.error_code_to_string(errorCode));\n        }\n    }\n    static _s_on_message_received(client, message) {\n        let messageReceivedEvent = {\n            message: message\n        };\n        process.nextTick(() => {\n            client.emit(Mqtt5Client.MESSAGE_RECEIVED, messageReceivedEvent);\n        });\n    }\n}\nexports.Mqtt5Client = Mqtt5Client;\n/**\n * Event emitted when the client encounters a serious error condition, such as invalid input, napi failures, and\n * other potentially unrecoverable situations.\n *\n * Listener type: {@link ErrorEventListener}\n *\n * @event\n */\nMqtt5Client.ERROR = 'error';\n/**\n * Event emitted when an MQTT PUBLISH packet is received by the client.\n *\n * Listener type: {@link MessageReceivedEventListener}\n *\n * @event\n */\nMqtt5Client.MESSAGE_RECEIVED = 'messageReceived';\n/**\n * Event emitted when the client begins a connection attempt.\n *\n * Listener type: {@link AttemptingConnectEventListener}\n *\n * @event\n */\nMqtt5Client.ATTEMPTING_CONNECT = 'attemptingConnect';\n/**\n * Event emitted when the client successfully establishes an MQTT connection.  Only emitted after\n * an {@link ATTEMPTING_CONNECT attemptingConnect} event.\n *\n * Listener type: {@link ConnectionSuccessEventListener}\n *\n * @event\n */\nMqtt5Client.CONNECTION_SUCCESS = 'connectionSuccess';\n/**\n * Event emitted when the client fails to establish an MQTT connection.  Only emitted after\n * an {@link ATTEMPTING_CONNECT attemptingConnect} event.\n *\n * Listener type: {@link ConnectionFailureEventListener}\n *\n * @event\n */\nMqtt5Client.CONNECTION_FAILURE = 'connectionFailure';\n/**\n * Event emitted when the client's current connection is closed for any reason.  Only emitted after\n * a {@link CONNECTION_SUCCESS connectionSuccess} event.\n *\n * Listener type: {@link DisconnectionEventListener}\n *\n * @event\n */\nMqtt5Client.DISCONNECTION = 'disconnection';\n/**\n * Event emitted when the client finishes shutdown as a result of the user invoking {@link stop}.\n *\n * Listener type: {@link StoppedEventListener}\n *\n * @event\n */\nMqtt5Client.STOPPED = 'stopped';\n//# sourceMappingURL=mqtt5.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXdzLWNydC9kaXN0L25hdGl2ZS9tcXR0NS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUIsR0FBRyw4Q0FBOEMsR0FBRyxvQ0FBb0MsR0FBRyx3QkFBd0I7QUFDdEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsbUJBQU8sQ0FBQyxzRUFBVztBQUNyRCwwQkFBMEIsbUJBQU8sQ0FBQyxzRkFBbUI7QUFDckQsZ0JBQWdCLG1CQUFPLENBQUMsMEVBQWlCO0FBQ3pDLHdCQUF3QixtQkFBTyxDQUFDLDREQUFNO0FBQ3RDLGlDQUFpQyxtQkFBTyxDQUFDLHNGQUF1QjtBQUNoRSxnQkFBZ0IsbUJBQU8sQ0FBQyxrRUFBUztBQUNqQyxhQUFhLG1CQUFPLENBQUMsZ0VBQVE7QUFDN0Isb0RBQW1ELEVBQUUscUNBQXFDLG1DQUFtQyxFQUFDO0FBQzlILGFBQWEsbUJBQU8sQ0FBQywwRUFBaUI7QUFDdEMsYUFBYSxtQkFBTyxDQUFDLHdGQUF3QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBFQUEwRSxvQ0FBb0MsS0FBSztBQUNwSDtBQUNBLGtHQUFrRztBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEZBQThGLDhDQUE4QyxLQUFLO0FBQ2xKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLG9DQUFvQyxnQkFBZ0IsK0NBQStDLG1DQUFtQyxrRUFBa0Usb0NBQW9DLHlGQUF5Rix1Q0FBdUMsdUZBQXVGLHlCQUF5QixzREFBc0Q7QUFDcm1CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhLG9CQUFvQixxQkFBcUIsU0FBUyxtQkFBbUI7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sNENBQTRDO0FBQ25EO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sNENBQTRDO0FBQ25EO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sNENBQTRDO0FBQ2xEO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYsV0FBVztBQUNoRztBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGF5d2luZC8uL25vZGVfbW9kdWxlcy9hd3MtY3J0L2Rpc3QvbmF0aXZlL21xdHQ1LmpzPzkzMDgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IEFtYXpvbi5jb20sIEluYy4gb3IgaXRzIGFmZmlsaWF0ZXMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMC5cbiAqL1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1xdHQ1Q2xpZW50ID0gZXhwb3J0cy5DbGllbnRFeHRlbmRlZFZhbGlkYXRpb25BbmRGbG93Q29udHJvbCA9IGV4cG9ydHMuQ2xpZW50T3BlcmF0aW9uUXVldWVCZWhhdmlvciA9IGV4cG9ydHMuSHR0cFByb3h5T3B0aW9ucyA9IHZvaWQgMDtcbi8qKlxuICogTm9kZS5qcyBzcGVjaWZpYyBNUVRUNSBjbGllbnQgaW1wbGVtZW50YXRpb25cbiAqXG4gKiBERVZFTE9QRVIgUFJFVklFVyBESVNDTEFJTUVSXG4gKlxuICogTVFUVDUgc3VwcG9ydCBpcyBjdXJyZW50bHkgaW4gKipkZXZlbG9wZXIgcHJldmlldyoqLiAgV2UgZW5jb3VyYWdlIGZlZWRiYWNrIGF0IGFsbCB0aW1lcywgYnV0IGZlZWRiYWNrIGR1cmluZyB0aGVcbiAqIHByZXZpZXcgd2luZG93IGlzIGVzcGVjaWFsbHkgdmFsdWFibGUgaW4gc2hhcGluZyB0aGUgZmluYWwgcHJvZHVjdC4gIER1cmluZyB0aGUgcHJldmlldyBwZXJpb2Qgd2UgbWF5IG1ha2VcbiAqIGJhY2t3YXJkcy1pbmNvbXBhdGlibGUgY2hhbmdlcyB0byB0aGUgcHVibGljIEFQSSwgYnV0IGluIGdlbmVyYWwsIHRoaXMgaXMgc29tZXRoaW5nIHdlIHdpbGwgdHJ5IG91ciBiZXN0IHRvIGF2b2lkLlxuICpcbiAqIFtNUVRUNSBDbGllbnQgVXNlciBHdWlkZV0oaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9hd3NsYWJzL2F3cy1jcnQtbm9kZWpzL2Jsb2IvbWFpbi9NUVRUNS1Vc2VyR3VpZGUubWQpXG4gKlxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKiBAbW9kdWxlIG1xdHQ1XG4gKiBAbWVyZ2VUYXJnZXRcbiAqXG4gKi9cbmNvbnN0IGJpbmRpbmdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9iaW5kaW5nXCIpKTtcbmNvbnN0IG5hdGl2ZV9yZXNvdXJjZV8xID0gcmVxdWlyZShcIi4vbmF0aXZlX3Jlc291cmNlXCIpO1xuY29uc3QgZXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vZXZlbnRcIik7XG5jb25zdCBpbyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9pb1wiKSk7XG5jb25zdCBtcXR0X3NoYXJlZCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vY29tbW9uL21xdHRfc2hhcmVkXCIpKTtcbmNvbnN0IGVycm9yXzEgPSByZXF1aXJlKFwiLi9lcnJvclwiKTtcbnZhciBodHRwXzEgPSByZXF1aXJlKFwiLi9odHRwXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSHR0cFByb3h5T3B0aW9uc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaHR0cF8xLkh0dHBQcm94eU9wdGlvbnM7IH0gfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4uL2NvbW1vbi9tcXR0NVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4uL2NvbW1vbi9tcXR0NV9wYWNrZXRcIiksIGV4cG9ydHMpO1xuO1xuLyoqXG4gKiBDb250cm9scyBob3cgZGlzY29ubmVjdHMgYWZmZWN0IHRoZSBxdWV1ZWQgYW5kIGluLXByb2dyZXNzIG9wZXJhdGlvbnMgdHJhY2tlZCBieSB0aGUgY2xpZW50LiAgQWxzbyBjb250cm9sc1xuICogaG93IG9wZXJhdGlvbnMgYXJlIGhhbmRsZWQgd2hpbGUgdGhlIGNsaWVudCBpcyBub3QgY29ubmVjdGVkLiAgSW4gcGFydGljdWxhciwgaWYgdGhlIGNsaWVudCBpcyBub3QgY29ubmVjdGVkLFxuICogdGhlbiBhbnkgb3BlcmF0aW9uIHRoYXQgd291bGQgYmUgZmFpbGVkIG9uIGRpc2Nvbm5lY3QgKGFjY29yZGluZyB0byB0aGVzZSBydWxlcykgd2lsbCBiZSByZWplY3RlZC5cbiAqL1xudmFyIENsaWVudE9wZXJhdGlvblF1ZXVlQmVoYXZpb3I7XG4oZnVuY3Rpb24gKENsaWVudE9wZXJhdGlvblF1ZXVlQmVoYXZpb3IpIHtcbiAgICAvKiogU2FtZSBhcyBGYWlsUW9zMFB1Ymxpc2hPbkRpc2Nvbm5lY3QgKi9cbiAgICBDbGllbnRPcGVyYXRpb25RdWV1ZUJlaGF2aW9yW0NsaWVudE9wZXJhdGlvblF1ZXVlQmVoYXZpb3JbXCJEZWZhdWx0XCJdID0gMF0gPSBcIkRlZmF1bHRcIjtcbiAgICAvKipcbiAgICAgKiBSZS1xdWV1ZXMgUW9TIDErIHB1Ymxpc2hlcyBvbiBkaXNjb25uZWN0OyB1bi1hY2tlZCBwdWJsaXNoZXMgZ28gdG8gdGhlIGZyb250IHdoaWxlIHVucHJvY2Vzc2VkIHB1Ymxpc2hlcyBzdGF5XG4gICAgICogaW4gcGxhY2UuICBBbGwgb3RoZXIgb3BlcmF0aW9ucyAoUW9TIDAgcHVibGlzaGVzLCBzdWJzY3JpYmUsIHVuc3Vic2NyaWJlKSBhcmUgZmFpbGVkLlxuICAgICAqL1xuICAgIENsaWVudE9wZXJhdGlvblF1ZXVlQmVoYXZpb3JbQ2xpZW50T3BlcmF0aW9uUXVldWVCZWhhdmlvcltcIkZhaWxOb25Rb3MxUHVibGlzaE9uRGlzY29ubmVjdFwiXSA9IDFdID0gXCJGYWlsTm9uUW9zMVB1Ymxpc2hPbkRpc2Nvbm5lY3RcIjtcbiAgICAvKipcbiAgICAgKiBRb1MgMCBwdWJsaXNoZXMgdGhhdCBhcmUgbm90IGNvbXBsZXRlIGF0IHRoZSB0aW1lIG9mIGRpc2Nvbm5lY3Rpb24gYXJlIGZhaWxlZC4gIFVuLWFja2VkIFFvUyAxKyBwdWJsaXNoZXMgYXJlXG4gICAgICogcmUtcXVldWVkIGF0IHRoZSBoZWFkIG9mIHRoZSBsaW5lIGZvciBpbW1lZGlhdGUgcmV0cmFuc21pc3Npb24gb24gYSBzZXNzaW9uIHJlc3VtcHRpb24uICBBbGwgb3RoZXIgb3BlcmF0aW9uc1xuICAgICAqIGFyZSByZXF1ZXVlZCBpbiBvcmlnaW5hbCBvcmRlciBiZWhpbmQgYW55IHJldHJhbnNtaXNzaW9ucy5cbiAgICAgKi9cbiAgICBDbGllbnRPcGVyYXRpb25RdWV1ZUJlaGF2aW9yW0NsaWVudE9wZXJhdGlvblF1ZXVlQmVoYXZpb3JbXCJGYWlsUW9zMFB1Ymxpc2hPbkRpc2Nvbm5lY3RcIl0gPSAyXSA9IFwiRmFpbFFvczBQdWJsaXNoT25EaXNjb25uZWN0XCI7XG4gICAgLyoqXG4gICAgICogQWxsIG9wZXJhdGlvbnMgdGhhdCBhcmUgbm90IGNvbXBsZXRlIGF0IHRoZSB0aW1lIG9mIGRpc2Nvbm5lY3Rpb24gYXJlIGZhaWxlZCwgZXhjZXB0IG9wZXJhdGlvbnMgdGhhdFxuICAgICAqIHRoZSBNUVRUNSBzcGVjIHJlcXVpcmVzIHRvIGJlIHJldHJhbnNtaXR0ZWQgKHVuLWFja2VkIFFvUzErIHB1Ymxpc2hlcykuXG4gICAgICovXG4gICAgQ2xpZW50T3BlcmF0aW9uUXVldWVCZWhhdmlvcltDbGllbnRPcGVyYXRpb25RdWV1ZUJlaGF2aW9yW1wiRmFpbEFsbE9uRGlzY29ubmVjdFwiXSA9IDNdID0gXCJGYWlsQWxsT25EaXNjb25uZWN0XCI7XG59KShDbGllbnRPcGVyYXRpb25RdWV1ZUJlaGF2aW9yID0gZXhwb3J0cy5DbGllbnRPcGVyYXRpb25RdWV1ZUJlaGF2aW9yIHx8IChleHBvcnRzLkNsaWVudE9wZXJhdGlvblF1ZXVlQmVoYXZpb3IgPSB7fSkpO1xuLyoqXG4gKiBBZGRpdGlvbmFsIGNvbnRyb2xzIGZvciBjbGllbnQgYmVoYXZpb3Igd2l0aCByZXNwZWN0IHRvIG9wZXJhdGlvbiB2YWxpZGF0aW9uIGFuZCBmbG93IGNvbnRyb2w7IHRoZXNlIGNoZWNrc1xuICogZ28gYmV5b25kIHRoZSBNUVRUNSBzcGVjIHRvIHJlc3BlY3QgbGltaXRzIG9mIHNwZWNpZmljIE1RVFQgYnJva2Vycy5cbiAqL1xudmFyIENsaWVudEV4dGVuZGVkVmFsaWRhdGlvbkFuZEZsb3dDb250cm9sO1xuKGZ1bmN0aW9uIChDbGllbnRFeHRlbmRlZFZhbGlkYXRpb25BbmRGbG93Q29udHJvbCkge1xuICAgIC8qKlxuICAgICAqIERvIG5vdCBkbyBhbnkgYWRkaXRpb25hbCB2YWxpZGF0aW9uIG9yIGZsb3cgY29udHJvbFxuICAgICAqL1xuICAgIENsaWVudEV4dGVuZGVkVmFsaWRhdGlvbkFuZEZsb3dDb250cm9sW0NsaWVudEV4dGVuZGVkVmFsaWRhdGlvbkFuZEZsb3dDb250cm9sW1wiTm9uZVwiXSA9IDBdID0gXCJOb25lXCI7XG4gICAgLyoqXG4gICAgICogQXBwbHkgYWRkaXRpb25hbCBjbGllbnQtc2lkZSB2YWxpZGF0aW9uIGFuZCBvcGVyYXRpb25hbCBmbG93IGNvbnRyb2wgdGhhdCByZXNwZWN0cyB0aGVcbiAgICAgKiBkZWZhdWx0IEFXUyBJb1QgQ29yZSBsaW1pdHMuXG4gICAgICpcbiAgICAgKiBDdXJyZW50bHkgYXBwbGllcyB0aGUgZm9sbG93aW5nIGFkZGl0aW9uYWwgdmFsaWRhdGlvbjpcbiAgICAgKlxuICAgICAqIDEuIE5vIG1vcmUgdGhhbiA4IHN1YnNjcmlwdGlvbnMgcGVyIFNVQlNDUklCRSBwYWNrZXRcbiAgICAgKiAxLiBUb3BpY3MgYW5kIHRvcGljIGZpbHRlcnMgaGF2ZSBhIG1heGltdW0gb2YgNyBzbGFzaGVzICg4IHNlZ21lbnRzKSwgbm90IGNvdW50aW5nIGFueSBBV1MgcnVsZXMgcHJlZml4XG4gICAgICogMS4gVG9waWNzIG11c3QgYmUgPD0gMjU2IGJ5dGVzIGluIGxlbmd0aFxuICAgICAqIDEuIENsaWVudCBpZCBtdXN0IGJlIDw9IDEyOCBieXRlcyBpbiBsZW5ndGhcbiAgICAgKlxuICAgICAqIEFsc28gYXBwbGllcyB0aGUgZm9sbG93aW5nIGZsb3cgY29udHJvbDpcbiAgICAgKlxuICAgICAqIDEuIE91dGJvdW5kIHRocm91Z2hwdXQgdGhyb3R0bGVkIHRvIDUxMktCL3NcbiAgICAgKiAxLiBPdXRib3VuZCBwdWJsaXNoIFRQUyB0aHJvdHRsZWQgdG8gMTAwXG4gICAgICovXG4gICAgQ2xpZW50RXh0ZW5kZWRWYWxpZGF0aW9uQW5kRmxvd0NvbnRyb2xbQ2xpZW50RXh0ZW5kZWRWYWxpZGF0aW9uQW5kRmxvd0NvbnRyb2xbXCJBd3NJb3RDb3JlRGVmYXVsdHNcIl0gPSAxXSA9IFwiQXdzSW90Q29yZURlZmF1bHRzXCI7XG59KShDbGllbnRFeHRlbmRlZFZhbGlkYXRpb25BbmRGbG93Q29udHJvbCA9IGV4cG9ydHMuQ2xpZW50RXh0ZW5kZWRWYWxpZGF0aW9uQW5kRmxvd0NvbnRyb2wgfHwgKGV4cG9ydHMuQ2xpZW50RXh0ZW5kZWRWYWxpZGF0aW9uQW5kRmxvd0NvbnRyb2wgPSB7fSkpO1xuLyoqXG4gKiBOb2RlLmpzIHNwZWNpZmljIE1RVFQ1IGNsaWVudCBpbXBsZW1lbnRhdGlvblxuICpcbiAqIERFVkVMT1BFUiBQUkVWSUVXIERJU0NMQUlNRVJcbiAqXG4gKiBNUVRUNSBzdXBwb3J0IGlzIGN1cnJlbnRseSBpbiAqKmRldmVsb3BlciBwcmV2aWV3KiouICBXZSBlbmNvdXJhZ2UgZmVlZGJhY2sgYXQgYWxsIHRpbWVzLCBidXQgZmVlZGJhY2sgZHVyaW5nIHRoZVxuICogcHJldmlldyB3aW5kb3cgaXMgZXNwZWNpYWxseSB2YWx1YWJsZSBpbiBzaGFwaW5nIHRoZSBmaW5hbCBwcm9kdWN0LiAgRHVyaW5nIHRoZSBwcmV2aWV3IHBlcmlvZCB3ZSBtYXkgbWFrZVxuICogYmFja3dhcmRzLWluY29tcGF0aWJsZSBjaGFuZ2VzIHRvIHRoZSBwdWJsaWMgQVBJLCBidXQgaW4gZ2VuZXJhbCwgdGhpcyBpcyBzb21ldGhpbmcgd2Ugd2lsbCB0cnkgb3VyIGJlc3QgdG8gYXZvaWQuXG4gKlxuICogTm90IGFsbCBwYXJ0cyBvZiB0aGUgTVFUVDUgc3BlYyBhcmUgc3VwcG9ydGVkLiBXZSBjdXJyZW50bHkgZG8gbm90IHN1cHBvcnQ6XG4gKlxuICogKiBBVVRIIHBhY2tldHMgYW5kIHRoZSBhdXRoZW50aWNhdGlvbiBmaWVsZHMgaW4gdGhlIENPTk5FQ1QgcGFja2V0XG4gKiAqIFFvUyAyXG4gKlxuICogW01RVFQ1IENsaWVudCBVc2VyIEd1aWRlXShodHRwczovL3d3dy5naXRodWIuY29tL2F3c2xhYnMvYXdzLWNydC1ub2RlanMvYmxvYi9tYWluL01RVFQ1LVVzZXJHdWlkZS5tZClcbiAqXG4gKiBUaGlzIGNsaWVudCBpcyBiYXNlZCBvbiBuYXRpdmUgcmVzb3VyY2VzLiAgV2hlbiBmaW5pc2hlZCB3aXRoIHRoZSBjbGllbnQsIHlvdSBtdXN0IGNhbGwgY2xvc2UoKSB0byBkaXNwb3NlIG9mXG4gKiB0aGVtIG9yIHRoZXkgd2lsbCBsZWFrLlxuICpcbiAqL1xuY2xhc3MgTXF0dDVDbGllbnQgZXh0ZW5kcyAoMCwgbmF0aXZlX3Jlc291cmNlXzEuTmF0aXZlUmVzb3VyY2VNaXhpbikoZXZlbnRfMS5CdWZmZXJlZEV2ZW50RW1pdHRlcikge1xuICAgIC8qKlxuICAgICAqIENsaWVudCBjb25zdHJ1Y3RvclxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbmZpZyBUaGUgY29uZmlndXJhdGlvbiBmb3IgdGhpcyBjbGllbnRcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fc3VwZXIoYmluZGluZ18xLmRlZmF1bHQubXF0dDVfY2xpZW50X25ldyh0aGlzLCBjb25maWcsIChjbGllbnQpID0+IHsgTXF0dDVDbGllbnQuX3Nfb25fc3RvcHBlZChjbGllbnQpOyB9LCAoY2xpZW50KSA9PiB7IE1xdHQ1Q2xpZW50Ll9zX29uX2F0dGVtcHRpbmdfY29ubmVjdChjbGllbnQpOyB9LCAoY2xpZW50LCBjb25uYWNrLCBzZXR0aW5ncykgPT4geyBNcXR0NUNsaWVudC5fc19vbl9jb25uZWN0aW9uX3N1Y2Nlc3MoY2xpZW50LCBjb25uYWNrLCBzZXR0aW5ncyk7IH0sIChjbGllbnQsIGVycm9yQ29kZSwgY29ubmFjaykgPT4geyBNcXR0NUNsaWVudC5fc19vbl9jb25uZWN0aW9uX2ZhaWx1cmUoY2xpZW50LCBuZXcgZXJyb3JfMS5DcnRFcnJvcihlcnJvckNvZGUpLCBjb25uYWNrKTsgfSwgKGNsaWVudCwgZXJyb3JDb2RlLCBkaXNjb25uZWN0KSA9PiB7IE1xdHQ1Q2xpZW50Ll9zX29uX2Rpc2Nvbm5lY3Rpb24oY2xpZW50LCBuZXcgZXJyb3JfMS5DcnRFcnJvcihlcnJvckNvZGUpLCBkaXNjb25uZWN0KTsgfSwgKGNsaWVudCwgbWVzc2FnZSkgPT4geyBNcXR0NUNsaWVudC5fc19vbl9tZXNzYWdlX3JlY2VpdmVkKGNsaWVudCwgbWVzc2FnZSk7IH0sIGNvbmZpZy5jbGllbnRCb290c3RyYXAgPyBjb25maWcuY2xpZW50Qm9vdHN0cmFwLm5hdGl2ZV9oYW5kbGUoKSA6IG51bGwsIGNvbmZpZy5zb2NrZXRPcHRpb25zID8gY29uZmlnLnNvY2tldE9wdGlvbnMubmF0aXZlX2hhbmRsZSgpIDogbnVsbCwgY29uZmlnLnRsc0N0eCA/IGNvbmZpZy50bHNDdHgubmF0aXZlX2hhbmRsZSgpIDogbnVsbCwgY29uZmlnLmh0dHBQcm94eU9wdGlvbnMgPyBjb25maWcuaHR0cFByb3h5T3B0aW9ucy5jcmVhdGVfbmF0aXZlX2hhbmRsZSgpIDogbnVsbCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VycyBjbGVhbnVwIG9mIG5hdGl2ZSByZXNvdXJjZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBNUVRUNSBjbGllbnQuICBPbmNlIHRoaXMgaGFzIGJlZW4gaW52b2tlZCwgY2FsbGJhY2tzXG4gICAgICogYW5kIGV2ZW50cyBhcmUgbm90IGd1YXJhbnRlZWQgdG8gYmUgcmVjZWl2ZWQuXG4gICAgICpcbiAgICAgKiBUaGlzIG11c3QgYmUgY2FsbGVkIHdoZW4gZmluaXNoZWQgd2l0aCBhIGNsaWVudDsgb3RoZXJ3aXNlLCBuYXRpdmUgcmVzb3VyY2VzIHdpbGwgbGVhay4gIEl0IGlzIG5vdCBzYWZlXG4gICAgICogdG8gaW52b2tlIGFueSBmdXJ0aGVyIG9wZXJhdGlvbnMgb24gdGhlIGNsaWVudCBhZnRlciBjbG9zZSgpIGhhcyBiZWVuIGNhbGxlZC5cbiAgICAgKlxuICAgICAqIEZvciBhIHJ1bm5pbmcgY2xpZW50LCBzYWZlIGFuZCBwcm9wZXIgc2h1dGRvd24gY2FuIGJlIGFjY29tcGxpc2hlZCBieVxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBzdG9wcGVkID0gb25jZShjbGllbnQsIFwic3RvcHBlZFwiKTtcbiAgICAgKiBjbGllbnQuc3RvcCgpO1xuICAgICAqIGF3YWl0IHN0b3BwZWQ7XG4gICAgICogY2xpZW50LmNsb3NlKCk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIGFuIGFzeW5jaHJvbm91cyBvcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAZ3JvdXAgTm9kZS1vbmx5XG4gICAgICovXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGJpbmRpbmdfMS5kZWZhdWx0Lm1xdHQ1X2NsaWVudF9jbG9zZSh0aGlzLm5hdGl2ZV9oYW5kbGUoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vdGlmaWVzIHRoZSBNUVRUNSBjbGllbnQgdGhhdCB5b3Ugd2FudCBpdCB0byBtYWludGFpbiBjb25uZWN0aXZpdHkgdG8gdGhlIGNvbmZpZ3VyZWQgZW5kcG9pbnQuXG4gICAgICogVGhlIGNsaWVudCB3aWxsIGF0dGVtcHQgdG8gc3RheSBjb25uZWN0ZWQgdXNpbmcgdGhlIHByb3BlcnRpZXMgb2YgdGhlIHJlY29ubmVjdC1yZWxhdGVkIHBhcmFtZXRlcnNcbiAgICAgKiBpbiB0aGUgbXF0dDUgY2xpZW50IGNvbmZpZ3VyYXRpb24uXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIGFuIGFzeW5jaHJvbm91cyBvcGVyYXRpb24uXG4gICAgICovXG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGJpbmRpbmdfMS5kZWZhdWx0Lm1xdHQ1X2NsaWVudF9zdGFydCh0aGlzLm5hdGl2ZV9oYW5kbGUoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vdGlmaWVzIHRoZSBNUVRUNSBjbGllbnQgdGhhdCB5b3Ugd2FudCBpdCB0byBlbmQgY29ubmVjdGl2aXR5IHRvIHRoZSBjb25maWd1cmVkIGVuZHBvaW50LCBkaXNjb25uZWN0aW5nIGFueVxuICAgICAqIGV4aXN0aW5nIGNvbm5lY3Rpb24gYW5kIGhhbHRpbmcgcmVjb25uZWN0aW9uIGF0dGVtcHRzLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBhbiBhc3luY2hyb25vdXMgb3BlcmF0aW9uLiAgT25jZSB0aGUgcHJvY2VzcyBjb21wbGV0ZXMsIG5vIGZ1cnRoZXIgZXZlbnRzIHdpbGwgYmUgZW1pdHRlZCB1bnRpbCB0aGUgY2xpZW50XG4gICAgICogaGFzIHtAbGluayBzdGFydH0gaW52b2tlZC4gIEludm9raW5nIHtAbGluayBzdGFydCBzdGFydCgpfSBhZnRlciBhIHtAbGluayBzdG9wIHN0b3AoKX0gd2lsbCBhbHdheXMgcmVzdWx0IGluIGFcbiAgICAgKiBuZXcgTVFUVCBzZXNzaW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRpc2Nvbm5lY3RQYWNrZXQgKG9wdGlvbmFsKSBwcm9wZXJ0aWVzIG9mIGEgRElTQ09OTkVDVCBwYWNrZXQgdG8gc2VuZCBhcyBwYXJ0IG9mIHRoZSBzaHV0ZG93biBwcm9jZXNzXG4gICAgICovXG4gICAgc3RvcChkaXNjb25uZWN0UGFja2V0KSB7XG4gICAgICAgIGJpbmRpbmdfMS5kZWZhdWx0Lm1xdHQ1X2NsaWVudF9zdG9wKHRoaXMubmF0aXZlX2hhbmRsZSgpLCBkaXNjb25uZWN0UGFja2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlIHRvIG9uZSBvciBtb3JlIHRvcGljIGZpbHRlcnMgYnkgcXVldWluZyBhIFNVQlNDUklCRSBwYWNrZXQgdG8gYmUgc2VudCB0byB0aGUgc2VydmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhY2tldCBTVUJTQ1JJQkUgcGFja2V0IHRvIHNlbmQgdG8gdGhlIHNlcnZlclxuICAgICAqIEByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCBhbiBlcnJvciBvciByZXNvbHZlZCB3aXRoIHRoZSBTVUJBQ0sgcmVzcG9uc2VcbiAgICAgKi9cbiAgICBzdWJzY3JpYmUocGFja2V0KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGN1cnJpZWRQcm9taXNlQ2FsbGJhY2soY2xpZW50LCBlcnJvckNvZGUsIHN1YmFjaykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTXF0dDVDbGllbnQuX3Nfb25fc3ViYWNrX2NhbGxiYWNrKHJlc29sdmUsIHJlamVjdCwgY2xpZW50LCBlcnJvckNvZGUsIHN1YmFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGJpbmRpbmdfMS5kZWZhdWx0Lm1xdHQ1X2NsaWVudF9zdWJzY3JpYmUodGhpcy5uYXRpdmVfaGFuZGxlKCksIHBhY2tldCwgY3VycmllZFByb21pc2VDYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVuc3Vic2NyaWJlIGZyb20gb25lIG9yIG1vcmUgdG9waWMgZmlsdGVycyBieSBxdWV1aW5nIGFuIFVOU1VCU0NSSUJFIHBhY2tldCB0byBiZSBzZW50IHRvIHRoZSBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFja2V0IFVOU1VCU0NSSUJFIHBhY2tldCB0byBzZW5kIHRvIHRoZSBzZXJ2ZXJcbiAgICAgKiBAcmV0dXJucyBhIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlamVjdGVkIHdpdGggYW4gZXJyb3Igb3IgcmVzb2x2ZWQgd2l0aCB0aGUgVU5TVUJBQ0sgcmVzcG9uc2VcbiAgICAgKi9cbiAgICB1bnN1YnNjcmliZShwYWNrZXQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gY3VycmllZFByb21pc2VDYWxsYmFjayhjbGllbnQsIGVycm9yQ29kZSwgdW5zdWJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1xdHQ1Q2xpZW50Ll9zX29uX3Vuc3ViYWNrX2NhbGxiYWNrKHJlc29sdmUsIHJlamVjdCwgY2xpZW50LCBlcnJvckNvZGUsIHVuc3ViYWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYmluZGluZ18xLmRlZmF1bHQubXF0dDVfY2xpZW50X3Vuc3Vic2NyaWJlKHRoaXMubmF0aXZlX2hhbmRsZSgpLCBwYWNrZXQsIGN1cnJpZWRQcm9taXNlQ2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIGEgbWVzc2FnZSB0byBzdWJzY3JpYmluZyBjbGllbnRzIGJ5IHF1ZXVpbmcgYSBQVUJMSVNIIHBhY2tldCB0byBiZSBzZW50IHRvIHRoZSBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFja2V0IFBVQkxJU0ggcGFja2V0IHRvIHNlbmQgdG8gdGhlIHNlcnZlclxuICAgICAqIEByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCBhbiBlcnJvciBvciByZXNvbHZlZCB3aXRoIHRoZSBQVUJBQ0sgcmVzcG9uc2UgKFFvUyAxKSBvclxuICAgICAqIHVuZGVmaW5lZCAoUW9TIDApXG4gICAgICovXG4gICAgcHVibGlzaChwYWNrZXQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHBhY2tldCAmJiBwYWNrZXQucGF5bG9hZCkge1xuICAgICAgICAgICAgICAgICAgICBwYWNrZXQucGF5bG9hZCA9IG1xdHRfc2hhcmVkLm5vcm1hbGl6ZV9wYXlsb2FkKHBhY2tldC5wYXlsb2FkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gY3VycmllZFByb21pc2VDYWxsYmFjayhjbGllbnQsIGVycm9yQ29kZSwgcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBNcXR0NUNsaWVudC5fc19vbl9wdWJhY2tfY2FsbGJhY2socmVzb2x2ZSwgcmVqZWN0LCBjbGllbnQsIGVycm9yQ29kZSwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYmluZGluZ18xLmRlZmF1bHQubXF0dDVfY2xpZW50X3B1Ymxpc2godGhpcy5uYXRpdmVfaGFuZGxlKCksIHBhY2tldCwgY3VycmllZFByb21pc2VDYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1ZXJpZXMgYSBzbWFsbCBzZXQgb2YgbnVtZXJpY2FsIHN0YXRpc3RpY3MgYWJvdXQgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGNsaWVudCdzIG9wZXJhdGlvbiBxdWV1ZVxuICAgICAqXG4gICAgICogQGdyb3VwIE5vZGUtb25seVxuICAgICAqL1xuICAgIGdldFF1ZXVlU3RhdGlzdGljcygpIHtcbiAgICAgICAgcmV0dXJuIGJpbmRpbmdfMS5kZWZhdWx0Lm1xdHQ1X2NsaWVudF9nZXRfcXVldWVfc3RhdGlzdGljcyh0aGlzLm5hdGl2ZV9oYW5kbGUoKSk7XG4gICAgfVxuICAgIG9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICBzdXBlci5vbihldmVudCwgbGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLypcbiAgICAgKiBQcml2YXRlIGhlbHBlciBmdW5jdGlvbnNcbiAgICAgKlxuICAgICAqIENhbGxiYWNrcyBjb21lIHRocm91Z2ggc3RhdGljIGZ1bmN0aW9ucyBzbyB0aGF0IHRoZSBuYXRpdmUgdGhyZWFkc2FmZSBmdW5jdGlvbiBvYmplY3RzIGRvIG5vdFxuICAgICAqIGNhcHR1cmUgdGhlIGNsaWVudCBvYmplY3QgaXRzZWxmLCBzaW1wbGlmeWluZyB0aGUgbnVtYmVyIG9mIHN0cm9uZyByZWZlcmVuY2VzIHRvIHRoZSBjbGllbnQgZmxvYXRpbmcgYXJvdW5kLlxuICAgICAqL1xuICAgIHN0YXRpYyBfc19vbl9zdG9wcGVkKGNsaWVudCkge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgIGxldCBzdG9wcGVkRXZlbnQgPSB7fTtcbiAgICAgICAgICAgIGNsaWVudC5lbWl0KE1xdHQ1Q2xpZW50LlNUT1BQRUQsIHN0b3BwZWRFdmVudCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgX3Nfb25fYXR0ZW1wdGluZ19jb25uZWN0KGNsaWVudCkge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgIGxldCBhdHRlbXB0aW5nQ29ubmVjdEV2ZW50ID0ge307XG4gICAgICAgICAgICBjbGllbnQuZW1pdChNcXR0NUNsaWVudC5BVFRFTVBUSU5HX0NPTk5FQ1QsIGF0dGVtcHRpbmdDb25uZWN0RXZlbnQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIF9zX29uX2Nvbm5lY3Rpb25fc3VjY2VzcyhjbGllbnQsIGNvbm5hY2ssIHNldHRpbmdzKSB7XG4gICAgICAgIGxldCBjb25uZWN0aW9uU3VjY2Vzc0V2ZW50ID0ge1xuICAgICAgICAgICAgY29ubmFjazogY29ubmFjayxcbiAgICAgICAgICAgIHNldHRpbmdzOiBzZXR0aW5nc1xuICAgICAgICB9O1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgIGNsaWVudC5lbWl0KE1xdHQ1Q2xpZW50LkNPTk5FQ1RJT05fU1VDQ0VTUywgY29ubmVjdGlvblN1Y2Nlc3NFdmVudCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgX3Nfb25fY29ubmVjdGlvbl9mYWlsdXJlKGNsaWVudCwgZXJyb3IsIGNvbm5hY2spIHtcbiAgICAgICAgbGV0IGNvbm5lY3Rpb25GYWlsdXJlRXZlbnQgPSB7XG4gICAgICAgICAgICBlcnJvcjogZXJyb3JcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGNvbm5hY2sgIT09IG51bGwgJiYgY29ubmFjayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25uZWN0aW9uRmFpbHVyZUV2ZW50LmNvbm5hY2sgPSBjb25uYWNrO1xuICAgICAgICB9XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgY2xpZW50LmVtaXQoTXF0dDVDbGllbnQuQ09OTkVDVElPTl9GQUlMVVJFLCBjb25uZWN0aW9uRmFpbHVyZUV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBfc19vbl9kaXNjb25uZWN0aW9uKGNsaWVudCwgZXJyb3IsIGRpc2Nvbm5lY3QpIHtcbiAgICAgICAgbGV0IGRpc2Nvbm5lY3Rpb25FdmVudCA9IHtcbiAgICAgICAgICAgIGVycm9yOiBlcnJvclxuICAgICAgICB9O1xuICAgICAgICBpZiAoZGlzY29ubmVjdCAhPT0gbnVsbCAmJiBkaXNjb25uZWN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRpc2Nvbm5lY3Rpb25FdmVudC5kaXNjb25uZWN0ID0gZGlzY29ubmVjdDtcbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgIGNsaWVudC5lbWl0KE1xdHQ1Q2xpZW50LkRJU0NPTk5FQ1RJT04sIGRpc2Nvbm5lY3Rpb25FdmVudCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgX3Nfb25fc3ViYWNrX2NhbGxiYWNrKHJlc29sdmUsIHJlamVjdCwgY2xpZW50LCBlcnJvckNvZGUsIHN1YmFjaykge1xuICAgICAgICBpZiAoZXJyb3JDb2RlID09IDAgJiYgc3ViYWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc29sdmUoc3ViYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlamVjdChpby5lcnJvcl9jb2RlX3RvX3N0cmluZyhlcnJvckNvZGUpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgX3Nfb25fdW5zdWJhY2tfY2FsbGJhY2socmVzb2x2ZSwgcmVqZWN0LCBjbGllbnQsIGVycm9yQ29kZSwgdW5zdWJhY2spIHtcbiAgICAgICAgaWYgKGVycm9yQ29kZSA9PSAwICYmIHVuc3ViYWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc29sdmUodW5zdWJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KGlvLmVycm9yX2NvZGVfdG9fc3RyaW5nKGVycm9yQ29kZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBfc19vbl9wdWJhY2tfY2FsbGJhY2socmVzb2x2ZSwgcmVqZWN0LCBjbGllbnQsIGVycm9yQ29kZSwgcmVzdWx0KSB7XG4gICAgICAgIGlmIChlcnJvckNvZGUgPT0gMCkge1xuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KGlvLmVycm9yX2NvZGVfdG9fc3RyaW5nKGVycm9yQ29kZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBfc19vbl9tZXNzYWdlX3JlY2VpdmVkKGNsaWVudCwgbWVzc2FnZSkge1xuICAgICAgICBsZXQgbWVzc2FnZVJlY2VpdmVkRXZlbnQgPSB7XG4gICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlXG4gICAgICAgIH07XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgY2xpZW50LmVtaXQoTXF0dDVDbGllbnQuTUVTU0FHRV9SRUNFSVZFRCwgbWVzc2FnZVJlY2VpdmVkRXZlbnQpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLk1xdHQ1Q2xpZW50ID0gTXF0dDVDbGllbnQ7XG4vKipcbiAqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgY2xpZW50IGVuY291bnRlcnMgYSBzZXJpb3VzIGVycm9yIGNvbmRpdGlvbiwgc3VjaCBhcyBpbnZhbGlkIGlucHV0LCBuYXBpIGZhaWx1cmVzLCBhbmRcbiAqIG90aGVyIHBvdGVudGlhbGx5IHVucmVjb3ZlcmFibGUgc2l0dWF0aW9ucy5cbiAqXG4gKiBMaXN0ZW5lciB0eXBlOiB7QGxpbmsgRXJyb3JFdmVudExpc3RlbmVyfVxuICpcbiAqIEBldmVudFxuICovXG5NcXR0NUNsaWVudC5FUlJPUiA9ICdlcnJvcic7XG4vKipcbiAqIEV2ZW50IGVtaXR0ZWQgd2hlbiBhbiBNUVRUIFBVQkxJU0ggcGFja2V0IGlzIHJlY2VpdmVkIGJ5IHRoZSBjbGllbnQuXG4gKlxuICogTGlzdGVuZXIgdHlwZToge0BsaW5rIE1lc3NhZ2VSZWNlaXZlZEV2ZW50TGlzdGVuZXJ9XG4gKlxuICogQGV2ZW50XG4gKi9cbk1xdHQ1Q2xpZW50Lk1FU1NBR0VfUkVDRUlWRUQgPSAnbWVzc2FnZVJlY2VpdmVkJztcbi8qKlxuICogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBjbGllbnQgYmVnaW5zIGEgY29ubmVjdGlvbiBhdHRlbXB0LlxuICpcbiAqIExpc3RlbmVyIHR5cGU6IHtAbGluayBBdHRlbXB0aW5nQ29ubmVjdEV2ZW50TGlzdGVuZXJ9XG4gKlxuICogQGV2ZW50XG4gKi9cbk1xdHQ1Q2xpZW50LkFUVEVNUFRJTkdfQ09OTkVDVCA9ICdhdHRlbXB0aW5nQ29ubmVjdCc7XG4vKipcbiAqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgY2xpZW50IHN1Y2Nlc3NmdWxseSBlc3RhYmxpc2hlcyBhbiBNUVRUIGNvbm5lY3Rpb24uICBPbmx5IGVtaXR0ZWQgYWZ0ZXJcbiAqIGFuIHtAbGluayBBVFRFTVBUSU5HX0NPTk5FQ1QgYXR0ZW1wdGluZ0Nvbm5lY3R9IGV2ZW50LlxuICpcbiAqIExpc3RlbmVyIHR5cGU6IHtAbGluayBDb25uZWN0aW9uU3VjY2Vzc0V2ZW50TGlzdGVuZXJ9XG4gKlxuICogQGV2ZW50XG4gKi9cbk1xdHQ1Q2xpZW50LkNPTk5FQ1RJT05fU1VDQ0VTUyA9ICdjb25uZWN0aW9uU3VjY2Vzcyc7XG4vKipcbiAqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgY2xpZW50IGZhaWxzIHRvIGVzdGFibGlzaCBhbiBNUVRUIGNvbm5lY3Rpb24uICBPbmx5IGVtaXR0ZWQgYWZ0ZXJcbiAqIGFuIHtAbGluayBBVFRFTVBUSU5HX0NPTk5FQ1QgYXR0ZW1wdGluZ0Nvbm5lY3R9IGV2ZW50LlxuICpcbiAqIExpc3RlbmVyIHR5cGU6IHtAbGluayBDb25uZWN0aW9uRmFpbHVyZUV2ZW50TGlzdGVuZXJ9XG4gKlxuICogQGV2ZW50XG4gKi9cbk1xdHQ1Q2xpZW50LkNPTk5FQ1RJT05fRkFJTFVSRSA9ICdjb25uZWN0aW9uRmFpbHVyZSc7XG4vKipcbiAqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgY2xpZW50J3MgY3VycmVudCBjb25uZWN0aW9uIGlzIGNsb3NlZCBmb3IgYW55IHJlYXNvbi4gIE9ubHkgZW1pdHRlZCBhZnRlclxuICogYSB7QGxpbmsgQ09OTkVDVElPTl9TVUNDRVNTIGNvbm5lY3Rpb25TdWNjZXNzfSBldmVudC5cbiAqXG4gKiBMaXN0ZW5lciB0eXBlOiB7QGxpbmsgRGlzY29ubmVjdGlvbkV2ZW50TGlzdGVuZXJ9XG4gKlxuICogQGV2ZW50XG4gKi9cbk1xdHQ1Q2xpZW50LkRJU0NPTk5FQ1RJT04gPSAnZGlzY29ubmVjdGlvbic7XG4vKipcbiAqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgY2xpZW50IGZpbmlzaGVzIHNodXRkb3duIGFzIGEgcmVzdWx0IG9mIHRoZSB1c2VyIGludm9raW5nIHtAbGluayBzdG9wfS5cbiAqXG4gKiBMaXN0ZW5lciB0eXBlOiB7QGxpbmsgU3RvcHBlZEV2ZW50TGlzdGVuZXJ9XG4gKlxuICogQGV2ZW50XG4gKi9cbk1xdHQ1Q2xpZW50LlNUT1BQRUQgPSAnc3RvcHBlZCc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tcXR0NS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/aws-crt/dist/native/mqtt5.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/aws-crt/dist/native/native_resource.js":
/*!*************************************************************!*\
  !*** ./node_modules/aws-crt/dist/native/native_resource.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n * SPDX-License-Identifier: Apache-2.0.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NativeResourceMixin = exports.NativeResource = void 0;\n/**\n * Represents an object allocated natively inside the AWS CRT.\n * @internal\n */\nclass NativeResource {\n    constructor(handle) {\n        this.handle = handle;\n    }\n    /** @internal */\n    native_handle() {\n        return this.handle;\n    }\n}\nexports.NativeResource = NativeResource;\n/**\n * Represents an object allocated natively inside the AWS CRT which also\n * needs a node/TS base class\n * @internal\n */\nfunction NativeResourceMixin(Base) {\n    /** @internal */\n    return class extends Base {\n        /** @internal */\n        constructor(...args) {\n            const handle = args.shift();\n            super(...args);\n            this._handle = handle;\n        }\n        /** @internal */\n        _super(handle) {\n            this._handle = handle;\n        }\n        /** @internal */\n        native_handle() {\n            return this._handle;\n        }\n    };\n}\nexports.NativeResourceMixin = NativeResourceMixin;\n//# sourceMappingURL=native_resource.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXdzLWNydC9kaXN0L25hdGl2ZS9uYXRpdmVfcmVzb3VyY2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkIsR0FBRyxzQkFBc0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGF5d2luZC8uL25vZGVfbW9kdWxlcy9hd3MtY3J0L2Rpc3QvbmF0aXZlL25hdGl2ZV9yZXNvdXJjZS5qcz85MjUxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjAuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTmF0aXZlUmVzb3VyY2VNaXhpbiA9IGV4cG9ydHMuTmF0aXZlUmVzb3VyY2UgPSB2b2lkIDA7XG4vKipcbiAqIFJlcHJlc2VudHMgYW4gb2JqZWN0IGFsbG9jYXRlZCBuYXRpdmVseSBpbnNpZGUgdGhlIEFXUyBDUlQuXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgTmF0aXZlUmVzb3VyY2Uge1xuICAgIGNvbnN0cnVjdG9yKGhhbmRsZSkge1xuICAgICAgICB0aGlzLmhhbmRsZSA9IGhhbmRsZTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIG5hdGl2ZV9oYW5kbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZTtcbiAgICB9XG59XG5leHBvcnRzLk5hdGl2ZVJlc291cmNlID0gTmF0aXZlUmVzb3VyY2U7XG4vKipcbiAqIFJlcHJlc2VudHMgYW4gb2JqZWN0IGFsbG9jYXRlZCBuYXRpdmVseSBpbnNpZGUgdGhlIEFXUyBDUlQgd2hpY2ggYWxzb1xuICogbmVlZHMgYSBub2RlL1RTIGJhc2UgY2xhc3NcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBOYXRpdmVSZXNvdXJjZU1peGluKEJhc2UpIHtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgcmV0dXJuIGNsYXNzIGV4dGVuZHMgQmFzZSB7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gYXJncy5zaGlmdCgpO1xuICAgICAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGUgPSBoYW5kbGU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBfc3VwZXIoaGFuZGxlKSB7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGUgPSBoYW5kbGU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBuYXRpdmVfaGFuZGxlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZTtcbiAgICAgICAgfVxuICAgIH07XG59XG5leHBvcnRzLk5hdGl2ZVJlc291cmNlTWl4aW4gPSBOYXRpdmVSZXNvdXJjZU1peGluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmF0aXZlX3Jlc291cmNlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/aws-crt/dist/native/native_resource.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/aws-crt/package.json":
/*!*******************************************!*\
  !*** ./node_modules/aws-crt/package.json ***!
  \*******************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"name":"aws-crt","version":"1.18.0","description":"NodeJS/browser bindings to the aws-c-* libraries","homepage":"https://github.com/awslabs/aws-crt-nodejs","repository":{"type":"git","url":"git+https://github.com/awslabs/aws-crt-nodejs.git"},"contributors":["AWS Common Runtime Team <aws-sdk-common-runtime@amazon.com>"],"license":"Apache-2.0","main":"./dist/index.js","browser":"./dist.browser/browser.js","types":"./dist/index.d.ts","scripts":{"tsc":"node ./scripts/tsc.js","test":"npm run test:native","test:node":"npm run test:native","test:native":"npx jest --runInBand --verbose --config test/native/jest.config.js --forceExit","test:browser":"npx jest --runInBand --verbose --config test/browser/jest.config.js --forceExit","test:browser:ci":"npm run install:puppeteer && npm run test:browser","install:puppeteer":"npm install --save-dev jest-puppeteer puppeteer @types/puppeteer","prepare":"node ./scripts/tsc.js && node ./scripts/install.js","install":"node ./scripts/install.js"},"devDependencies":{"@types/crypto-js":"^3.1.43","@types/jest":"^27.0.1","@types/node":"^10.17.54","@types/prettier":"2.6.0","@types/puppeteer":"^5.4.7","@types/uuid":"^3.4.8","@types/ws":"^7.4.7","aws-sdk":"^2.848.0","https-proxy-agent":"^5.0.1","jest":"^27.2.1","jest-puppeteer":"^5.0.4","jest-runtime":"^27.2.1","puppeteer":"^3.3.0","ts-jest":"^27.0.5","typedoc":"^0.22.18","typedoc-plugin-merge-modules":"^3.1.0","typescript":"^4.7.4","uuid":"^8.3.2","yargs":"^17.2.1","cmake-js":"^6.3.2","tar":"^6.1.11"},"dependencies":{"@aws-sdk/util-utf8-browser":"^3.109.0","@httptoolkit/websocket-stream":"^6.0.0","axios":"^0.24.0","buffer":"^6.0.3","crypto-js":"^4.0.0","mqtt":"^4.3.7","process":"^0.11.10"}}');

/***/ })

};
;