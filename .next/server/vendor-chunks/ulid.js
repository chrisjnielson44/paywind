/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ulid";
exports.ids = ["vendor-chunks/ulid"];
exports.modules = {

/***/ "(ssr)/./node_modules/ulid/dist/index.umd.js":
/*!*********************************************!*\
  !*** ./node_modules/ulid/dist/index.umd.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("(function (global, factory) {\n\t true ? factory(exports) :\n\t0;\n}(this, (function (exports) { 'use strict';\n\nfunction createError(message) {\n    var err = new Error(message);\n    err.source = \"ulid\";\n    return err;\n}\n// These values should NEVER change. If\n// they do, we're no longer making ulids!\nvar ENCODING = \"0123456789ABCDEFGHJKMNPQRSTVWXYZ\"; // Crockford's Base32\nvar ENCODING_LEN = ENCODING.length;\nvar TIME_MAX = Math.pow(2, 48) - 1;\nvar TIME_LEN = 10;\nvar RANDOM_LEN = 16;\nfunction replaceCharAt(str, index, char) {\n    if (index > str.length - 1) {\n        return str;\n    }\n    return str.substr(0, index) + char + str.substr(index + 1);\n}\nfunction incrementBase32(str) {\n    var done = undefined;\n    var index = str.length;\n    var char = void 0;\n    var charIndex = void 0;\n    var maxCharIndex = ENCODING_LEN - 1;\n    while (!done && index-- >= 0) {\n        char = str[index];\n        charIndex = ENCODING.indexOf(char);\n        if (charIndex === -1) {\n            throw createError(\"incorrectly encoded string\");\n        }\n        if (charIndex === maxCharIndex) {\n            str = replaceCharAt(str, index, ENCODING[0]);\n            continue;\n        }\n        done = replaceCharAt(str, index, ENCODING[charIndex + 1]);\n    }\n    if (typeof done === \"string\") {\n        return done;\n    }\n    throw createError(\"cannot increment this string\");\n}\nfunction randomChar(prng) {\n    var rand = Math.floor(prng() * ENCODING_LEN);\n    if (rand === ENCODING_LEN) {\n        rand = ENCODING_LEN - 1;\n    }\n    return ENCODING.charAt(rand);\n}\nfunction encodeTime(now, len) {\n    if (isNaN(now)) {\n        throw new Error(now + \" must be a number\");\n    }\n    if (now > TIME_MAX) {\n        throw createError(\"cannot encode time greater than \" + TIME_MAX);\n    }\n    if (now < 0) {\n        throw createError(\"time must be positive\");\n    }\n    if (Number.isInteger(now) === false) {\n        throw createError(\"time must be an integer\");\n    }\n    var mod = void 0;\n    var str = \"\";\n    for (; len > 0; len--) {\n        mod = now % ENCODING_LEN;\n        str = ENCODING.charAt(mod) + str;\n        now = (now - mod) / ENCODING_LEN;\n    }\n    return str;\n}\nfunction encodeRandom(len, prng) {\n    var str = \"\";\n    for (; len > 0; len--) {\n        str = randomChar(prng) + str;\n    }\n    return str;\n}\nfunction decodeTime(id) {\n    if (id.length !== TIME_LEN + RANDOM_LEN) {\n        throw createError(\"malformed ulid\");\n    }\n    var time = id.substr(0, TIME_LEN).split(\"\").reverse().reduce(function (carry, char, index) {\n        var encodingIndex = ENCODING.indexOf(char);\n        if (encodingIndex === -1) {\n            throw createError(\"invalid character found: \" + char);\n        }\n        return carry += encodingIndex * Math.pow(ENCODING_LEN, index);\n    }, 0);\n    if (time > TIME_MAX) {\n        throw createError(\"malformed ulid, timestamp too large\");\n    }\n    return time;\n}\nfunction detectPrng() {\n    var allowInsecure = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var root = arguments[1];\n\n    if (!root) {\n        root = typeof window !== \"undefined\" ? window : null;\n    }\n    var browserCrypto = root && (root.crypto || root.msCrypto);\n    if (browserCrypto) {\n        return function () {\n            var buffer = new Uint8Array(1);\n            browserCrypto.getRandomValues(buffer);\n            return buffer[0] / 0xff;\n        };\n    } else {\n        try {\n            var nodeCrypto = __webpack_require__(/*! crypto */ \"crypto\");\n            return function () {\n                return nodeCrypto.randomBytes(1).readUInt8() / 0xff;\n            };\n        } catch (e) {}\n    }\n    if (allowInsecure) {\n        try {\n            console.error(\"secure crypto unusable, falling back to insecure Math.random()!\");\n        } catch (e) {}\n        return function () {\n            return Math.random();\n        };\n    }\n    throw createError(\"secure crypto unusable, insecure Math.random not allowed\");\n}\nfunction factory(currPrng) {\n    if (!currPrng) {\n        currPrng = detectPrng();\n    }\n    return function ulid(seedTime) {\n        if (isNaN(seedTime)) {\n            seedTime = Date.now();\n        }\n        return encodeTime(seedTime, TIME_LEN) + encodeRandom(RANDOM_LEN, currPrng);\n    };\n}\nfunction monotonicFactory(currPrng) {\n    if (!currPrng) {\n        currPrng = detectPrng();\n    }\n    var lastTime = 0;\n    var lastRandom = void 0;\n    return function ulid(seedTime) {\n        if (isNaN(seedTime)) {\n            seedTime = Date.now();\n        }\n        if (seedTime <= lastTime) {\n            var incrementedRandom = lastRandom = incrementBase32(lastRandom);\n            return encodeTime(lastTime, TIME_LEN) + incrementedRandom;\n        }\n        lastTime = seedTime;\n        var newRandom = lastRandom = encodeRandom(RANDOM_LEN, currPrng);\n        return encodeTime(seedTime, TIME_LEN) + newRandom;\n    };\n}\nvar ulid = factory();\n\nexports.replaceCharAt = replaceCharAt;\nexports.incrementBase32 = incrementBase32;\nexports.randomChar = randomChar;\nexports.encodeTime = encodeTime;\nexports.encodeRandom = encodeRandom;\nexports.decodeTime = decodeTime;\nexports.detectPrng = detectPrng;\nexports.factory = factory;\nexports.monotonicFactory = monotonicFactory;\nexports.ulid = ulid;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdWxpZC9kaXN0L2luZGV4LnVtZC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLENBQUMsS0FBNEQ7QUFDN0QsQ0FBQyxDQUM2QjtBQUM5QixDQUFDLDZCQUE2Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSw2QkFBNkIsbUJBQU8sQ0FBQyxzQkFBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0NBQStDLGFBQWE7O0FBRTVELENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wYXl3aW5kLy4vbm9kZV9tb2R1bGVzL3VsaWQvZGlzdC9pbmRleC51bWQuanM/NDM5YiJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG5cdChmYWN0b3J5KChnbG9iYWwuVUxJRCA9IHt9KSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBjcmVhdGVFcnJvcihtZXNzYWdlKSB7XG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICBlcnIuc291cmNlID0gXCJ1bGlkXCI7XG4gICAgcmV0dXJuIGVycjtcbn1cbi8vIFRoZXNlIHZhbHVlcyBzaG91bGQgTkVWRVIgY2hhbmdlLiBJZlxuLy8gdGhleSBkbywgd2UncmUgbm8gbG9uZ2VyIG1ha2luZyB1bGlkcyFcbnZhciBFTkNPRElORyA9IFwiMDEyMzQ1Njc4OUFCQ0RFRkdISktNTlBRUlNUVldYWVpcIjsgLy8gQ3JvY2tmb3JkJ3MgQmFzZTMyXG52YXIgRU5DT0RJTkdfTEVOID0gRU5DT0RJTkcubGVuZ3RoO1xudmFyIFRJTUVfTUFYID0gTWF0aC5wb3coMiwgNDgpIC0gMTtcbnZhciBUSU1FX0xFTiA9IDEwO1xudmFyIFJBTkRPTV9MRU4gPSAxNjtcbmZ1bmN0aW9uIHJlcGxhY2VDaGFyQXQoc3RyLCBpbmRleCwgY2hhcikge1xuICAgIGlmIChpbmRleCA+IHN0ci5sZW5ndGggLSAxKSB7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIHJldHVybiBzdHIuc3Vic3RyKDAsIGluZGV4KSArIGNoYXIgKyBzdHIuc3Vic3RyKGluZGV4ICsgMSk7XG59XG5mdW5jdGlvbiBpbmNyZW1lbnRCYXNlMzIoc3RyKSB7XG4gICAgdmFyIGRvbmUgPSB1bmRlZmluZWQ7XG4gICAgdmFyIGluZGV4ID0gc3RyLmxlbmd0aDtcbiAgICB2YXIgY2hhciA9IHZvaWQgMDtcbiAgICB2YXIgY2hhckluZGV4ID0gdm9pZCAwO1xuICAgIHZhciBtYXhDaGFySW5kZXggPSBFTkNPRElOR19MRU4gLSAxO1xuICAgIHdoaWxlICghZG9uZSAmJiBpbmRleC0tID49IDApIHtcbiAgICAgICAgY2hhciA9IHN0cltpbmRleF07XG4gICAgICAgIGNoYXJJbmRleCA9IEVOQ09ESU5HLmluZGV4T2YoY2hhcik7XG4gICAgICAgIGlmIChjaGFySW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVFcnJvcihcImluY29ycmVjdGx5IGVuY29kZWQgc3RyaW5nXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFySW5kZXggPT09IG1heENoYXJJbmRleCkge1xuICAgICAgICAgICAgc3RyID0gcmVwbGFjZUNoYXJBdChzdHIsIGluZGV4LCBFTkNPRElOR1swXSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBkb25lID0gcmVwbGFjZUNoYXJBdChzdHIsIGluZGV4LCBFTkNPRElOR1tjaGFySW5kZXggKyAxXSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZG9uZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gZG9uZTtcbiAgICB9XG4gICAgdGhyb3cgY3JlYXRlRXJyb3IoXCJjYW5ub3QgaW5jcmVtZW50IHRoaXMgc3RyaW5nXCIpO1xufVxuZnVuY3Rpb24gcmFuZG9tQ2hhcihwcm5nKSB7XG4gICAgdmFyIHJhbmQgPSBNYXRoLmZsb29yKHBybmcoKSAqIEVOQ09ESU5HX0xFTik7XG4gICAgaWYgKHJhbmQgPT09IEVOQ09ESU5HX0xFTikge1xuICAgICAgICByYW5kID0gRU5DT0RJTkdfTEVOIC0gMTtcbiAgICB9XG4gICAgcmV0dXJuIEVOQ09ESU5HLmNoYXJBdChyYW5kKTtcbn1cbmZ1bmN0aW9uIGVuY29kZVRpbWUobm93LCBsZW4pIHtcbiAgICBpZiAoaXNOYU4obm93KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3Iobm93ICsgXCIgbXVzdCBiZSBhIG51bWJlclwiKTtcbiAgICB9XG4gICAgaWYgKG5vdyA+IFRJTUVfTUFYKSB7XG4gICAgICAgIHRocm93IGNyZWF0ZUVycm9yKFwiY2Fubm90IGVuY29kZSB0aW1lIGdyZWF0ZXIgdGhhbiBcIiArIFRJTUVfTUFYKTtcbiAgICB9XG4gICAgaWYgKG5vdyA8IDApIHtcbiAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3IoXCJ0aW1lIG11c3QgYmUgcG9zaXRpdmVcIik7XG4gICAgfVxuICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKG5vdykgPT09IGZhbHNlKSB7XG4gICAgICAgIHRocm93IGNyZWF0ZUVycm9yKFwidGltZSBtdXN0IGJlIGFuIGludGVnZXJcIik7XG4gICAgfVxuICAgIHZhciBtb2QgPSB2b2lkIDA7XG4gICAgdmFyIHN0ciA9IFwiXCI7XG4gICAgZm9yICg7IGxlbiA+IDA7IGxlbi0tKSB7XG4gICAgICAgIG1vZCA9IG5vdyAlIEVOQ09ESU5HX0xFTjtcbiAgICAgICAgc3RyID0gRU5DT0RJTkcuY2hhckF0KG1vZCkgKyBzdHI7XG4gICAgICAgIG5vdyA9IChub3cgLSBtb2QpIC8gRU5DT0RJTkdfTEVOO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufVxuZnVuY3Rpb24gZW5jb2RlUmFuZG9tKGxlbiwgcHJuZykge1xuICAgIHZhciBzdHIgPSBcIlwiO1xuICAgIGZvciAoOyBsZW4gPiAwOyBsZW4tLSkge1xuICAgICAgICBzdHIgPSByYW5kb21DaGFyKHBybmcpICsgc3RyO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufVxuZnVuY3Rpb24gZGVjb2RlVGltZShpZCkge1xuICAgIGlmIChpZC5sZW5ndGggIT09IFRJTUVfTEVOICsgUkFORE9NX0xFTikge1xuICAgICAgICB0aHJvdyBjcmVhdGVFcnJvcihcIm1hbGZvcm1lZCB1bGlkXCIpO1xuICAgIH1cbiAgICB2YXIgdGltZSA9IGlkLnN1YnN0cigwLCBUSU1FX0xFTikuc3BsaXQoXCJcIikucmV2ZXJzZSgpLnJlZHVjZShmdW5jdGlvbiAoY2FycnksIGNoYXIsIGluZGV4KSB7XG4gICAgICAgIHZhciBlbmNvZGluZ0luZGV4ID0gRU5DT0RJTkcuaW5kZXhPZihjaGFyKTtcbiAgICAgICAgaWYgKGVuY29kaW5nSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVFcnJvcihcImludmFsaWQgY2hhcmFjdGVyIGZvdW5kOiBcIiArIGNoYXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYXJyeSArPSBlbmNvZGluZ0luZGV4ICogTWF0aC5wb3coRU5DT0RJTkdfTEVOLCBpbmRleCk7XG4gICAgfSwgMCk7XG4gICAgaWYgKHRpbWUgPiBUSU1FX01BWCkge1xuICAgICAgICB0aHJvdyBjcmVhdGVFcnJvcihcIm1hbGZvcm1lZCB1bGlkLCB0aW1lc3RhbXAgdG9vIGxhcmdlXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGltZTtcbn1cbmZ1bmN0aW9uIGRldGVjdFBybmcoKSB7XG4gICAgdmFyIGFsbG93SW5zZWN1cmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuICAgIHZhciByb290ID0gYXJndW1lbnRzWzFdO1xuXG4gICAgaWYgKCFyb290KSB7XG4gICAgICAgIHJvb3QgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogbnVsbDtcbiAgICB9XG4gICAgdmFyIGJyb3dzZXJDcnlwdG8gPSByb290ICYmIChyb290LmNyeXB0byB8fCByb290Lm1zQ3J5cHRvKTtcbiAgICBpZiAoYnJvd3NlckNyeXB0bykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDEpO1xuICAgICAgICAgICAgYnJvd3NlckNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYnVmZmVyKTtcbiAgICAgICAgICAgIHJldHVybiBidWZmZXJbMF0gLyAweGZmO1xuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgbm9kZUNyeXB0byA9IHJlcXVpcmUoXCJjcnlwdG9cIik7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlQ3J5cHRvLnJhbmRvbUJ5dGVzKDEpLnJlYWRVSW50OCgpIC8gMHhmZjtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuICAgIGlmIChhbGxvd0luc2VjdXJlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwic2VjdXJlIGNyeXB0byB1bnVzYWJsZSwgZmFsbGluZyBiYWNrIHRvIGluc2VjdXJlIE1hdGgucmFuZG9tKCkhXCIpO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgucmFuZG9tKCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHRocm93IGNyZWF0ZUVycm9yKFwic2VjdXJlIGNyeXB0byB1bnVzYWJsZSwgaW5zZWN1cmUgTWF0aC5yYW5kb20gbm90IGFsbG93ZWRcIik7XG59XG5mdW5jdGlvbiBmYWN0b3J5KGN1cnJQcm5nKSB7XG4gICAgaWYgKCFjdXJyUHJuZykge1xuICAgICAgICBjdXJyUHJuZyA9IGRldGVjdFBybmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVsaWQoc2VlZFRpbWUpIHtcbiAgICAgICAgaWYgKGlzTmFOKHNlZWRUaW1lKSkge1xuICAgICAgICAgICAgc2VlZFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbmNvZGVUaW1lKHNlZWRUaW1lLCBUSU1FX0xFTikgKyBlbmNvZGVSYW5kb20oUkFORE9NX0xFTiwgY3VyclBybmcpO1xuICAgIH07XG59XG5mdW5jdGlvbiBtb25vdG9uaWNGYWN0b3J5KGN1cnJQcm5nKSB7XG4gICAgaWYgKCFjdXJyUHJuZykge1xuICAgICAgICBjdXJyUHJuZyA9IGRldGVjdFBybmcoKTtcbiAgICB9XG4gICAgdmFyIGxhc3RUaW1lID0gMDtcbiAgICB2YXIgbGFzdFJhbmRvbSA9IHZvaWQgMDtcbiAgICByZXR1cm4gZnVuY3Rpb24gdWxpZChzZWVkVGltZSkge1xuICAgICAgICBpZiAoaXNOYU4oc2VlZFRpbWUpKSB7XG4gICAgICAgICAgICBzZWVkVGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlZWRUaW1lIDw9IGxhc3RUaW1lKSB7XG4gICAgICAgICAgICB2YXIgaW5jcmVtZW50ZWRSYW5kb20gPSBsYXN0UmFuZG9tID0gaW5jcmVtZW50QmFzZTMyKGxhc3RSYW5kb20pO1xuICAgICAgICAgICAgcmV0dXJuIGVuY29kZVRpbWUobGFzdFRpbWUsIFRJTUVfTEVOKSArIGluY3JlbWVudGVkUmFuZG9tO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RUaW1lID0gc2VlZFRpbWU7XG4gICAgICAgIHZhciBuZXdSYW5kb20gPSBsYXN0UmFuZG9tID0gZW5jb2RlUmFuZG9tKFJBTkRPTV9MRU4sIGN1cnJQcm5nKTtcbiAgICAgICAgcmV0dXJuIGVuY29kZVRpbWUoc2VlZFRpbWUsIFRJTUVfTEVOKSArIG5ld1JhbmRvbTtcbiAgICB9O1xufVxudmFyIHVsaWQgPSBmYWN0b3J5KCk7XG5cbmV4cG9ydHMucmVwbGFjZUNoYXJBdCA9IHJlcGxhY2VDaGFyQXQ7XG5leHBvcnRzLmluY3JlbWVudEJhc2UzMiA9IGluY3JlbWVudEJhc2UzMjtcbmV4cG9ydHMucmFuZG9tQ2hhciA9IHJhbmRvbUNoYXI7XG5leHBvcnRzLmVuY29kZVRpbWUgPSBlbmNvZGVUaW1lO1xuZXhwb3J0cy5lbmNvZGVSYW5kb20gPSBlbmNvZGVSYW5kb207XG5leHBvcnRzLmRlY29kZVRpbWUgPSBkZWNvZGVUaW1lO1xuZXhwb3J0cy5kZXRlY3RQcm5nID0gZGV0ZWN0UHJuZztcbmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG5leHBvcnRzLm1vbm90b25pY0ZhY3RvcnkgPSBtb25vdG9uaWNGYWN0b3J5O1xuZXhwb3J0cy51bGlkID0gdWxpZDtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ulid/dist/index.umd.js\n");

/***/ })

};
;